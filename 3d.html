<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Slot Circuit 3D Player</title>
    
    <!-- LIBRERÍAS EXTERNAS (CDN) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/lucide@0.263.1/dist/umd/lucide.min.js"></script>
    
    <!-- LIBRERÍAS PARA PDF Y CHART -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <!-- FUENTES DIGITALES -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <!-- THREE.JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        /* ESTILOS GLOBALES */
        script { display: none !important; }
        body { background-color: #0a0a0a; color: white; margin: 0; overflow: hidden; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; user-select: none; touch-action: none; }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .animate-in { animation: fadeIn 0.5s ease-out forwards; }
        
        /* PANTALLA DE CARGA */
        #loading-screen { position: fixed; inset: 0; background: radial-gradient(circle at center, #1e293b 0%, #020617 100%); color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 9999; text-align: center; padding: 20px; transition: opacity 0.8s ease-out; }
        .loader-title { font-size: 3rem; font-weight: 900; color: #39ff14; text-transform: uppercase; letter-spacing: -2px; margin-bottom: 2rem; text-shadow: 0 0 15px rgba(57, 255, 20, 0.8); animation: pulse-neon 2s infinite alternate; }
        .loader-bar-bg { width: 300px; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; position: relative; margin-bottom: 1rem; }
        .loader-bar-fill { position: absolute; top: 0; left: 0; bottom: 0; width: 40%; background: #39ff14; box-shadow: 0 0 10px #39ff14; animation: load-scan 1s linear infinite; }
        .loader-subtitle { font-size: 0.8rem; color: #94a3b8; letter-spacing: 2px; font-weight: bold; }
        @keyframes pulse-neon { 0% { text-shadow: 0 0 15px rgba(57, 255, 20, 0.8); opacity: 0.9; transform: scale(1); } 100% { text-shadow: 0 0 30px rgba(57, 255, 20, 1); opacity: 1; transform: scale(1.02); } }
        @keyframes load-scan { 0% { left: -40%; } 100% { left: 100%; } }
        
        /* UI HELPERS & FONTS */
        .btn-spectacular-shimmer::after {
            content: ''; position: absolute; top: 0; left: 0; width: 50%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(57, 255, 20, 0.6), transparent);
            transform: translateX(-150%) skewX(-20deg);
            animation: shimmer-slide 3s infinite cubic-bezier(0.4, 0, 0.2, 1);
        }
        @keyframes shimmer-slide { 0% { transform: translateX(-150%) skewX(-20deg); } 100% { transform: translateX(250%) skewX(-20deg); } }
        #error-msg { color: #ef4444; margin-top: 20px; max-width: 600px; display: none; border: 1px solid #ef4444; padding: 10px; border-radius: 8px; background: rgba(0,0,0,0.8); }
        .font-digital { font-family: 'Orbitron', monospace; }
        .font-timer { font-family: 'Share Tech Mono', monospace; }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        .file-input-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <h1 class="loader-title">3D PLAYER</h1>
        <div class="loader-bar-bg"><div class="loader-bar-fill"></div></div>
        <div class="loader-subtitle">CARGANDO MOTOR FÍSICO...</div>
        <div id="error-msg"></div>
    </div>
    <div id="root"></div>
    
    <script>
        window.onerror = function(msg, url, line, col, error) {
            const ls = document.getElementById('loading-screen'); const ed = document.getElementById('error-msg');
            if(ls && ed) { ls.style.zIndex="10000"; ls.style.display="flex"; ls.style.opacity="1"; ed.style.display="block"; ed.innerHTML=`<strong>Error Detectado:</strong><br>${msg}<br><small>Línea: ${line}</small>`; }
            return false;
        };
    </script>

    <script type="text/babel" data-presets="react,env">
        const { useState, useEffect, useRef } = React;

        /* --- 1. DATOS ESTÁTICOS (TRACK DEFINITIONS) --- */
        const TRACK_DEFINITIONS = {
          NINCO: { name: 'NINCO', themeColor: 'red', neonColor: '#ef4444', uiClass: 'border-red-500/50 text-red-400 shadow-[0_0_15px_rgba(239,68,68,0.3)] hover:bg-red-950/30', activeClass: 'bg-red-600 text-white shadow-[0_0_20px_rgba(239,68,68,0.6)] border-red-500', trackColor: '#111111', railColor: '#dcdcdc', slotColor: '#000000', width: 18.0, laneSpacing: 9.0, connectionBoxColor: '#ef4444' },
          SCX_ANALOG: { name: 'SCALEXTRIC', themeColor: 'yellow', neonColor: '#facc15', uiClass: 'border-yellow-500/50 text-yellow-400 shadow-[0_0_15px_rgba(250,204,21,0.3)] hover:bg-yellow-950/30', activeClass: 'bg-yellow-500 text-black shadow-[0_0_20px_rgba(250,204,21,0.6)] border-yellow-400 font-bold', trackColor: '#5a5a5a', railColor: '#d0d0d0', slotColor: '#1a1a1a', width: 15.6, laneSpacing: 7.7, connectionBoxColor: '#ef4444' },
          SCX_ADVANCE: { name: 'SCX ADVANCE', themeColor: 'blue', neonColor: '#3b82f6', uiClass: 'border-blue-500/50 text-blue-400 shadow-[0_0_15px_rgba(59,130,246,0.3)] hover:bg-blue-950/30', activeClass: 'bg-blue-600 text-white shadow-[0_0_20px_rgba(59,130,246,0.6)] border-blue-400 font-bold', trackColor: '#5a5a5a', railColor: '#d0d0d0', slotColor: '#1a1a1a', width: 15.6, laneSpacing: 7.7, connectionBoxColor: '#ef4444' },
          POLICAR: { name: 'POLICAR', themeColor: 'orange', neonColor: '#f97316', uiClass: 'border-orange-500/50 text-orange-400 shadow-[0_0_15px_rgba(249,115,22,0.3)] hover:bg-orange-950/30', activeClass: 'bg-orange-600 text-white shadow-[0_0_20px_rgba(249,115,22,0.6)] border-orange-500 font-bold', trackColor: '#1a1a1a', railColor: '#dcdcdc', slotColor: '#000000', width: 17.9, laneSpacing: 9.0, connectionBoxColor: '#333' },
          SCALEAUTO: { name: 'SCALEAUTO', themeColor: 'lime', neonColor: '#84cc16', uiClass: 'border-lime-500/50 text-lime-400 shadow-[0_0_15px_rgba(132,204,22,0.3)] hover:bg-lime-950/30', activeClass: 'bg-lime-500 text-black shadow-[0_0_20px_rgba(132,204,22,0.6)] border-lime-400 font-bold', trackColor: '#4d4d4d', railColor: '#e0e0e0', slotColor: '#111111', width: 20.0, laneSpacing: 10.0, connectionBoxColor: '#9ca3af' }
        };

        const IconWrapper = ({ name, size = 24, className, ...props }) => {
            if (typeof lucide === 'undefined' || !lucide.icons) return null;
            const iconData = lucide.icons[name];
            if (!iconData) return null;
            const [tag, attrs, children = []] = iconData;
            return <svg {...attrs} width={size} height={size} className={className} {...props}>{Array.isArray(children) && children.map(([childTag, childAttrs], index) => React.createElement(childTag, { ...childAttrs, key: index }))}</svg>;
        };
        const icons = ['Trash2','Image','Fuel','Move','Zap','Bluetooth','RotateCw','X','Repeat','PenTool','ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Square','FolderOpen','Save','FileText','Activity','Play','Pause','Flag','GitCommit','ZoomIn','ZoomOut','Crosshair','Undo2','Redo2','Layers','Clock','Hash','Plus','Minus','AlertTriangle', 'Cloud', 'CloudUpload', 'CloudDownload', 'Settings', 'Battery', 'Scale', 'Trophy', 'Timer', 'Gauge', 'Maximize', 'Minimize', 'User', 'Users'].reduce((acc, name) => { acc[name] = (p) => <IconWrapper name={name} {...p} />; return acc; }, {});
        const { Trash2, Image: ImageIcon, Fuel, Move, Zap, Bluetooth, RotateCw, X, Repeat, PenTool, ArrowUp, ArrowDown, ArrowLeft, ArrowRight, Square, FolderOpen, Save, FileText, Activity, Play, Pause, Flag, GitCommit, ZoomIn, ZoomOut, Crosshair, Undo2, Redo2, Layers, Clock, Hash, Plus, Minus, AlertTriangle, Cloud, CloudUpload, CloudDownload, Settings, Battery, Scale, Trophy, Timer, Gauge, Maximize, Minimize, User, Users } = icons;

        /* --- 2. COMPONENTES VISUALES --- */
        const MotorSVG = ({ type, color, label }) => {
            return (
                <svg viewBox="0 0 100 60" className="w-full h-full drop-shadow-lg filter transition-transform duration-500 hover:scale-105">
                    <defs>
                        <linearGradient id={`motor-body-${label}`} x1="0%" y1="0%" x2="0%" y2="100%"><stop offset="0%" stopColor="#e2e8f0" /><stop offset="50%" stopColor="#94a3b8" /><stop offset="100%" stopColor="#64748b" /></linearGradient>
                        <linearGradient id={`label-grad-${label}`} x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stopColor={color} /><stop offset="100%" stopColor="#000" stopOpacity="0.5" /></linearGradient>
                        <pattern id="copper-coil" width="4" height="4" patternUnits="userSpaceOnUse"><path d="M0,4 L4,0 M-1,1 L1,-1 M3,5 L5,3" stroke="#b45309" strokeWidth="1" /></pattern>
                    </defs>
                    <rect x="2" y="28" width="12" height="4" fill="#cbd5e1" stroke="#64748b" strokeWidth="0.5" />
                    <path d="M4,26 L8,26 L9,24 L11,24 L12,26 L12,34 L11,36 L9,36 L8,34 L4,34 Z" fill="#fbbf24" stroke="#b45309" strokeWidth="0.5" />
                    {type === 'Long Can' && (<g><rect x="14" y="15" width="76" height="30" rx="2" fill={`url(#motor-body-${label})`} stroke="#475569" strokeWidth="1" /><rect x="22" y="18" width="60" height="24" rx="1" fill={`url(#label-grad-${label})`} /><path d="M28,20 L38,20 L38,23 L28,23 Z" fill="url(#copper-coil)" stroke="#000" strokeWidth="0.5" /><path d="M48,20 L58,20 L58,23 L48,23 Z" fill="url(#copper-coil)" stroke="#000" strokeWidth="0.5" /><path d="M68,20 L78,20 L78,23 L68,23 Z" fill="url(#copper-coil)" stroke="#000" strokeWidth="0.5" /></g>)}
                    {type === 'Short Can' && (<g><rect x="20" y="12" width="56" height="36" rx="6" fill={`url(#motor-body-${label})`} stroke="#475569" strokeWidth="1" /><ellipse cx="48" cy="30" rx="22" ry="14" fill={`url(#label-grad-${label})`} stroke="rgba(255,255,255,0.2)" strokeWidth="1" /><circle cx="30" cy="30" r="1.5" fill="#1e293b" /><circle cx="66" cy="30" r="1.5" fill="#1e293b" /></g>)}
                    {type === 'Flat' && (<g><rect x="14" y="20" width="76" height="20" rx="1" fill={`url(#motor-body-${label})`} stroke="#475569" strokeWidth="1" /><rect x="24" y="22" width="56" height="16" rx="2" fill="#111" stroke="#333" strokeWidth="0.5" /><rect x="26" y="24" width="52" height="12" rx="1" fill="url(#copper-coil)" /><path d="M20,20 L40,20 L35,40 L20,40 Z" fill={color} opacity="0.9" /></g>)}
                    <text x="50" y="33" fontSize="7" fontWeight="900" fill="white" textAnchor="middle" style={{textShadow: '0 1px 2px black'}} fontFamily="Arial, sans-serif" letterSpacing="0.5px">{label}</text>
                    <path d="M90,24 L94,24 L94,18 L96,18 L96,26 L90,26 Z" fill="#fbbf24" stroke="#b45309" strokeWidth="0.5" /> <path d="M90,36 L94,36 L94,42 L96,42 L96,34 L90,34 Z" fill="#fbbf24" stroke="#b45309" strokeWidth="0.5" />
                </svg>
            );
        };
        const TireSVG = ({ type, rimColor, label, compoundColor }) => (<svg viewBox="0 0 60 60" className="w-full h-full drop-shadow-md transform transition-transform hover:scale-110"><defs><radialGradient id={`rim-${label}`} cx="50%" cy="50%" r="50%"><stop offset="0%" stopColor="#fff"/><stop offset="100%" stopColor={rimColor}/></radialGradient></defs><circle cx="30" cy="30" r="28" fill="#1a1a1a" stroke="#000" strokeWidth="1" />{type === 'Lluvia' && <path d="M10,10 L50,50 M50,10 L10,50 M30,5 L30,55 M5,30 L55,30" stroke="#333" strokeWidth="1" opacity="0.3" />}<circle cx="30" cy="30" r="18" fill={`url(#rim-${label})`} stroke="#444" strokeWidth="1" /><circle cx="30" cy="30" r="3" fill="#111" /><text x="30" y="54" fontSize="7" fontWeight="900" fill={compoundColor} textAnchor="middle" style={{textShadow:'0 1px 1px black'}}>{label}</text></svg>);
        const GearSVG = ({ teeth, color, material }) => (<svg viewBox="0 0 60 60" className="w-full h-full transform transition-transform hover:rotate-90 duration-500"><path d="M30,2 L32,6 L36,6 L38,2 L42,4 L42,8 L46,10 L48,6 L52,9 L50,14 L54,16 L58,14 L58,19 L54,22 L56,26 L60,28 L58,32 L54,34 L56,38 L58,41 L54,44 L50,42 L48,46 L52,50 L48,54 L44,52 L42,56 L38,58 L36,54 L32,54 L30,58 L26,56 L24,52 L20,54 L16,50 L20,46 L18,42 L14,44 L10,41 L12,37 L8,34 L4,32 L2,28 L6,26 L8,22 L4,19 L4,14 L8,16 L12,14 L10,9 L14,6 L16,10 L20,8 L20,4 L24,2 L26,6 L30,6 Z" fill={color} stroke="#000" strokeWidth="0.5"/><circle cx="30" cy="30" r="10" fill={material==='Bronce'?'#92400e':(material==='Dural'?'#94a3b8':'#e2e8f0')} stroke="#000" strokeWidth="1"/><circle cx="30" cy="30" r="3" fill="#000"/></svg>);
        const PinionSVG = ({ teeth, material, diameter }) => (<svg viewBox="0 0 40 40" className="w-full h-full transform transition-transform hover:rotate-180 duration-500"><circle cx="20" cy="20" r="18" fill="none" stroke="#666" strokeWidth="2" strokeDasharray="3,1"/><path d="M20,2 L23,5 L28,5 L30,8 L35,10 L35,15 L32,18 L35,22 L35,28 L30,32 L25,32 L22,35 L18,35 L15,32 L10,32 L5,28 L5,22 L8,18 L5,15 L5,10 L10,8 L12,5 L17,5 Z" fill={material==='Latón'?'#fbbf24':(material==='Nylon'?'#fff':'#94a3b8')} stroke="#000" strokeWidth="0.5"/><circle cx="20" cy="20" r="4" fill="#000"/></svg>);
        
        const LapTimeChart = ({ results, carSetups }) => {
            const width = 800, height = 300, padding = 40;
            const carIds = Object.keys(results).map(Number);
            
            const allPoints = [];
            carIds.forEach(id => {
                results[id].forEach(lap => {
                    if(lap.time > 0) allPoints.push(lap.time);
                });
            });
            
            if (allPoints.length === 0) return null;

            const minTime = Math.min(...allPoints) * 0.95; // Un poco de margen abajo
            const maxTime = Math.max(...allPoints) * 1.05; // Un poco de margen arriba
            const timeRange = maxTime - minTime || 1;
            
            const maxLap = Math.max(...carIds.map(id => results[id].length));
            const lapRange = Math.max(1, maxLap - 1);

            const getX = (lapIdx) => padding + (lapIdx / lapRange) * (width - padding * 2);
            const getY = (time) => height - padding - ((time - minTime) / timeRange) * (height - padding * 2);

            const formatTime = (ms) => (ms/1000).toFixed(2);

            return (
                <div className="w-full bg-[#050a05] border border-gray-700 rounded-xl p-4 relative">
                    <h4 className="text-xs font-bold text-gray-400 uppercase tracking-widest mb-2 text-center">ANÁLISIS DE RITMO VUELTA A VUELTA</h4>
                    <svg viewBox={`0 0 ${width} ${height}`} className="w-full h-auto overflow-visible">
                        {[0, 0.25, 0.5, 0.75, 1].map((pct, i) => {
                            const y = height - padding - pct * (height - padding * 2);
                            const val = minTime + pct * timeRange;
                            return (
                                <g key={i}>
                                    <line x1={padding} y1={y} x2={width - padding} y2={y} stroke="#333" strokeWidth="1" strokeDasharray="4,4" />
                                    <text x={padding - 5} y={y + 3} textAnchor="end" className="text-[10px] fill-gray-500 font-mono">{formatTime(val)}s</text>
                                </g>
                            );
                        })}
                        <line x1={padding} y1={height - padding} x2={width - padding} y2={height - padding} stroke="#666" strokeWidth="1" />
                        <line x1={padding} y1={padding} x2={padding} y2={height - padding} stroke="#666" strokeWidth="1" />
                        {carIds.map(id => {
                            const data = results[id];
                            if (data.length < 1) return null;
                            let d = "";
                            data.forEach((lap, i) => {
                                const x = getX(i);
                                const y = getY(lap.time);
                                if (i === 0) d += `M ${x} ${y}`;
                                else d += ` L ${x} ${y}`;
                            });

                            return (
                                <g key={id}>
                                    <path d={d} fill="none" stroke={carSetups[id]?.color || '#fff'} strokeWidth="3" strokeLinecap="round" strokeLinejoin="round" />
                                    {data.map((lap, i) => (
                                        <circle key={i} cx={getX(i)} cy={getY(lap.time)} r="4" fill="#000" stroke={carSetups[id]?.color} strokeWidth="2" />
                                    ))}
                                </g>
                            );
                        })}
                        {Array.from({length: maxLap}).map((_, i) => (
                            <text key={i} x={getX(i)} y={height - padding + 15} textAnchor="middle" className="text-[10px] fill-gray-400 font-mono">V{i+1}</text>
                        ))}
                    </svg>
                </div>
            );
        };

        const AnalogDashboard = ({ telemetry, carSetups, raceState, activeLights, elapsedTime, targetLaps }) => {
            const isPractice = raceState === 'idle';
            const formatTime = (ms) => { if (!ms || ms === Infinity) return "00:00.000"; const m = Math.floor(ms / 60000); const s = Math.floor((ms % 60000) / 1000); const sms = Math.floor(ms % 1000); return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}.${sms.toString().padStart(3,'0')}`; };
            const sortedTelemetry = [...telemetry].sort((a, b) => a.position - b.position); const leader = sortedTelemetry[0];
            return (
                <div className="absolute top-0 left-0 w-full h-full pointer-events-none flex justify-between p-6 z-50 items-start pt-20">
                    <div className="w-80 flex flex-col gap-2 animate-in slide-in-left duration-700">
                        <div className="bg-black/80 backdrop-blur-xl border-l-4 border-red-500 rounded-r-xl p-4 shadow-[0_0_30px_rgba(239,68,68,0.2)] relative overflow-hidden">
                            <div className="flex justify-between items-center mb-2"><span className="text-2xl font-black italic text-white tracking-tighter uppercase">{carSetups[1].name}</span><span className="px-2 py-0.5 bg-red-600 text-black font-bold text-xs rounded">P1</span></div>
                            <div className="relative w-full h-32 flex justify-center items-center my-2"><svg viewBox="0 0 100 100" className="w-full h-full"><path d="M 15 85 A 50 50 0 1 1 85 85" fill="none" stroke="#333" strokeWidth="10" strokeLinecap="round"/><path d="M 15 85 A 50 50 0 1 1 85 85" fill="none" stroke="#ef4444" strokeWidth="10" strokeLinecap="round" strokeDasharray="220" strokeDashoffset={220 - (telemetry[0].speed / 450) * 220} className="transition-all duration-100 ease-linear"/></svg><div className="absolute inset-0 flex flex-col items-center justify-center pt-4"><span className="text-4xl font-digital font-black text-white drop-shadow-[0_0_10px_red]">{telemetry[0].speed}</span><span className="text-[10px] text-gray-400 font-bold">KM/H</span></div></div>
                            <div className="space-y-2 mt-2"><div><div className="flex justify-between text-[9px] font-bold text-gray-400 mb-0.5"><span>RPM</span><span>{(telemetry[0].speed / 400 * 22000).toFixed(0)}</span></div><div className="h-1.5 bg-gray-800 rounded-full overflow-hidden"><div className="h-full bg-gradient-to-r from-green-500 via-yellow-500 to-red-500" style={{width: `${(telemetry[0].speed / 450) * 100}%`}}></div></div></div><div><div className="flex justify-between text-[9px] font-bold text-gray-400 mb-0.5"><span>FUEL</span><span>78%</span></div><div className="h-1.5 bg-gray-800 rounded-full overflow-hidden"><div className="h-full bg-blue-500" style={{width: '78%'}}></div></div></div></div>
                        </div>
                        <div className="bg-black/60 backdrop-blur-md border-l-2 border-red-500/50 rounded-r-lg p-3"><div className="flex justify-between items-center text-xs font-mono text-gray-300"><span>LAST:</span> <span className="text-white">{formatTime(telemetry[0].lastLap)}</span></div><div className="flex justify-between items-center text-xs font-mono text-[#39ff14]"><span>BEST:</span> <span>{formatTime(telemetry[0].bestLap)}</span></div></div>
                    </div>
                    <div className="flex-1 flex flex-col items-center mx-4 gap-3">
                        <div className="bg-black px-5 py-3 rounded-[1.5rem] border-4 border-gray-800 flex gap-4 shadow-[0_0_60px_black] backdrop-blur-md relative z-10 scale-90">{[1, 2, 3, 4, 5].map(n => { const isRed = raceState === 'countdown' && activeLights >= n; const isGreen = raceState === 'racing'; let bg = 'bg-[#0a0a0a]'; let shadow = 'border-gray-800 opacity-60'; if (isGreen) { bg = 'bg-[#39ff14]'; shadow = 'shadow-[0_0_40px_#39ff14] border-[#39ff14] scale-110 opacity-100'; } else if (isRed) { bg = 'bg-[#ff0000]'; shadow = 'shadow-[0_0_40px_#ff0000] border-[#ff0000] scale-110 opacity-100'; } return <div key={n} className={`w-8 h-8 rounded-full border-4 ${bg} ${shadow} transition-all duration-100`}></div> })}</div>
                        <div className="bg-black/80 border-2 border-cyan-500 px-6 py-1 rounded-xl shadow-[0_0_30px_rgba(34,211,238,0.4)] backdrop-blur-md animate-in flex flex-col items-center w-[300px]"><span className="text-cyan-400 font-normal text-4xl tracking-widest drop-shadow-[0_0_10px_rgba(34,211,238,0.8)] font-timer tabular-nums text-center w-full block">{formatTime(elapsedTime)}</span></div>
                        <div className="w-full max-w-2xl bg-[#0f172a]/90 border border-gray-700 rounded-xl overflow-hidden shadow-2xl backdrop-blur-md">
                            <div className="bg-gray-900/50 px-4 py-2 flex justify-between items-center border-b border-gray-700"><span className="text-xs font-bold text-gray-400 tracking-widest uppercase flex items-center gap-2"><Activity size={12}/> SEGUIMIENTO DE CARRERA</span><span className="text-xs font-mono text-[#39ff14]">{isPractice ? 'MODO TEST INFINITO' : `VUELTA ${leader ? Math.min(targetLaps, (targetLaps - leader.laps) + 1) : 0} / ${targetLaps}`}</span></div>
                            <div className="divide-y divide-gray-800">{sortedTelemetry.map((pilot, idx) => { const config = carSetups[pilot.id]; const isLeader = idx === 0; const gap = isLeader ? (isPractice ? "TEST" : "LIDER") : `+${((pilot.laps - leader.laps) * 10 + Math.random()*2).toFixed(1)}s`; const lapsDone = isPractice ? pilot.laps : (targetLaps - pilot.laps); return (<div key={pilot.id} className="grid grid-cols-12 gap-2 px-4 py-2 items-center hover:bg-white/5 transition-colors"><div className="col-span-1 text-xl font-black italic text-gray-500">{pilot.position}</div><div className="col-span-4 flex items-center gap-2"><div className="w-1 h-6 rounded-full" style={{backgroundColor: config.color}}></div><div><div className="font-bold text-xs text-white uppercase">{config.name}</div><div className="text-[8px] text-gray-500 font-mono">{config.motorName}</div></div></div><div className="col-span-2 text-center"><div className="text-[8px] text-gray-500 uppercase">VUELTAS</div><div className="font-digital text-white text-sm">{lapsDone}</div></div><div className="col-span-2 text-center"><div className="text-[8px] text-gray-500 uppercase">GAP</div><div className={`font-mono font-bold text-xs ${isLeader ? 'text-[#39ff14]' : 'text-yellow-500'}`}>{gap}</div></div><div className="col-span-3 text-right"><div className="text-[8px] text-gray-500 uppercase">MEJOR VUELTA</div><div className="font-mono text-[#39ff14] text-xs">{formatTime(pilot.bestLap)}</div></div></div>); })}</div>
                        </div>
                    </div>
                    <div className="w-80 flex flex-col gap-2 animate-in slide-in-right duration-700">
                        <div className="bg-black/80 backdrop-blur-xl border-r-4 border-blue-500 rounded-l-xl p-4 shadow-[0_0_30px_rgba(59,130,246,0.2)] relative overflow-hidden">
                            <div className="flex flex-row-reverse justify-between items-center mb-2"><span className="text-2xl font-black italic text-white tracking-tighter uppercase">{carSetups[2].name}</span><span className="px-2 py-0.5 bg-blue-600 text-black font-bold text-xs rounded">P2</span></div>
                            <div className="relative w-full h-32 flex justify-center items-center my-2"><svg viewBox="0 0 100 100" className="w-full h-full transform scale-x-[-1]"><path d="M 15 85 A 50 50 0 1 1 85 85" fill="none" stroke="#333" strokeWidth="10" strokeLinecap="round"/><path d="M 15 85 A 50 50 0 1 1 85 85" fill="none" stroke="#3b82f6" strokeWidth="10" strokeLinecap="round" strokeDasharray="220" strokeDashoffset={220 - (telemetry[1].speed / 450) * 220} className="transition-all duration-100 ease-linear"/></svg><div className="absolute inset-0 flex flex-col items-center justify-center pt-4"><span className="text-4xl font-digital font-black text-white drop-shadow-[0_0_10px_blue]">{telemetry[1].speed}</span><span className="text-[10px] text-gray-400 font-bold">KM/H</span></div></div>
                            <div className="space-y-2 mt-2 text-right"><div><div className="flex flex-row-reverse justify-between text-[9px] font-bold text-gray-400 mb-0.5"><span>RPM</span><span>{(telemetry[1].speed / 400 * 22000).toFixed(0)}</span></div><div className="h-1.5 bg-gray-800 rounded-full overflow-hidden transform scale-x-[-1]"><div className="h-full bg-gradient-to-r from-green-500 via-yellow-500 to-blue-500" style={{width: `${(telemetry[1].speed / 450) * 100}%`}}></div></div></div><div><div className="flex flex-row-reverse justify-between text-[9px] font-bold text-gray-400 mb-0.5"><span>FUEL</span><span>82%</span></div><div className="h-1.5 bg-gray-800 rounded-full overflow-hidden transform scale-x-[-1]"><div className="h-full bg-blue-500" style={{width: '82%'}}></div></div></div></div>
                        </div>
                        <div className="bg-black/60 backdrop-blur-md border-r-2 border-blue-500/50 rounded-l-lg p-3 text-right"><div className="flex flex-row-reverse justify-between items-center text-xs font-mono text-gray-300"><span>LAST:</span> <span className="text-white">{formatTime(telemetry[1].lastLap)}</span></div><div className="flex flex-row-reverse justify-between items-center text-xs font-mono text-[#39ff14]"><span>BEST:</span> <span>{formatTime(telemetry[1].bestLap)}</span></div></div>
                    </div>
                </div>
            );
        };

        const MotorShowcase = ({ selectedCarId, currentConfig, onUpdate }) => {
            if (!currentConfig) return null;
            const motors = {
                "SLOT.IT (V12/BOXER)": [{ label: "V12/4", rpm: "23.000", torque: "170", type: "Short Can", color: "#fca5a5", name: "V12/4 23k" },{ label: "BOXER 2", rpm: "21.500", torque: "340", type: "Long Can", color: "#fdba74", name: "Boxer 21.5k" },{ label: "FLAT-6", rpm: "20.500", torque: "200", type: "Flat", color: "#fde047", name: "Flat-6 20.5k" }],
                "NSR (KING/SHARK)": [{ label: "KING 21", rpm: "21.400", torque: "350", type: "Long Can", color: "#bef264", name: "King 21 Evo" },{ label: "SHARK 25", rpm: "25.000", torque: "176", type: "Short Can", color: "#67e8f9", name: "Shark 25k" },{ label: "BABY K", rpm: "17.000", torque: "245", type: "Long Can", color: "#d8b4fe", name: "Baby King" }],
                "SCALEAUTO (TECH)": [{ label: "SC-11", rpm: "20.000", torque: "260", type: "Long Can", color: "#fca5a5", name: "SC-11b" },{ label: "SC-25", rpm: "21.000", torque: "320", type: "Long Can", color: "#cbd5e1", name: "Sprinter" }],
                "NINCO (NC)": [{ label: "NC-5", rpm: "20.000", torque: "290", type: "Long Can", color: "#f87171", name: "Speeder" },{ label: "NC-6", rpm: "23.500", torque: "350", type: "Long Can", color: "#fbbf24", name: "Crusher" }],
                "SCALEXTRIC (RX/RK)": [{ label: "RX-41", rpm: "18.000", torque: "210", type: "Short Can", color: "#94a3b8", name: "RX-41" },{ label: "PRO SPEED", rpm: "22.000", torque: "310", type: "Long Can", color: "#fb923c", name: "Pro Speed" }]
            }; 
            return (
                <div className="w-64 h-[21rem] flex flex-col rounded-sm overflow-hidden border border-[#39ff14]/30 shadow-[0_0_20px_rgba(57,255,20,0.1)] bg-[#050a05]/90 backdrop-blur-md animate-in z-50 transition-all hover:border-[#39ff14]/80 hover:shadow-[0_0_30px_rgba(57,255,20,0.2)] group relative">
                    <div className="absolute top-0 right-0 w-3 h-3 border-t-2 border-r-2 border-[#39ff14]"></div><div className="absolute bottom-0 left-0 w-3 h-3 border-b-2 border-l-2 border-[#39ff14]"></div><div className="p-2 border-b border-[#39ff14]/20 bg-[#39ff14]/5 flex justify-between items-center shrink-0 relative z-10"><div className="flex items-center gap-2"> <Zap className="text-[#39ff14]" size={14} /> <h2 className="text-[10px] font-black text-white tracking-[0.2em] uppercase">MOTOR & POWER</h2> </div><div className="flex items-center gap-1"><div className="w-1 h-1 rounded-full bg-[#39ff14] animate-pulse"></div><span className="text-[8px] text-[#39ff14]/70 font-mono">C{selectedCarId}</span></div></div><div className="flex-1 overflow-y-auto p-2 space-y-3 workshop-scroll relative z-10">{Object.entries(motors).map(([brand, list]) => (<div key={brand}><div className="flex items-center gap-2 mb-1.5 pl-1"><div className="h-px w-2 bg-[#39ff14]/50"></div><h3 className="text-[9px] font-bold text-[#39ff14] uppercase tracking-wider">{brand}</h3><div className="h-px flex-1 bg-gradient-to-r from-[#39ff14]/30 to-transparent"></div></div><div className="space-y-1">{list.map((motor, idx) => { const isSelected = currentConfig.motorName === motor.label; return (<div key={idx} onClick={() => onUpdate('motor', motor)} className={`rounded-sm p-1.5 flex gap-2 transition-all group/item items-center cursor-pointer border ${isSelected ? 'bg-[#39ff14]/20 border-[#39ff14] shadow-[0_0_10px_#39ff14]' : 'bg-black/40 border-[#39ff14]/10 hover:bg-[#39ff14]/10 hover:border-[#39ff14]/40'}`}><div className="w-10 h-6 shrink-0"><MotorSVG type={motor.type} color={motor.color} label={motor.label} /></div><div className="flex-1 min-w-0 pl-1"><div className="flex justify-between items-baseline"><h4 className={`font-bold text-[9px] truncate transition-colors ${isSelected ? 'text-white' : 'text-gray-300 group-hover/item:text-white'}`}>{motor.label}</h4></div><div className="flex justify-between text-[7px] text-gray-500 mt-0.5"><span className="text-[#39ff14]">{motor.rpm} rpm</span><span>{motor.torque} g/cm</span></div></div></div>); })}</div></div>))}</div></div>); };
        const TireShowcase = ({ selectedCarId, currentConfig, onUpdate }) => {
            if (!currentConfig) return null;
            const tires = {"SCALEAUTO (1/32)": [{ name: "Spirits", type: "Slick", compound: "Blando", grip: 95, color: "#cbd5e1", text: "#fff", label: "SPIRITS" },{ name: "AS-25", type: "Slick", compound: "Duro", grip: 40, color: "#94a3b8", text: "#94a3b8", label: "AS-25" },{ name: "Zero Grip", type: "Slick", compound: "Delantero", grip: 5, color: "#475569", text: "#475569", label: "ZERO" }],"SLOT.IT (P6/F22)": [{ name: "P6", type: "Slick", compound: "Medio", grip: 70, color: "#fdba74", text: "#f97316", label: "P6" },{ name: "F22", type: "Slick", compound: "Blando", grip: 85, color: "#86efac", text: "#22c55e", label: "F22" },{ name: "N18", type: "Slick", compound: "Duro", grip: 50, color: "#fca5a5", text: "#ef4444", label: "N18" },{ name: "G25", type: "Slick", compound: "Ex-Blando", grip: 90, color: "#fde047", text: "#eab308", label: "G25" }],"NSR (RACING)": [{ name: "Supergrip", type: "Slick", compound: "Blando", grip: 80, color: "#ef4444", text: "#ef4444", label: "SUPER" },{ name: "Ultragrip", type: "Slick", compound: "Muy Blando", grip: 92, color: "#a855f7", text: "#a855f7", label: "ULTRA" },{ name: "Extreme", type: "Slick", compound: "Extremo", grip: 98, color: "#dc2626", text: "#dc2626", label: "XTREM" },{ name: "Rain", type: "Lluvia", compound: "Mojado", grip: 88, color: "#3b82f6", text: "#3b82f6", label: "RAIN" }],"MITOOS": [{ name: "S1", type: "Slick", compound: "Blando", grip: 85, color: "#f472b6", text: "#ec4899", label: "S1" },{ name: "S2", type: "Slick", compound: "Medio", grip: 70, color: "#c084fc", text: "#9333ea", label: "S2" }]}; return (<div className="w-64 h-[21rem] flex flex-col rounded-sm overflow-hidden border border-[#39ff14]/30 shadow-[0_0_20px_rgba(57,255,20,0.1)] bg-[#050a05]/90 backdrop-blur-md animate-in z-50 transition-all hover:border-[#39ff14]/80 hover:shadow-[0_0_30px_rgba(57,255,20,0.2)] group relative"><div className="absolute top-0 left-0 w-2 h-2 border-t-2 border-l-2 border-[#39ff14]"></div><div className="absolute top-0 right-0 w-2 h-2 border-t-2 border-r-2 border-[#39ff14]"></div><div className="absolute bottom-0 left-0 w-2 h-2 border-b-2 border-l-2 border-[#39ff14]"></div><div className="absolute bottom-0 right-0 w-2 h-2 border-b-2 border-r-2 border-[#39ff14]"></div><div className="absolute inset-0 opacity-5 pointer-events-none" style={{backgroundImage: 'linear-gradient(#39ff14 1px, transparent 1px), linear-gradient(90deg, #39ff14 1px, transparent 1px)', backgroundSize: '20px 20px'}}></div><div className="p-2 border-b border-[#39ff14]/20 bg-[#39ff14]/5 flex justify-between items-center shrink-0 relative z-10"><div className="flex items-center gap-2"> <RotateCw className="text-[#39ff14]" size={14} /> <h2 className="text-[10px] font-black text-white tracking-[0.2em] uppercase drop-shadow-[0_0_5px_rgba(57,255,20,0.8)]">COMPUESTOS Y GOMAS</h2> </div><div className="flex items-center gap-1"><div className="w-1.5 h-1.5 rounded-full bg-[#39ff14] animate-pulse"></div><span className="text-[8px] text-[#39ff14]/70 font-mono">C{selectedCarId}</span></div></div><div className="flex-1 overflow-y-auto p-2 space-y-3 workshop-scroll relative z-10">{Object.entries(tires).map(([brand, list]) => (<div key={brand}><div className="flex items-center gap-2 mb-1.5 pl-1"><div className="h-px w-2 bg-[#39ff14]/50"></div><h3 className="text-[9px] font-bold text-[#39ff14] uppercase tracking-wider">{brand}</h3><div className="h-px flex-1 bg-gradient-to-r from-[#39ff14]/30 to-transparent"></div></div><div className="space-y-1">{list.map((tire, idx) => { const isSelected = currentConfig.tireName === tire.label; return (<div key={idx} onClick={() => onUpdate('tire', tire)} className={`rounded-sm p-1.5 flex gap-2 transition-all group/item items-center cursor-pointer border ${isSelected ? 'bg-[#39ff14]/20 border-[#39ff14] shadow-[0_0_10px_#39ff14]' : 'bg-black/40 border-[#39ff14]/10 hover:bg-[#39ff14]/10 hover:border-[#39ff14]/40'}`}><div className="w-8 h-8 shrink-0 flex items-center justify-center opacity-90 group-hover/item:opacity-100 transition-opacity"><TireSVG type={tire.type} rimColor={tire.color} label={tire.label} compoundColor={tire.text} /></div><div className="flex-1 min-w-0 pl-1"><div className="flex justify-between items-baseline"><h4 className={`font-bold text-[9px] truncate transition-colors ${isSelected ? 'text-white' : 'text-gray-300 group-hover/item:text-white'}`}>{tire.name}</h4><span className="text-[7px] text-[#39ff14]/60 font-mono">{tire.type === 'Rain' ? 'Lluvia' : tire.type}</span></div><div className="flex flex-col gap-0.5 mt-0.5"><div className="flex justify-between text-[7px] text-gray-500"><span>{tire.compound}</span><span className="text-[#39ff14]">{tire.grip}% Grip</span></div><div className="h-1 w-full bg-gray-800 rounded-full overflow-hidden"><div className="h-full bg-gradient-to-r from-gray-600 to-[#39ff14]" style={{width: `${tire.grip}%`}}></div></div></div></div></div>); })}</div></div>))}</div></div>); };
        const GearShowcase = ({ selectedCarId, currentConfig, onUpdate }) => {
            if (!currentConfig) return null;
            const gears = {"SLOT.IT (EN LÍNEA)": [{ teeth: "24z", color: "#22c55e", type: "Aluminio", label: "GRN" },{ teeth: "25z", color: "#78350f", type: "Bronce", label: "BRN" },{ teeth: "26z", color: "#3b82f6", type: "Bronce", label: "BLU" },{ teeth: "27z", color: "#eab308", type: "Aluminio", label: "YEL" },{ teeth: "28z", color: "#f97316", type: "Aluminio", label: "ORG" }],"NSR (ANGLEWINDER)": [{ teeth: "29z", color: "#ec4899", type: "Aluminio", label: "PNK" },{ teeth: "30z", color: "#ef4444", type: "Aluminio", label: "RED" },{ teeth: "31z", color: "#111111", type: "Aluminio", label: "BLK" },{ teeth: "32z", color: "#a855f7", type: "Aluminio", label: "PUR" }],"SLOTING PLUS (DURAL)": [{ teeth: "28z", color: "#dc2626", type: "Dural", label: "RED" },{ teeth: "30z", color: "#9333ea", type: "Dural", label: "PUR" },{ teeth: "32z", color: "#2563eb", type: "Dural", label: "BLU" },{ teeth: "34z", color: "#eab308", type: "Dural", label: "GLD" }]}; return (<div className="w-64 h-40 flex flex-col rounded-sm overflow-hidden border border-[#39ff14]/30 shadow-[0_0_20px_rgba(57,255,20,0.1)] bg-[#050a05]/90 backdrop-blur-md animate-in z-50 transition-all hover:border-[#39ff14]/80 hover:shadow-[0_0_30px_rgba(57,255,20,0.2)] group relative"><div className="absolute top-0 right-0 w-3 h-3 border-t-2 border-r-2 border-[#39ff14]"></div><div className="absolute bottom-0 left-0 w-3 h-3 border-b-2 border-l-2 border-[#39ff14]"></div><div className="p-2 border-b border-[#39ff14]/20 bg-[#39ff14]/5 flex justify-between items-center shrink-0"><div className="flex items-center gap-2"> <Settings className="text-[#39ff14]" size={14} /> <h2 className="text-[10px] font-black text-white tracking-[0.2em] uppercase">RELACIÓN TRANSMISIÓN</h2> </div> <span className="text-[8px] text-[#39ff14]/70 font-mono">CORONAS</span></div><div className="flex-1 overflow-y-auto p-2 space-y-3 workshop-scroll relative z-10">{Object.entries(gears).map(([brand, list]) => (<div key={brand}><div className="flex items-center gap-2 mb-1.5 pl-1"><div className="w-1 h-1 bg-[#39ff14] rounded-full"></div><h3 className="text-[9px] font-bold text-[#39ff14]/80 uppercase tracking-wide">{brand}</h3></div><div className="grid grid-cols-4 gap-2">{list.map((gear, idx) => { const isSelected = currentConfig.gearTeeth === parseInt(gear.teeth); return (<div key={idx} onClick={() => onUpdate('gear', gear)} className={`flex flex-col items-center gap-1 group/gear cursor-pointer p-1 rounded transition-all border ${isSelected ? 'bg-[#39ff14]/20 border-[#39ff14] shadow-[0_0_10px_#39ff14]' : 'border-transparent hover:bg-[#39ff14]/10'}`} title={`${gear.teeth} - ${gear.type}`}><div className="w-10 h-10 transition-transform duration-300 group-hover/gear:scale-110"><GearSVG teeth={gear.teeth} color={gear.color} material={gear.type} /></div><div className={`text-[8px] font-mono transition-colors ${isSelected ? 'text-[#39ff14]' : 'text-gray-400 group-hover/gear:text-white'}`}>{gear.teeth}</div></div>); })}</div></div>))}</div></div>); };
        const PinionShowcase = ({ selectedCarId, currentConfig, onUpdate }) => {
            if (!currentConfig) return null;
            const pinions = {"SLOT.IT (5.5mm / 6.5mm)": [{ teeth: "9z", type: "Latón", diameter: "5.5" },{ teeth: "10z", type: "Latón", diameter: "5.5" },{ teeth: "11z", type: "Bronce", diameter: "6.5" },{ teeth: "12z", type: "Bronce", diameter: "6.5" }],"NSR (RACING)": [{ teeth: "10z", type: "Acero", diameter: "5.5" },{ teeth: "11z", type: "Acero", diameter: "6.5" },{ teeth: "12z", type: "Acero", diameter: "7.5" },{ teeth: "13z", type: "Acero", diameter: "7.5" }],"SLOTING PLUS (MODULAR)": [{ teeth: "10z", type: "Nylon", diameter: "6.5" },{ teeth: "11z", type: "Nylon", diameter: "6.5" },{ teeth: "12z", type: "Acero", diameter: "6.5" },{ teeth: "13z", type: "Latón", diameter: "6.5" }],"SCALEAUTO (ACERO)": [{ teeth: "8z", type: "Acero", diameter: "5.0" },{ teeth: "9z", type: "Acero", diameter: "5.5" },{ teeth: "10z", type: "Acero", diameter: "6.0" }]}; return (<div className="w-64 h-40 flex flex-col rounded-sm overflow-hidden border border-[#39ff14]/30 shadow-[0_0_20px_rgba(57,255,20,0.1)] bg-[#050a05]/90 backdrop-blur-md animate-in z-50 transition-all hover:border-[#39ff14]/80 hover:shadow-[0_0_30px_rgba(57,255,20,0.2)] group relative"><div className="absolute top-0 right-0 w-3 h-3 border-t-2 border-r-2 border-[#39ff14]"></div><div className="absolute bottom-0 left-0 w-3 h-3 border-b-2 border-l-2 border-[#39ff14]"></div><div className="p-2 border-b border-[#39ff14]/20 bg-[#39ff14]/5 flex justify-between items-center shrink-0"><div className="flex items-center gap-2"> <Settings className="text-[#39ff14]" size={14} /> <h2 className="text-[10px] font-black text-white tracking-[0.2em] uppercase">PIÑONES MOTOR</h2> </div> <span className="text-[8px] text-[#39ff14]/70 font-mono">EJE MOTOR</span></div><div className="flex-1 overflow-y-auto p-2 space-y-3 workshop-scroll relative z-10">{Object.entries(pinions).map(([brand, list]) => (<div key={brand}><div className="flex items-center gap-2 mb-1.5 pl-1"><div className="w-1 h-1 bg-[#39ff14] rounded-full"></div><h3 className="text-[9px] font-bold text-[#39ff14]/80 uppercase tracking-wide">{brand}</h3></div><div className="grid grid-cols-4 gap-2">{list.map((pinion, idx) => { const isSelected = currentConfig.pinionTeeth === parseInt(pinion.teeth); return (<div key={idx} onClick={() => onUpdate('pinion', pinion)} className={`flex flex-col items-center gap-1 group/pinion cursor-pointer p-1 rounded transition-all border ${isSelected ? 'bg-[#39ff14]/20 border-[#39ff14] shadow-[0_0_10px_#39ff14]' : 'border-transparent hover:bg-[#39ff14]/10'}`} title={`${pinion.teeth} - ${pinion.type}`}><div className="w-10 h-10 transition-transform duration-300 group-hover/pinion:scale-110"><PinionSVG teeth={pinion.teeth} material={pinion.type} diameter={pinion.diameter} /></div><div className={`text-[8px] font-mono transition-colors ${isSelected ? 'text-[#39ff14]' : 'text-gray-400 group-hover/pinion:text-white'}`}>{pinion.teeth}</div></div>); })}</div></div>))}</div></div>); };
        const VoltageShowcase = ({ voltage, setVoltage }) => {const [amps, setAmps] = useState(1.2); const [history, setHistory] = useState(new Array(24).fill(0.2)); useEffect(() => { const interval = setInterval(() => { const baseAmps = (voltage / 12) * 1.5; const noise = (Math.random() - 0.5) * 0.15; const newAmps = Math.max(0, baseAmps + noise); setAmps(newAmps); setHistory(prev => { const barHeight = Math.min(1, Math.max(0.1, newAmps / 3)); return [...prev.slice(1), barHeight]; }); }, 100); return () => clearInterval(interval); }, [voltage]); return (<div className="w-64 h-40 flex flex-col rounded-sm overflow-hidden border border-[#39ff14]/30 shadow-[0_0_20px_rgba(57,255,20,0.1)] bg-[#050a05]/90 backdrop-blur-md animate-in z-50 transition-all hover:border-[#39ff14]/80 hover:shadow-[0_0_30px_rgba(57,255,20,0.2)] relative group"><svg className="absolute top-0 left-0 w-6 h-6 pointer-events-none opacity-50" viewBox="0 0 32 32"><path d="M1 1 L10 1 L10 2 L2 2 L2 10 L1 10 Z" fill="#39ff14"/></svg><svg className="absolute top-0 right-0 w-6 h-6 pointer-events-none opacity-50" viewBox="0 0 32 32"><path d="M31 1 L22 1 L22 2 L30 2 L30 10 L31 10 Z" fill="#39ff14"/></svg><svg className="absolute bottom-0 left-0 w-6 h-6 pointer-events-none opacity-50" viewBox="0 0 32 32"><path d="M1 31 L10 31 L10 30 L2 30 L2 22 L1 22 Z" fill="#39ff14"/></svg><svg className="absolute bottom-0 right-0 w-6 h-6 pointer-events-none opacity-50" viewBox="0 0 32 32"><path d="M31 31 L22 31 L22 30 L30 30 L30 22 L31 22 Z" fill="#39ff14"/></svg><div className="p-2 border-b border-[#39ff14]/20 bg-[#39ff14]/5 flex justify-between items-center shrink-0 relative z-10"><div className="flex items-center gap-2"> <Battery className="text-[#39ff14]" size={14} /> <h2 className="text-[10px] font-black text-white tracking-[0.2em] uppercase">FUENTE DS-3</h2> </div><div className="flex items-center gap-1"><div className="w-1.5 h-1.5 bg-red-500 rounded-full animate-pulse"></div><span className="text-[8px] text-[#39ff14]/70 font-mono">ON AIR</span></div></div><div className="flex flex-col p-2 gap-2 h-full relative z-10"><div className="grid grid-cols-2 gap-2 h-16"><div className="bg-black border border-[#39ff14]/30 rounded relative flex flex-col items-center justify-center shadow-[inset_0_0_15px_rgba(0,0,0,1)]"><span className="absolute top-0.5 left-1 text-[6px] text-[#39ff14]/60 font-bold tracking-wider">VOLTAJE</span><div className="flex items-baseline gap-0.5 mt-1"><span className="font-digital text-2xl font-black text-white drop-shadow-[0_0_5px_white] tracking-widest">{voltage.toFixed(1)}</span><span className="text-[10px] font-bold text-[#39ff14]">V</span></div></div><div className="bg-black border border-[#39ff14]/30 rounded relative flex flex-col items-center justify-center shadow-[inset_0_0_15px_rgba(0,0,0,1)]"><span className="absolute top-0.5 left-1 text-[6px] text-[#39ff14]/60 font-bold tracking-wider">CORRIENTE</span><div className="flex items-baseline gap-0.5 mt-1"><span className="font-digital text-2xl font-black text-[#39ff14] drop-shadow-[0_0_8px_#39ff14] tracking-widest">{amps.toFixed(2)}</span><span className="text-[10px] font-bold text-[#39ff14]">A</span></div><div className="absolute top-1 right-1 w-1 h-1 bg-red-500 rounded-full animate-pulse shadow-[0_0_5px_red]"></div></div></div><div className="flex-1 bg-black/50 border border-[#39ff14]/20 rounded flex items-end px-0.5 gap-[1px] relative overflow-hidden"><div className="absolute inset-0 opacity-20" style={{backgroundImage: 'linear-gradient(transparent 3px, #39ff14 3px)', backgroundSize: '100% 4px'}}></div>{history.map((h, i) => (<div key={i} className="flex-1 bg-[#39ff14]/60 shadow-[0_0_5px_#39ff14]" style={{height: `${h * 100}%`, transition: 'height 0.1s ease'}}></div>))}<span className="absolute top-0.5 right-1 text-[6px] text-[#39ff14]/50 font-mono">LOAD MONITOR</span></div><div className="flex items-center gap-2"><button onClick={() => setVoltage(Math.max(10, voltage - 0.5))} className="w-8 h-6 rounded bg-gray-900 border border-gray-700 hover:border-[#39ff14] hover:bg-[#39ff14]/20 text-gray-400 hover:text-[#39ff14] flex items-center justify-center transition-all active:scale-95"><Minus size={12}/></button><div className="flex-1 h-1.5 bg-gray-900 rounded-full overflow-hidden border border-gray-700 relative group-hover:border-[#39ff14]/30 transition-colors"><div className="h-full bg-gradient-to-r from-[#39ff14]/40 to-[#39ff14] shadow-[0_0_10px_#39ff14] relative transition-all duration-300" style={{width: `${((voltage - 10) / 10) * 100}%`}}></div></div><button onClick={() => setVoltage(Math.min(20, voltage + 0.5))} className="w-8 h-6 rounded bg-gray-900 border border-gray-700 hover:border-[#39ff14] hover:bg-[#39ff14]/20 text-gray-400 hover:text-[#39ff14] flex items-center justify-center transition-all active:scale-95"><Plus size={12}/></button></div></div></div>); };
        const WeightShowcase = ({ selectedCarId, currentConfig, onUpdate }) => {
            if (!currentConfig) return null;
            const weightItems = [{ id: 'body', label: "CARROCERÍA", val: 24.5 },{ id: 'chassis', label: "CHASIS 3D", val: 16.2 },{ id: 'trans', label: "EJES/TRANS", val: 12.8 },{ id: 'wheels', label: "LLANTAS", val: 8.4 },{ id: 'cockpit', label: "COCKPIT", val: 2.1 }]; const baseWeight = weightItems.reduce((acc, item) => acc + item.val, 0); const currentWeight = currentConfig.weight || baseWeight; return (<div className="w-64 h-40 flex flex-col rounded-sm overflow-hidden border border-[#39ff14]/30 shadow-[0_0_20px_rgba(57,255,20,0.1)] bg-[#050a05]/90 backdrop-blur-md animate-in z-50 transition-all hover:border-[#39ff14]/80 hover:shadow-[0_0_30px_rgba(57,255,20,0.2)] relative group cursor-pointer" onClick={() => onUpdate('weight', currentWeight > 80 ? 60 : 85)} title="Click para Aligerar/Lastrar Chasis"><div className="absolute inset-0 opacity-10 pointer-events-none" style={{backgroundImage: 'radial-gradient(#39ff14 1px, transparent 1px)', backgroundSize: '10px 10px'}}></div><div className="p-2 border-b border-[#39ff14]/20 bg-[#39ff14]/5 flex justify-between items-center shrink-0 relative z-10"><div className="flex items-center gap-2"> <Scale className="text-[#39ff14]" size={14} /> <h2 className="text-[10px] font-black text-white tracking-[0.2em] uppercase">BÁSCULA DIGITAL</h2> </div><div className="flex items-center gap-1"><div className="w-1 h-1 rounded-full bg-[#39ff14] animate-pulse"></div><span className="text-[8px] text-[#39ff14]/70 font-mono">C{selectedCarId}</span></div></div><div className="flex flex-row flex-1 p-2 gap-2 relative z-10 overflow-hidden"><div className="flex-1 flex flex-col justify-between pr-2 border-r border-[#39ff14]/10">{weightItems.map((w, i) => (<div key={i} className="flex items-center justify-between group/row"><span className="text-[8px] text-gray-400 font-bold uppercase tracking-tighter group-hover/row:text-white transition-colors">{w.label}</span><span className="text-[9px] font-mono text-[#39ff14]">{w.val}</span></div>))}</div><div className="w-24 flex flex-col justify-between items-end"><div className="text-right mt-1"><span className="text-[7px] text-[#39ff14]/60 font-bold tracking-widest uppercase block mb-0.5">PESO TOTAL</span><div className="relative inline-block bg-black/40 px-2 py-1 rounded border border-[#39ff14]/20 shadow-[inset_0_0_10px_rgba(0,0,0,1)]"><span className="font-digital text-3xl font-black text-white drop-shadow-[0_0_10px_rgba(57,255,20,0.8)] leading-none block">{currentWeight.toFixed(1)}</span><span className="absolute -bottom-2 -right-1 text-[10px] font-bold text-[#39ff14]">g</span></div></div><div className="w-full flex items-end gap-[2px] h-10 mt-2 opacity-80">{weightItems.map((w, i) => (<div key={i} className="flex-1 bg-[#39ff14]/20 rounded-sm relative group/bar hover:bg-[#39ff14]/40 transition-colors"><div className="absolute bottom-0 w-full bg-[#39ff14] rounded-sm transition-all duration-500 shadow-[0_0_5px_#39ff14]" style={{height: `${(w.val / 30) * 100}%`}}></div></div>))}</div></div></div></div>); };
        const TelemetryPanel = ({ carId, data, config }) => { 
            if (!data || !config) return null;
            const speedPercent = Math.min(100, (data.speed / 400) * 100); const rpmPercent = Math.min(100, (data.speed / 300) * 90 + Math.random()*10); return (<div className="w-72 bg-[#050a05]/95 border-2 border-[#39ff14] rounded-xl overflow-hidden shadow-[0_0_40px_rgba(57,255,20,0.2)] backdrop-blur-xl animate-in transform transition-all hover:scale-105"><div className="bg-[#39ff14] text-black px-4 py-2 flex justify-between items-center"><div className="flex items-center gap-2"><Activity size={18} className="animate-pulse"/><h2 className="font-black text-xs tracking-[0.25em] uppercase">TELEMETRÍA EN VIVO</h2></div><span className="font-mono font-bold text-xs bg-black/20 px-2 py-0.5 rounded">COCHE {carId}</span></div><div className="p-4 grid grid-cols-2 gap-4 relative"><div className="absolute inset-0 opacity-10 pointer-events-none" style={{backgroundImage: 'linear-gradient(transparent 9px, #39ff14 1px), linear-gradient(90deg, transparent 9px, #39ff14 1px)', backgroundSize: '20px 20px'}}></div><div className="col-span-2 flex items-end justify-between border-b border-[#39ff14]/30 pb-2"><div><span className="text-[10px] text-[#39ff14]/60 font-bold uppercase block">VELOCIDAD</span><span className="font-digital text-5xl text-white drop-shadow-[0_0_10px_rgba(57,255,20,0.8)] leading-none">{data.speed}</span><span className="text-xs text-[#39ff14] font-bold ml-1">Km/h</span></div><div className="w-1/2 flex flex-col items-end"><div className="w-full h-2 bg-gray-900 rounded-full overflow-hidden border border-[#39ff14]/30"><div className="h-full bg-gradient-to-r from-[#39ff14]/40 via-[#39ff14] to-white transition-all duration-75" style={{width: `${rpmPercent}%`}}></div></div><span className="text-[8px] text-[#39ff14] font-mono mt-1">RPM: {(rpmPercent * 250).toFixed(0)}0</span></div></div><div className="space-y-2"><div className="flex justify-between items-center"><span className="text-[9px] text-gray-400 font-bold">MOTOR</span><span className="text-[9px] text-[#39ff14] font-mono border border-[#39ff14]/30 px-1 rounded">{config.motorName || 'STD'}</span></div><div className="flex justify-between items-center"><span className="text-[9px] text-gray-400 font-bold">GOMAS</span><span className="text-[9px] text-[#39ff14] font-mono border border-[#39ff14]/30 px-1 rounded">{config.tireName || 'STD'}</span></div><div className="flex justify-between items-center"><span className="text-[9px] text-gray-400 font-bold">RELACIÓN</span><span className="text-[9px] text-[#39ff14] font-mono border border-[#39ff14]/30 px-1 rounded">{config.gearRatio ? config.gearRatio.toFixed(2) : '3.00'}</span></div></div><div className="text-right space-y-1"><div><span className="text-[8px] text-gray-500 block uppercase">ÚLTIMA VUELTA</span><span className="font-digital text-lg text-white">{data.lastLap > 0 ? (data.lastLap/1000).toFixed(3) : '--.---'}</span></div><div><span className="text-[8px] text-[#39ff14]/80 block uppercase">MEJOR VUELTA</span><span className="font-digital text-lg text-[#39ff14] drop-shadow-[0_0_5px_rgba(57,255,20,0.5)]">{data.bestLap > 0 && data.bestLap !== Infinity ? (data.bestLap/1000).toFixed(3) : '--.---'}</span></div></div></div></div>); };
        
        /* --- 3. VISOR 3D (CORE LOGIC) --- */
        const Telemetry3DViewer = ({ circuitData, carSettings, customCarAssets, onClose }) => {
            const containerRef = useRef(null);
            const [paused, setPaused] = useState(false); 
            const [laneChangeActive, setLaneChangeActive] = useState(true); 
            const [raceState, setRaceState] = useState('grid'); 
            const [winnerId, setWinnerId] = useState(null); 
            const [activeLights, setActiveLights] = useState(0); 
            const [elapsedTime, setElapsedTime] = useState(0);
            const [targetLaps, setTargetLaps] = useState(10);
            const [validationError, setValidationError] = useState(null);
            const [trackVoltage, setTrackVoltage] = useState(12.0);
            const [activeButton, setActiveButton] = useState('GRID');
            const [isFullscreen, setIsFullscreen] = useState(false);
            const [manualThrottle, setManualThrottle] = useState(0);
            const [selectedCarId, setSelectedCarId] = useState(1);
            const [sessionResults, setSessionResults] = useState(null);
            const [isGeneratingPDF, setIsGeneratingPDF] = useState(false);
            
            const [laneChangePressed, setLaneChangePressed] = useState(false);
            const [pitPressed, setPitPressed] = useState(false);
            const [autoLaneChange, setAutoLaneChange] = useState(false);
            const [numCars, setNumCars] = useState(2);

            // VARIABLES DE ESTADO Y REF PARA RALLY
            const rallyPathRef = useRef([]);
            const rallyDistancesRef = useRef([]);
            const hasRotonda = circuitData.pieces.some(p => p.subtype === 'rotonda');

            const laneChangePressedRef = useRef(false);
            const pitPressedRef = useRef(false);
            const autoLaneChangeRef = useRef(false);
            const numCarsRef = useRef(2);
            const manualThrottleRef = useRef(0);
            const selectedCarIdRef = useRef(selectedCarId);
            const trackVoltageRef = useRef(trackVoltage);
            const sessionDataRef = useRef({});

            useEffect(() => { laneChangePressedRef.current = laneChangePressed; }, [laneChangePressed]);
            useEffect(() => { pitPressedRef.current = pitPressed; }, [pitPressed]);
            useEffect(() => { autoLaneChangeRef.current = autoLaneChange; }, [autoLaneChange]);
            useEffect(() => { numCarsRef.current = numCars; }, [numCars]);
            useEffect(() => { manualThrottleRef.current = manualThrottle; }, [manualThrottle]);
            useEffect(() => { selectedCarIdRef.current = selectedCarId; }, [selectedCarId]);
            useEffect(() => { trackVoltageRef.current = trackVoltage; }, [trackVoltage]);
            
            const [carSetups, setCarSetups] = useState(() => {
                const initialSetups = {};
                for(let i=1; i<=8; i++) {
                    initialSetups[i] = { 
                        motorRPM: 20000, motorTorque: 240, motorName: 'Standard 20k', 
                        tireGrip: 80, tireName: 'Slick Std', 
                        gearTeeth: 27, pinionTeeth: 9, gearRatio: 3.0, 
                        weight: 85, 
                        name: carSettings[i-1]?.name || `PILOTO ${i}`, 
                        color: carSettings[i-1]?.color || '#ffffff' 
                    };
                }
                return initialSetups;
            });

            useEffect(() => {
                setCarSetups(prev => {
                    const next = { ...prev };
                    carSettings.forEach((setting, idx) => {
                        const id = idx + 1;
                        if (next[id]) {
                            next[id] = { ...next[id], name: setting.name, color: setting.color };
                        }
                    });
                    return next;
                });
            }, [carSettings]);

            const exportToPDF = async () => {
                const element = document.getElementById('engineering-report');
                if (!element) return;
                setIsGeneratingPDF(true);
                try {
                    const canvas = await html2canvas(element, { scale: 2, backgroundColor: '#0f172a' });
                    const imgData = canvas.toDataURL('image/png');
                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF('l', 'mm', 'a4');
                    const pdfWidth = pdf.internal.pageSize.getWidth();
                    const pdfHeight = pdf.internal.pageSize.getHeight();
                    const imgWidth = canvas.width;
                    const imgHeight = canvas.height;
                    const ratio = Math.min(pdfWidth / imgWidth, pdfHeight / imgHeight);
                    const imgX = (pdfWidth - imgWidth * ratio) / 2;
                    const imgY = 10;
                    pdf.addImage(imgData, 'PNG', imgX, imgY, imgWidth * ratio, imgHeight * ratio);
                    pdf.save(`setup-report-${new Date().toISOString().slice(0,10)}.pdf`);
                } catch (e) {
                    console.error("PDF Error:", e);
                    alert("Error al generar PDF");
                } finally {
                    setIsGeneratingPDF(false);
                }
            };

            const handleUpdateConfig = (type, value) => {
                setCarSetups(prev => {
                    const newSetup = { ...prev[selectedCarId] };
                    if (type === 'motor') { newSetup.motorRPM = parseInt(value.rpm.replace('.','')); newSetup.motorTorque = parseInt(value.torque); newSetup.motorName = value.label; }
                    else if (type === 'tire') { newSetup.tireGrip = value.grip; newSetup.tireName = value.label; }
                    else if (type === 'gear') { newSetup.gearTeeth = parseInt(value.teeth); newSetup.gearRatio = newSetup.gearTeeth / newSetup.pinionTeeth; }
                    else if (type === 'pinion') { newSetup.pinionTeeth = parseInt(value.teeth); newSetup.gearRatio = newSetup.gearTeeth / newSetup.pinionTeeth; }
                    else if (type === 'weight') { newSetup.weight = value; }
                    return { ...prev, [selectedCarId]: newSetup };
                });
            };

            const carAssetsRef = useRef(customCarAssets);
            useEffect(() => { carAssetsRef.current = customCarAssets; }, [customCarAssets]);
            const targetLapsRef = useRef(10);
            useEffect(() => { targetLapsRef.current = targetLaps; }, [targetLaps]);
            useEffect(() => { if (raceState === 'grid') { physicsState.current.forEach(c => c.laps = targetLaps); } }, [targetLaps, raceState]);

            const lastResumeTime = useRef(0);
            const previouslyElapsedTime = useRef(0);
            const togglePause = () => {
                if (paused) {
                    lastResumeTime.current = Date.now();
                    setPaused(false);
                    if (timerIntervalRef.current) clearInterval(timerIntervalRef.current);
                    timerIntervalRef.current = setInterval(() => {
                        if (raceStateRef.current === 'racing' || raceStateRef.current === 'idle') {
                             setElapsedTime(previouslyElapsedTime.current + (Date.now() - lastResumeTime.current));
                        }
                    }, 33);
                } else {
                    const now = Date.now();
                    previouslyElapsedTime.current += (now - lastResumeTime.current);
                    setPaused(true);
                    if (timerIntervalRef.current) clearInterval(timerIntervalRef.current);
                    setElapsedTime(previouslyElapsedTime.current);
                }
            };

            const [telemetry, setTelemetry] = useState(Array(8).fill(null).map((_, i) => ({
                id: i + 1, speed: 0, lastLap: 0, bestLap: 0, averageLap: 0, currentLap: 0, laps: 0, position: i + 1, fuel: 100
            })));

            const audioCtxRef = useRef(null);
            const timerIntervalRef = useRef(null);
            const raceSequenceIntervalRef = useRef(null); 
            const pieceMapRef = useRef([]); 
            const lastUIUpdate = useRef(0); 
            const activeButtonRef = useRef('GRID'); 
            useEffect(() => { activeButtonRef.current = activeButton; }, [activeButton]);

            const formatRaceTime = (ms) => { if (!ms || ms === Infinity || isNaN(ms)) return "00:00.000"; const m = Math.floor(ms / 60000); const s = Math.floor((ms % 60000) / 1000); const sms = Math.floor(ms % 1000); return `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}.${sms.toString().padStart(3,'0')}`; };
            const playRaceSound = (type) => { try { const AudioContext = window.AudioContext || window.webkitAudioContext; if (!audioCtxRef.current) audioCtxRef.current = new AudioContext(); if (audioCtxRef.current.state === 'suspended') audioCtxRef.current.resume(); const ctx = audioCtxRef.current; const t = ctx.currentTime; const masterGain = ctx.createGain(); masterGain.connect(ctx.destination); masterGain.gain.value = 0.6; if (type === 'red') { const osc1 = ctx.createOscillator(); osc1.type = 'square'; osc1.frequency.setValueAtTime(750, t); const osc2 = ctx.createOscillator(); osc2.type = 'square'; osc2.frequency.setValueAtTime(765, t); const gain = ctx.createGain(); gain.gain.setValueAtTime(0.0, t); gain.gain.linearRampToValueAtTime(0.3, t + 0.02); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15); osc1.connect(gain); osc2.connect(gain); gain.connect(masterGain); osc1.start(t); osc1.stop(t + 0.15); osc2.start(t); osc2.stop(t + 0.15); } else if (type === 'green') { const notes = [110, 220, 277.18, 329.63, 440, 554.37]; notes.forEach((freq, i) => { [ -4, 4 ].forEach(detune => { const osc = ctx.createOscillator(); const gain = ctx.createGain(); osc.type = 'sawtooth'; osc.frequency.setValueAtTime(freq, t); osc.detune.value = detune; gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(0.1 / (i*0.5 + 1), t + 0.08); gain.gain.exponentialRampToValueAtTime(0.001, t + 3.5); osc.connect(gain); gain.connect(masterGain); osc.start(t); osc.stop(t + 3.5); }); }); } } catch (e) { console.error("Audio error", e); } };

            const checkRaceRequirements = () => { const hasGrid = circuitData.pieces.some(p => p.subtype === 'starting_grid'); const hasConnection = circuitData.pieces.some(p => p.subtype === 'analog_connect' || p.subtype === 'connection' || p.subtype === 'digital_console'); if (!hasGrid && !hasConnection) return "Faltan: Parrilla de Salida y Pista de Conexiones"; if (!hasGrid) return "Falta: Parrilla de Salida"; if (!hasConnection) return "Falta: Pista de Conexiones"; return null; };
            
            const LANE_1 = 0, LANE_2 = 1, LANE_PIT = 99;
            const getTrackTotalLength = () => { if (pieceMapRef.current && pieceMapRef.current.length > 0) return pieceMapRef.current[pieceMapRef.current.length - 1].distEnd; return 0; };

            const getStartingPosition = (carIndex, mode) => {
                const totalLen = getTrackTotalLength();
                if (totalLen === 0) return { pos: 0, lane: (carIndex % 2 === 0 ? LANE_1 : LANE_2) };
                const gridPiece = pieceMapRef.current.find(p => p.subtype === 'starting_grid');
                const connPiece = pieceMapRef.current.find(p => p.subtype === 'analog_connect' || p.subtype === 'connection' || p.subtype === 'digital_console');
                const finishLinePiece = connPiece || pieceMapRef.current[0];
                let targetPiece, distIntoPiece, rowSpacing;
                if (mode === 'digital') {
                    targetPiece = gridPiece || finishLinePiece;
                    if (targetPiece) {
                        const len = targetPiece.distEnd - targetPiece.distStart;
                        const isLane1 = carIndex % 2 === 0;
                        if (targetPiece.subtype === 'starting_grid') { distIntoPiece = len * (isLane1 ? 0.7 : 0.3); } else { distIntoPiece = len * 0.5; }
                        rowSpacing = Math.floor(carIndex / 2) * 40.0;
                    }
                } else {
                    targetPiece = finishLinePiece;
                    if (targetPiece) {
                        const len = targetPiece.distEnd - targetPiece.distStart;
                        distIntoPiece = len * 0.5; rowSpacing = 0; 
                    }
                }
                if (!targetPiece) return { pos: 0, lane: (carIndex % 2 === 0 ? LANE_1 : LANE_2) };
                let pos = targetPiece.distStart + distIntoPiece - rowSpacing - 3.0;
                if (totalLen > 0) { while (pos < 0) pos += totalLen; pos = pos % totalLen; }
                return { pos, lane: (carIndex % 2 === 0 ? LANE_1 : LANE_2) };
            };

            const physicsState = useRef(Array(8).fill(null).map((_, i) => { 
                const lane = i % 2 === 0 ? LANE_1 : LANE_2; 
                return { 
                    id: i + 1, color: 0xffffff, currentLane: lane, targetLane: lane, isChanging: false, changeProgress: 0, distance: -40.0 * Math.floor(i / 2), speed: 0, 
                    lastPieceIndex: -1, lapStartTime: 0, lastLapTime: 0, bestLapTime: Infinity, laps: 0, totalLapTime: 0, completedLaps: 0, 
                    isDerailled: false, derailTime: 0, velocity: new THREE.Vector3(0,0,0), worldPos: new THREE.Vector3(0,0,0), recoverTime: 0, invulnerableUntil: 0, fuel: 100,
                    wantsToPit: false, isRefueling: false, refuelStartTime: 0, hasRefueledThisLap: false, crossedStartLine: false
                }; 
            }));
            const pausedRef = useRef(false), laneActiveRef = useRef(false), raceStateRef = useRef('idle'), clock = useRef(new THREE.Clock()), carSetupsRef = useRef(carSetups);
            
            useEffect(() => { carSetupsRef.current = carSetups; }, [carSetups]); 
            useEffect(() => { pausedRef.current = paused; }, [paused]); 
            useEffect(() => { laneActiveRef.current = laneChangeActive; }, [laneChangeActive]); 
            useEffect(() => { raceStateRef.current = raceState; }, [raceState]);

            const startRaceSequence = () => { 
                if (audioCtxRef.current && audioCtxRef.current.state === 'suspended') audioCtxRef.current.resume();
                setRaceState('countdown'); setActiveLights(0); setElapsedTime(0); previouslyElapsedTime.current = 0; 
                physicsState.current.forEach(c => c.invulnerableUntil = Date.now() + 6000);
                let step = 0; 
                if (raceSequenceIntervalRef.current) clearInterval(raceSequenceIntervalRef.current); 
                if (timerIntervalRef.current) clearInterval(timerIntervalRef.current); 
                raceSequenceIntervalRef.current = setInterval(() => { 
                    step++; 
                    if (step <= 5) { setActiveLights(step); playRaceSound('red'); } else { 
                        clearInterval(raceSequenceIntervalRef.current); 
                        setTimeout(() => { 
                            setRaceState('racing'); setActiveLights(0); playRaceSound('green'); 
                            const startTime = Date.now(); lastResumeTime.current = startTime; 
                            physicsState.current.forEach(c => { c.lapStartTime = startTime; c.speed = 0; }); 
                            timerIntervalRef.current = setInterval(() => { setElapsedTime(Date.now() - startTime); }, 33); 
                        }, Math.random() * 1000 + 500); 
                    } 
                }, 1000); 
            };
            
            const enterGridMode = () => { 
                const error = checkRaceRequirements(); if (error) { setValidationError(error); setTimeout(() => setValidationError(null), 4000); return; } 
                setRaceState('grid'); setWinnerId(null); setActiveLights(0); setElapsedTime(0); previouslyElapsedTime.current = 0; setActiveButton('GRID'); setNumCars(hasRotonda ? 1 : 2); 
                setSessionResults(null); 
                sessionDataRef.current = {}; 
                if (timerIntervalRef.current) clearInterval(timerIntervalRef.current); 
                if (raceSequenceIntervalRef.current) clearInterval(raceSequenceIntervalRef.current); 
                physicsState.current.forEach((car, i) => { 
                    const startData = getStartingPosition(i, 'analog');
                    car.distance = startData.pos; 
                    car.currentLane = startData.lane; car.targetLane = startData.lane;
                    car.speed = 0; car.isChanging = false; car.laps = targetLaps; car.lapStartTime = 0; car.lastLapTime = 0; car.totalLapTime = 0; car.completedLaps = 0; car.fuel = 100; car.isDerailled = false; car.invulnerableUntil = Date.now() + 2000; car.wantsToPit = false; car.isRefueling = false; car.hasRefueledThisLap = false;
                    car.crossedStartLine = false; 
                    sessionDataRef.current[car.id] = [];
                }); 
                setPaused(false); 
            };
            
            const startPracticeMode = () => { 
                setRaceState('idle'); setWinnerId(null); setActiveLights(0); setElapsedTime(0); previouslyElapsedTime.current = 0; setActiveButton('PRACTICE'); setNumCars(hasRotonda ? 1 : 2); 
                setSessionResults(null);
                if (timerIntervalRef.current) clearInterval(timerIntervalRef.current); 
                const startTime = Date.now(); lastResumeTime.current = startTime; setManualThrottle(0); 
                physicsState.current.forEach((car, i) => { 
                    const startData = getStartingPosition(i, 'analog');
                    car.distance = startData.pos; 
                    car.currentLane = startData.lane; car.targetLane = startData.lane;
                    car.speed = 0; car.isChanging = false; car.laps = 0; car.lapStartTime = startTime; car.lastLapTime = 0; car.totalLapTime = 0; car.completedLaps = 0; car.fuel = 100; car.isDerailled = false; car.invulnerableUntil = Date.now() + 5000; car.wantsToPit = false; car.isRefueling = false; car.hasRefueledThisLap = false;
                    car.crossedStartLine = false; 
                }); 
                timerIntervalRef.current = setInterval(() => setElapsedTime(Date.now() - startTime), 33); setPaused(false); 
            };
            
            const resetPractice = () => { 
                setRaceState('idle'); setWinnerId(null); setElapsedTime(0); previouslyElapsedTime.current = 0; setActiveButton('PRACTICE'); setSessionResults(null);
                physicsState.current.forEach((car, i) => { 
                    const startData = getStartingPosition(i, 'analog');
                    car.distance = startData.pos;
                    car.currentLane = startData.lane; car.targetLane = startData.lane;
                    car.laps = 0; car.lapStartTime = 0; car.lastLapTime = 0; car.bestLapTime = Infinity; car.totalLapTime = 0; car.completedLaps = 0; car.speed = 0; 
                    car.crossedStartLine = false; 
                }); 
                setPaused(true); 
            };
            
            const handleAnalogMode = () => {
                setLaneChangeActive(false); setActiveButton('ANALOG'); setRaceState('grid'); setManualThrottle(0); setNumCars(hasRotonda ? 1 : 2); setSessionResults(null);
                sessionDataRef.current = {}; 
                if (timerIntervalRef.current) clearInterval(timerIntervalRef.current); setElapsedTime(0); previouslyElapsedTime.current = 0;
                physicsState.current.forEach((car, i) => {
                    const startData = getStartingPosition(i, 'analog');
                    car.distance = startData.pos; 
                    car.currentLane = startData.lane; car.targetLane = startData.lane;
                    car.speed = 0; car.isChanging = false; car.changeProgress = 0; car.laps = targetLaps; car.lapStartTime = 0; car.lastLapTime = 0; car.fuel = 100; car.isDerailled = false; car.invulnerableUntil = Date.now() + 2000; car.wantsToPit = false; car.isRefueling = false;
                    car.crossedStartLine = false; 
                    sessionDataRef.current[car.id] = []; 
                });
                setPaused(false);
            };

            const handleDigitalMode = () => { 
                const digitalSubtypes = ['digital_x', 'change_right', 'change_left', 'change_curve_r', 'pit_entry', 'digital_console', 'connection'], hasDigitalPieces = circuitData.pieces.some(p => digitalSubtypes.includes(p.subtype)); 
                if (!hasDigitalPieces) { setValidationError("⚠️ ERROR: No hay pistas digitales en el circuito."); setTimeout(() => setValidationError(null), 3000); return; } 
                setLaneChangeActive(true); setActiveButton('DIGITAL'); setNumCars(4); setSessionResults(null);
                physicsState.current.forEach((car, i) => {
                    const startData = getStartingPosition(i, 'digital');
                    car.distance = startData.pos; 
                    car.currentLane = startData.lane; car.targetLane = startData.lane;
                    car.speed = 0; car.isDerailled = false; car.invulnerableUntil = Date.now() + 3000; car.wantsToPit = false; car.isRefueling = false;
                    car.crossedStartLine = false; 
                });
            };
            const toggleFullscreen = () => { if (!document.fullscreenElement) { document.documentElement.requestFullscreen(); setIsFullscreen(true); } else { document.exitFullscreen(); setIsFullscreen(false); } };

            useEffect(() => { return () => { if (timerIntervalRef.current) clearInterval(timerIntervalRef.current); if (raceSequenceIntervalRef.current) clearInterval(raceSequenceIntervalRef.current); }; }, []);

            useEffect(() => {
                if (!circuitData || !containerRef.current || typeof THREE === 'undefined') return;
                let renderer, scene, camera, animationId; let isDragging = false, previousTouch = { x: 0, y: 0 }; 
                let spherical = new THREE.Spherical(250, Math.PI/3, Math.PI/4);
                let carMeshes = []; pieceMapRef.current = []; let cameraTarget = new THREE.Vector3(0, 0, 0);
                const brandData = TRACK_DEFINITIONS[circuitData.brand] || TRACK_DEFINITIONS.NINCO, laneSpacing = brandData.laneSpacing || 9.0, trackWidth = brandData.width || 18.0;
                
                const onResize = () => { if (camera && renderer) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); } };
                
                const onMouseDown = (e) => { isDragging=true; previousTouch={x:e.clientX, y:e.clientY}; };
                const onMouseMove = (e) => { 
                    if(!isDragging) return; 
                    spherical.theta -= (e.clientX-previousTouch.x)*0.005; 
                    spherical.phi -= (e.clientY-previousTouch.y)*0.005; 
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                    spherical.makeSafe();
                    previousTouch={x:e.clientX, y:e.clientY}; 
                };
                const onMouseUp = () => isDragging=false;
                const onWheel = (e) => { e.preventDefault(); spherical.radius = Math.max(50, Math.min(1500, spherical.radius + e.deltaY * 0.5)); };
                
                let previousPinchDist = 0;
                const onTouchStart = (e) => {
                    if (e.touches.length === 1) { isDragging = true; previousTouch = { x: e.touches[0].clientX, y: e.touches[0].clientY }; } else if (e.touches.length === 2) { isDragging = false; const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; previousPinchDist = Math.hypot(dx, dy); }
                };
                const onTouchMove = (e) => {
                    if (e.touches.length === 1 && isDragging) { e.preventDefault(); const touch = e.touches[0]; spherical.theta -= (touch.clientX - previousTouch.x) * 0.005; spherical.phi -= (touch.clientY - previousTouch.y) * 0.005; spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi)); spherical.makeSafe(); previousTouch = { x: touch.clientX, y: touch.clientY }; } else if (e.touches.length === 2) { e.preventDefault(); const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; const dist = Math.hypot(dx, dy); const delta = previousPinchDist - dist; spherical.radius = Math.max(50, Math.min(1500, spherical.radius + delta * 2)); previousPinchDist = dist; }
                };
                const onTouchEnd = () => { isDragging = false; };

                const createCar = (id, color) => { const pg = new THREE.Group(), vg = new THREE.Group(); pg.add(vg); const bm = new THREE.MeshStandardMaterial({ color, roughness: 0.2, metalness: 0.6 }), bg = new THREE.BoxGeometry(4.5, 1.2, 9), b = new THREE.Mesh(bg, bm); b.position.y = 0.8; b.castShadow = true; vg.add(b); const cg = new THREE.BoxGeometry(3.5, 0.8, 4), cm = new THREE.MeshStandardMaterial({ color: 0x111111 }), c = new THREE.Mesh(cg, cm); c.position.y = 1.8; vg.add(c); const wg = new THREE.CylinderGeometry(1.2, 1.2, 0.8, 16); wg.rotateZ(Math.PI/2); const wm = new THREE.MeshStandardMaterial({ color: 0x222222 }); [[-2.5, 3], [2.5, 3], [-2.5, -3], [2.5, -3]].forEach(p => { const w = new THREE.Mesh(wg, wm); w.position.set(p[0], 1.2, p[1]); vg.add(w); }); return pg; };
                const createAsphaltTexture = (r, bc) => { const cv = document.createElement('canvas'); cv.width = 512; cv.height = 512; const cx = cv.getContext('2d'); cx.fillStyle = bc || '#080808'; cx.fillRect(0, 0, 512, 512); for (let i = 0; i < 150000; i++) { const v = 15 + Math.floor(Math.random() * 30); cx.fillStyle = `rgba(${v}, ${v}, ${v}, 0.2)`; cx.fillRect(Math.random() * 512, Math.random() * 512, 1.5, 1.5); } const t = new THREE.CanvasTexture(cv); t.wrapS = THREE.RepeatWrapping; t.wrapT = THREE.RepeatWrapping; return t; };

                const init3D = () => {
                    const rails = { lane1: [], lane2: [], pit: [], changes: [] }, vertexDistances = [0]; let accumulatedDist = 0;
                    scene = new THREE.Scene(); scene.background = new THREE.Color(0x3b5f7d); scene.fog = new THREE.Fog(0x3b5f7d, 500, 3000); 
                    
                    const gridHelper = new THREE.GridHelper(10000, 200, 0x39ff14, 0x39ff14);
                    gridHelper.position.y = -0.5; 
                    gridHelper.material.transparent = true;
                    gridHelper.material.opacity = 0.1; 
                    scene.add(gridHelper);

                    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 5000); renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.shadowMap.enabled = true;
                    while(containerRef.current.firstChild) containerRef.current.removeChild(containerRef.current.firstChild); containerRef.current.appendChild(renderer.domElement);
                    scene.add(new THREE.AmbientLight(0xffffff, 0.8)); const dl = new THREE.DirectionalLight(0xffffff, 1.2); dl.position.set(100, 300, 50); dl.castShadow = true; scene.add(dl);
                    const asphaltTexture = createAsphaltTexture(renderer, brandData.trackColor), trackGroup = new THREE.Group(), stdHalf = trackWidth / 2, pitCenterDist = (laneSpacing / 2) + laneSpacing, pitOuterEdge = pitCenterDist + (trackWidth / 2 + 1) / 2; 
                    const asphaltVerts = [], asphaltIndices = [], asphaltUVs = []; let aspVertCount = 0; 
                    const addAsphaltSlice = (cx, cz, ang, lW, rW, dist) => { const px = Math.cos(ang + Math.PI/2), pz = Math.sin(ang + Math.PI/2); asphaltVerts.push(cx - px * lW, 0, cz - pz * lW, cx + px * rW, 0, cz + pz * rW); const v = dist * 0.2; asphaltUVs.push(0, v, 1, v); if (aspVertCount > 0) { const b = (aspVertCount-1)*2; asphaltIndices.push(b, b+2, b+1, b+1, b+2, b+3); } aspVertCount++; };
                    let curX = 0, curZ = 0, curAngle = 0, l1Off = -laneSpacing/2, l2Off = laneSpacing/2;
                    const addRailPoint = (x, z, ang, lo1, lo2, po, di) => { const px = Math.cos(ang + Math.PI/2), pz = Math.sin(ang + Math.PI/2); 
                        if (lo1 !== null) rails.lane1.push(new THREE.Vector3(x + px * lo1, 0.2, z + pz * lo1)); else rails.lane1.push(null);
                        if (lo2 !== null) rails.lane2.push(new THREE.Vector3(x + px * lo2, 0.2, z + pz * lo2)); else rails.lane2.push(null);
                        if (po !== null) rails.pit.push(new THREE.Vector3(x + px * po, 0.2, z + pz * po)); else rails.pit.push(null); if (di > 0) { accumulatedDist += di; vertexDistances.push(accumulatedDist); } 
                    };
                    addRailPoint(0,0,0, l1Off, l2Off, null, 0); addAsphaltSlice(0,0,0, stdHalf, stdHalf, 0); 
                    const easeSine = (t) => (1 - Math.cos(t * Math.PI)) / 2;
                    const cubicBezier = (p0, p1, p2, p3, t) => { const u = 1 - t; return (u*u*u * p0) + (3*u*u*t * p1) + (3*u*t*t * p2) + (t*t*t * p3); };

                    circuitData.pieces.forEach((p, index) => {
                        if (p.subtype === 'rotonda') {
                            const steps = 40; const r = p.radius || 14.5; const loopCenterX = r * 1.3; const laneOffVal = laneSpacing / 2; const startX = curX; const startZ = curZ; const startAngle = curAngle; const straightLen = 10.0;
                            const rotVertexIndex = rails.lane1.length;
                            rails.lane1.push(null); rails.lane2.push(null); rails.pit.push(null); vertexDistances.push(accumulatedDist);
                            const loopRailPoints = []; const loopArcLength = Math.PI * r; const straightParts = loopCenterX * 2; const totalPieceLen = straightLen + straightLen + loopArcLength + straightParts; const loopStepDist = (loopArcLength + straightParts) / steps;
                            const startRailX = startX + (Math.cos(startAngle + Math.PI/2) * -laneOffVal); const startRailZ = startZ + (Math.sin(startAngle + Math.PI/2) * -laneOffVal); loopRailPoints.push(new THREE.Vector3(startRailX, 0.2, startRailZ));
                            const singleLaneWidth = 4.5; addAsphaltSlice(startX, startZ, startAngle, 9.0, 9.0, accumulatedDist);
                            const straightEndX = startX + straightLen * Math.cos(startAngle); const straightEndZ = startZ + straightLen * Math.sin(startAngle);
                            const straightEndRailX = straightEndX + (Math.cos(startAngle + Math.PI/2) * -laneOffVal); const straightEndRailZ = straightEndZ + (Math.sin(startAngle + Math.PI/2) * -laneOffVal); loopRailPoints.push(new THREE.Vector3(straightEndRailX, 0.2, straightEndRailZ));
                            addAsphaltSlice(straightEndX, straightEndZ, startAngle, 9.0, 9.0, accumulatedDist + straightLen);
                            for (let i = 0; i <= steps; i++) { 
                                const tTotal = i / steps; let localX, localZ, localAngle;
                                if (tTotal < 0.3) { const t = tTotal / 0.3; localX = cubicBezier(0, loopCenterX * 0.4, loopCenterX * 0.4, loopCenterX, t); localZ = cubicBezier(-laneOffVal, -laneOffVal, -r, -r, t); const dX = (3*(1-t)*(1-t) * (loopCenterX*0.4 - 0)) + (6*(1-t)*t * (loopCenterX*0.4 - loopCenterX*0.4)) + (3*t*t * (loopCenterX - loopCenterX*0.4)); const dZ = (3*(1-t)*(1-t) * (-laneOffVal - -laneOffVal)) + (6*(1-t)*t * (-r - -laneOffVal)) + (3*t*t * (-r - -r)); localAngle = Math.atan2(dZ, dX); } 
                                else if (tTotal < 0.7) { const t = (tTotal - 0.3) / 0.4; const currentArcAngle = -Math.PI / 2 + (Math.PI * t); localX = loopCenterX + r * Math.cos(currentArcAngle); localZ = r * Math.sin(currentArcAngle); localAngle = currentArcAngle + Math.PI / 2; } 
                                else { const t = (tTotal - 0.7) / 0.3; localX = cubicBezier(loopCenterX, loopCenterX * 0.4, loopCenterX * 0.4, 0, t); localZ = cubicBezier(r, r, laneOffVal, laneOffVal, t); const dX = (3*(1-t)*(1-t) * (loopCenterX*0.4 - loopCenterX)) + (6*(1-t)*t * (loopCenterX*0.4 - loopCenterX*0.4)) + (3*t*t * (0 - loopCenterX*0.4)); const dZ = (3*(1-t)*(1-t) * (r - r)) + (6*(1-t)*t * (laneOffVal - r)) + (3*t*t * (laneOffVal - laneOffVal)); localAngle = Math.atan2(dZ, dX); }
                                const cosA = Math.cos(startAngle); const sinA = Math.sin(startAngle); const worldX = straightEndX + (localX * cosA - localZ * sinA); const worldZ = straightEndZ + (localX * sinA + localZ * cosA); const worldAngle = startAngle + localAngle;
                                if (i > 0) loopRailPoints.push(new THREE.Vector3(worldX, 0.2, worldZ)); addAsphaltSlice(worldX, worldZ, worldAngle, singleLaneWidth, singleLaneWidth, accumulatedDist + straightLen + (i * loopStepDist));
                            }
                            const returnStartRailX = straightEndX + (Math.cos(startAngle + Math.PI/2) * laneOffVal); const returnStartRailZ = straightEndZ + (Math.sin(startAngle + Math.PI/2) * laneOffVal);
                            const endRailX = startX + (Math.cos(startAngle + Math.PI/2) * laneOffVal); const endRailZ = startZ + (Math.sin(startAngle + Math.PI/2) * laneOffVal); loopRailPoints.push(new THREE.Vector3(endRailX, 0.2, endRailZ));
                            addAsphaltSlice(startX, startZ, startAngle + Math.PI, 9.0, 9.0, accumulatedDist + totalPieceLen);
                            rails.changes.push({ points: loopRailPoints, refIdx: rotVertexIndex, count: steps + 2, isRotonda: true });
                            curX = startX; curZ = startZ; curAngle = startAngle + Math.PI; accumulatedDist += totalPieceLen;
                            addRailPoint(curX, curZ, curAngle, -laneOffVal, laneOffVal, null, 0); vertexDistances.push(accumulatedDist); 
                            pieceMapRef.current.push({ index: index, distStart: accumulatedDist - totalPieceLen, distEnd: accumulatedDist, type: p.type, subtype: p.subtype, invert: p.invert });
                            return; 
                        }

                        const startDist = accumulatedDist, steps = (p.type === 'curve') ? Math.ceil(Math.abs(p.angle) * 2) : 10, stepLen = p.length / steps, totalSweep = (p.type==='curve') ? (p.angle * Math.PI / 180) * (p.direction==='left'?-1:1) : 0, stepAngle = totalSweep / steps; let stepPhysDist = stepLen; if (p.type === 'curve') stepPhysDist = (2 * Math.PI * p.radius) * (Math.abs(p.angle) / 360) / steps;
                        const isC = p.subtype === 'crossing', isPi = p.type === 'pit_entry', isPo = p.type === 'pit_exit', isCe = p.subtype === 'chicane_entry', isCx = p.subtype === 'chicane_exit';
                        const pitSide = p.invert ? 'left' : 'right', pitDir = pitSide === 'right' ? 1 : -1;
                        let sL1 = l1Off, sL2 = l2Off, tL1 = l1Off, tL2 = l2Off;
                        if (isC) { tL1 = l2Off; tL2 = l1Off; l1Off = tL1; l2Off = tL2; } else if (isCe) { tL1 = sL1 * 0.2; tL2 = sL2 * 0.2; l1Off = tL1; l2Off = tL2; } else if (isCx) { tL1 = (sL1 > 0 ? 1 : -1) * (laneSpacing / 2); tL2 = (sL2 > 0 ? 1 : -1) * (laneSpacing / 2); l1Off = tL1; l2Off = tL2; }
                        const d12 = [], d21 = [];
                        for (let i = 1; i <= steps; i++) {
                            const t = i / steps; if (p.type === 'curve') { const r = p.radius, chordLen = 2 * r * Math.sin(Math.abs(stepAngle)/2), chordDir = curAngle + stepAngle/2; curX += chordLen * Math.cos(chordDir); curZ += chordLen * Math.sin(chordDir); curAngle += stepAngle; } else { curX += stepLen * Math.cos(curAngle); curZ += stepLen * Math.sin(curAngle); }
                            let mixT = (isC || isCe || isCx) ? easeSine(t) : t; const cL1 = sL1 + (tL1 - sL1) * mixT, cL2 = sL2 + (tL2 - sL2) * mixT;
                            let cPit = null, cTWL = stdHalf, cTWR = stdHalf;
                            if (isPi) { const sp = pitDir * (laneSpacing/2), ep = pitDir * pitCenterDist, e = t*t*(3-2*t); cPit = sp + (ep-sp)*e; if(pitSide==='right') cTWR = stdHalf + (pitOuterEdge-stdHalf)*e; else cTWL = stdHalf + (pitOuterEdge-stdHalf)*e; }
                            else if (isPo) { const sp = pitDir * pitCenterDist, ep = pitDir * (laneSpacing/2), e = t*t*(3-2*t); cPit = sp + (ep-sp)*e; if(pitSide==='right') cTWR = pitOuterEdge - (pitOuterEdge-stdHalf)*e; else cTWL = pitOuterEdge - (pitOuterEdge-stdHalf)*e; }
                            else if (p.subtype && p.subtype.includes('pit_parallel')) { cPit = pitDir * pitCenterDist; if(pitSide==='right') cTWR = pitOuterEdge; else cTWL = pitOuterEdge; }
                            addRailPoint(curX, curZ, curAngle, cL1, cL2, cPit, stepPhysDist); addAsphaltSlice(curX, curZ, curAngle, cTWL, cTWR, accumulatedDist);
                            if (['digital_x', 'change_right', 'change_left'].includes(p.subtype)) { const ct = easeSine(t), o12 = sL1 + (sL2-sL1)*ct, o21 = sL2 + (sL1-sL2)*ct, px = Math.cos(curAngle+Math.PI/2), pz = Math.sin(curAngle+Math.PI/2); if (p.subtype !== 'change_left') d12.push(new THREE.Vector3(curX+px*o12, 0.2, curZ+pz*o12)); if (p.subtype !== 'change_right') d21.push(new THREE.Vector3(curX+px*o21, 0.2, curZ+pz*o21)); }
                        }
                        if (d12.length > 0) rails.changes.push(d12); if (d21.length > 0) rails.changes.push(d21);
                        pieceMapRef.current.push({ index, distStart: startDist, distEnd: accumulatedDist, type: p.type, subtype: p.subtype, invert: p.invert, canChangeLane: ['digital_x','change_right','change_left','pit_entry'].includes(p.subtype) || p.type === 'pit_entry' || p.type === 'pit_exit', isPitSection: isPi || isPo || (p.subtype && p.subtype.includes('pit_parallel')) });
                    });
                    
                    let finalRallyPath = []; let rallyDists = [0]; let currentRallyDist = 0;
                    if (hasRotonda) {
                        const rotondas = rails.changes.filter(c => c.isRotonda).sort((a, b) => a.refIdx - b.refIdx);
                        const startRotondaRef = rotondas.length > 0 ? rotondas[0].refIdx : -1;
                        const endRotondaRef = rotondas.length > 0 ? rotondas[rotondas.length - 1].refIdx : -1;
                        const appendPath = (points) => { if (points.length === 0) return; const newPoints = points.map(p => p.clone()); if (finalRallyPath.length > 0) { const lastP = finalRallyPath[finalRallyPath.length - 1]; const firstP = newPoints[0]; if (lastP.distanceTo(firstP) < 10.0) { firstP.copy(lastP); } else { finalRallyPath.push(new THREE.Vector3().lerpVectors(lastP, firstP, 0.5)); } } newPoints.forEach(p => finalRallyPath.push(p)); };
                        let currentSegment = [];
                        for (let i = 0; i < rails.lane1.length; i++) { if (rails.lane1[i]) { currentSegment.push(rails.lane1[i]); } else { if (currentSegment.length > 0) { appendPath(currentSegment); currentSegment = []; } const rotChange = rails.changes.find(c => c.isRotonda && Math.abs(c.refIdx - i) < 3); if (rotChange) { if (rotChange.refIdx >= endRotondaRef && i > 5) { appendPath(rotChange.points); } while(i < rails.lane1.length - 1 && rails.lane1[i+1] === null) { i++; } } } } if (currentSegment.length > 0) appendPath(currentSegment);
                        currentSegment = [];
                        for (let i = rails.lane2.length - 1; i >= 0; i--) { if (rails.lane2[i]) { currentSegment.push(rails.lane2[i]); } else { if (currentSegment.length > 0) { appendPath(currentSegment); currentSegment = []; } const rotChange = rails.changes.find(c => c.isRotonda && Math.abs(c.refIdx - i) < 3); if (rotChange) { if (rotChange.refIdx <= startRotondaRef) { appendPath(rotChange.points); } while(i > 0 && rails.lane2[i-1] === null) { i--; } } } } if (currentSegment.length > 0) appendPath(currentSegment);
                        const cleanPath = (points) => { if (points.length < 2) return points; const cleaned = [points[0]]; for (let i = 1; i < points.length; i++) { if (points[i].distanceTo(cleaned[cleaned.length - 1]) > 0.05) { cleaned.push(points[i]); } } return cleaned; }; finalRallyPath = cleanPath(finalRallyPath);
                        if (finalRallyPath.length > 0) { const first = finalRallyPath[0]; const last = finalRallyPath[finalRallyPath.length - 1]; if (first.distanceTo(last) > 0.5) { finalRallyPath.push(new THREE.Vector3().lerpVectors(last, first, 0.33)); finalRallyPath.push(new THREE.Vector3().lerpVectors(last, first, 0.66)); finalRallyPath.push(first.clone()); } }
                        if (finalRallyPath.length > 10) { for (let iter = 0; iter < 10; iter++) { const smoothed = []; const len = finalRallyPath.length; for (let i = 0; i < len; i++) { const prev = finalRallyPath[(i - 1 + len) % len]; const curr = finalRallyPath[i]; const next = finalRallyPath[(i + 1) % len]; const x = (prev.x + curr.x + next.x) / 3; const y = (prev.y + curr.y + next.y) / 3; const z = (prev.z + curr.z + next.z) / 3; smoothed.push(new THREE.Vector3(x, y, z)); } finalRallyPath = smoothed; } }
                        for(let i=1; i<finalRallyPath.length; i++) { const d = finalRallyPath[i].distanceTo(finalRallyPath[i-1]); currentRallyDist += d; rallyDists.push(currentRallyDist); }
                    }
                    rallyPathRef.current = finalRallyPath; rallyDistancesRef.current = rallyDists;

                    const totalDist = accumulatedDist; physicsState.current.forEach(car => { if (totalDist > 0) { while (car.distance < 0) car.distance += totalDist; car.distance = car.distance % totalDist; } });
                    const createRailMesh = (pts, c, w=0.6) => { const cp = pts.filter(p => p !== null); if(cp.length < 2) return; const path = new THREE.CatmullRomCurve3(cp); const g = new THREE.TubeGeometry(path, Math.max(2, cp.length), w/1.8, 8, false); const m = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 1.0, roughness: 0.15 }); const mesh = new THREE.Mesh(g, m); mesh.castShadow = true; trackGroup.add(mesh); };
                    const createMultiSegmentRailMesh = (points, color, width=0.6) => { let currentSegment = []; for (let p of points) { if (p === null) { if (currentSegment.length > 1) createRailMesh(currentSegment, color, width); currentSegment = []; } else { currentSegment.push(p); } } if (currentSegment.length > 1) createRailMesh(currentSegment, color, width); };

                    const ag = new THREE.BufferGeometry(); ag.setAttribute('position', new THREE.Float32BufferAttribute(asphaltVerts, 3)); ag.setAttribute('uv', new THREE.Float32BufferAttribute(asphaltUVs, 2)); ag.setIndex(asphaltIndices); ag.computeVertexNormals(); 
                    const am = new THREE.Mesh(ag, new THREE.MeshStandardMaterial({ map: asphaltTexture, side: THREE.DoubleSide })); am.receiveShadow = true; trackGroup.add(am);
                    createMultiSegmentRailMesh(rails.lane1, null, 0.7); createMultiSegmentRailMesh(rails.lane2, null, 0.7); 
                    let curSeg = []; for (let p of rails.pit) { if (p === null) { if (curSeg.length > 1) createRailMesh(curSeg, null, 0.6); curSeg = []; } else { curSeg.push(p); } } if (curSeg.length > 1) createRailMesh(curSeg, null, 0.6); 
                    rails.changes.forEach(obj => { if (obj.points) createRailMesh(obj.points, null, 0.5); else createRailMesh(obj, null, 0.5); });
                    
                    const finishLinePiece = pieceMapRef.current.find(p => p.subtype === 'analog_connect' || p.subtype === 'connection' || p.subtype === 'digital_console') || pieceMapRef.current[0];
                    if (finishLinePiece) {
                        const getPosAt = (pa, d) => { let i=0; while(i < vertexDistances.length-1 && vertexDistances[i+1] < d) i++; const r = (d - vertexDistances[i]) / (vertexDistances[i+1] - vertexDistances[i]); if(!pa[i] || !pa[i+1]) return null; return new THREE.Vector3().lerpVectors(pa[i], pa[i+1], r); };
                        const midD = finishLinePiece.distStart + (finishLinePiece.distEnd - finishLinePiece.distStart) / 2;
                        const p1 = getPosAt(rails.lane1, midD), p2 = getPosAt(rails.lane2, midD);
                        if (p1 && p2) {
                            const mid = new THREE.Vector3().lerpVectors(p1, p2, 0.5);
                            const tangent = new THREE.Vector3().subVectors(getPosAt(rails.lane1, midD + 1), p1).normalize();
                            const lineG = new THREE.BoxGeometry(trackWidth, 0.02, 1.8);
                            const lineCanvas = document.createElement('canvas'); lineCanvas.width = 128; lineCanvas.height = 32; const lineCtx = lineCanvas.getContext('2d');
                            lineCtx.fillStyle = 'white'; lineCtx.fillRect(0,0,128,32); lineCtx.fillStyle = 'black';
                            for(let x=0; x<128; x+=16) for(let y=0; y<32; y+=16) if((x+y)/16 % 2 === 0) lineCtx.fillRect(x,y,16,16);
                            const lineTex = new THREE.CanvasTexture(lineCanvas);
                            const lineM = new THREE.MeshStandardMaterial({ map: lineTex, roughness: 0.9, polygonOffset: true, polygonOffsetFactor: -1 });
                            const lineMesh = new THREE.Mesh(lineG, lineM);
                            lineMesh.position.set(mid.x, 0.02, mid.z);
                            const lookAtPos = mid.clone().add(tangent); lookAtPos.y = 0.02; lineMesh.lookAt(lookAtPos);
                            trackGroup.add(lineMesh);
                        }
                    }

                    const b = new THREE.Box3().setFromObject(trackGroup); if (!b.isEmpty()) { const center = b.getCenter(new THREE.Vector3()); trackGroup.position.sub(center); trackGroup.position.y = 0; } scene.add(trackGroup);
                    if (rails.lane1.length > 2) { physicsState.current.forEach((car) => { const s = carSetupsRef.current[car.id]; if (!s) return; const cc = parseInt(s.color.replace('#','0x')); const c = createCar(car.id, cc); trackGroup.add(c); carMeshes.push(c); }); }
                    const getPositionAtDistance = (pa, d) => { let i = 0, min = 0, max = vertexDistances.length - 1; while (min <= max) { let mid = Math.floor((min + max) / 2); if (vertexDistances[mid] <= d) { i = mid; min = mid + 1; } else { max = mid - 1; } } if (i >= vertexDistances.length - 1) i = vertexDistances.length - 2; const r = (d - vertexDistances[i]) / (vertexDistances[i+1] - vertexDistances[i]); if (!pa[i] || !pa[i+1]) return pa[i] || pa[i+1]; return new THREE.Vector3().lerpVectors(pa[i], pa[i+1], r); };
                    const getRallyPositionByDist = (dist) => { const path = rallyPathRef.current; const dists = rallyDistancesRef.current; if (!path || path.length < 2 || dists.length < 2) return new THREE.Vector3(); const totalLen = dists[dists.length - 1]; let safeDist = dist; if (safeDist < 0) safeDist += totalLen; safeDist = safeDist % totalLen; let idx = 0; let min = 0, max = dists.length - 1; while (min <= max) { let mid = Math.floor((min + max) / 2); if (dists[mid] <= safeDist) { idx = mid; min = mid + 1; } else { max = mid - 1; } } if (idx >= dists.length - 1) idx = dists.length - 2; const dStart = dists[idx]; const dEnd = dists[idx+1]; const segmentLen = dEnd - dStart; const ratio = segmentLen > 0.00001 ? (safeDist - dStart) / segmentLen : 0; const p1 = path[idx]; const p2 = path[idx+1]; return new THREE.Vector3().lerpVectors(p1, p2, ratio); };

                    const animate = () => { 
                        animationId = requestAnimationFrame(animate); const dt = clock.current.getDelta(); 
                        cameraTarget.lerp(new THREE.Vector3(0,0,0), 0.1); 
                        const camPos = new THREE.Vector3().setFromSpherical(spherical);
                        camera.position.copy(cameraTarget).add(camPos); camera.lookAt(cameraTarget);
                        const shouldMove = !pausedRef.current && (raceStateRef.current === 'idle' || raceStateRef.current === 'racing'), nowTime = Date.now();
                        
                        if (carMeshes.length > 0 && vertexDistances.length > 1) { 
                            const vf = trackVoltage / 12.0;
                            const totalDist = accumulatedDist;
                            const finishPiece = pieceMapRef.current.find(p => p.subtype === 'analog_connect' || p.subtype === 'connection' || p.subtype === 'digital_console') || pieceMapRef.current[0];
                            const finishLineDist = finishPiece ? (finishPiece.distStart + (finishPiece.distEnd - finishPiece.distStart) * 0.5) : 0;

                            physicsState.current.forEach((car, idx) => {
                                if (idx >= carMeshes.length) return; const pg = carMeshes[idx], vg = pg.children[0], s = carSetupsRef.current[car.id]; if (!s) return;
                                if (car.id > numCarsRef.current) { if (vg.visible) vg.visible = false; return; } else { if (!vg.visible && nowTime >= car.invulnerableUntil) vg.visible = true; }
                                const gr = s.gearTeeth / s.pinionTeeth, ms = (s.motorRPM / 150) * (3.0 / gr) * vf, acc = (s.motorTorque / s.weight) * gr * vf * 80;
                                let ts = ms, isB = false;
                                if (activeButtonRef.current === 'DIGITAL' || activeButtonRef.current === 'PRACTICE') {
                                    const ac = physicsState.current.filter(c => c.id <= numCarsRef.current && c.id !== car.id && !c.isDerailled);
                                    let dtc = Infinity; 
                                    ac.forEach(o => { 
                                        if (o.currentLane === car.currentLane || o.targetLane === car.currentLane) { 
                                            let di = o.distance - car.distance; 
                                            if (di < -totalDist / 2) di += totalDist; else if (di > totalDist / 2) di -= totalDist;
                                            if (di > 0 && di < dtc) dtc = di; 
                                        } 
                                    });
                                    const minGap = car.speed < 20 ? 10 : 60; 
                                    if (dtc < minGap) { ts *= Math.max(0.15, (dtc - 5) / (minGap - 5)); if (dtc < 15 && car.speed > 50) isB = true; }
                                }
                                if (activeButtonRef.current === 'PRACTICE' || activeButtonRef.current === 'DIGITAL') {
                                    if (car.id === selectedCarIdRef.current) { const th = manualThrottleRef.current / 100.0; ts = Math.min(ts, ms * th); if (th < 0.05) isB = true; if (pitPressedRef.current) car.wantsToPit = true; } 
                                    else { const cp = pieceMapRef.current.find(p => p.index === car.lastPieceIndex); let ait = 0.85; if (cp && cp.type === 'curve') { ait = 0.30 + (Math.min(1, cp.radius / 90.0) * 0.45); } else if (cp && cp.subtype && cp.subtype.includes('chicane')) ait = 0.35; ait *= (0.9 + Math.random() * 0.1); if (car.id > 2) ait *= 0.9; ts = Math.min(ts, ms * ait); if (car.fuel < 15 && Math.random() > 0.9) car.wantsToPit = true; }
                                } else if (activeButtonRef.current === 'ANALOG' && shouldMove) {
                                    if (car.id === selectedCarIdRef.current) { const th = manualThrottleRef.current / 100.0; ts = ms * th; if (th < 0.05) isB = true; } 
                                    else { const cp = pieceMapRef.current.find(p => p.index === car.lastPieceIndex); let ait = 0.95; if (cp && cp.type === 'curve') ait = 0.40 + (Math.min(1, cp.radius/90) * 0.55); ts = ms * ait; }
                                }
                                const cp = pieceMapRef.current.find(p => car.distance >= p.distStart && car.distance < p.distEnd);
                                if (shouldMove && car.speed > 10 && activeButtonRef.current === 'DIGITAL') { car.fuel = Math.max(0, car.fuel - (car.speed/ms)*dt*2.5); }
                                if (activeButtonRef.current === 'DIGITAL' && car.fuel <= 0) ts = ms * 0.2; 
                                if (car.currentLane === LANE_PIT && cp && cp.subtype && cp.subtype.includes('pit_parallel')) {
                                    const pl = cp.distEnd - cp.distStart, dip = car.distance - cp.distStart;
                                    if (car.wantsToPit && !car.hasRefueledThisLap && dip > pl * 0.45) { if (!car.isRefueling) { car.isRefueling = true; car.refuelStartTime = nowTime; car.speed = 0; car.distance = cp.distStart + (pl * 0.5); } }
                                }
                                if (car.isRefueling) {
                                    car.speed = 0; ts = 0; car.fuel = Math.min(100, car.fuel + (dt * 35));
                                    if (nowTime - car.refuelStartTime >= 3000) { car.isRefueling = false; car.hasRefueledThisLap = true; car.wantsToPit = false; } else { pg.position.y = 0.2 + Math.sin(nowTime * 0.05) * 0.02; return; }
                                }
                                if (cp && cp.type === 'pit_exit') { car.hasRefueledThisLap = false; if (car.id === selectedCarIdRef.current) car.wantsToPit = false; }
                                if (car.isDerailled) { car.velocity.y -= 9.8 * dt * 5; car.worldPos.add(car.velocity.clone().multiplyScalar(dt)); if (car.worldPos.y < 0.5) { car.worldPos.y = 0.5; car.velocity.y *= -0.5; car.velocity.x *= 0.8; car.velocity.z *= 0.8; } pg.position.copy(car.worldPos); pg.rotation.x += car.velocity.z*dt*0.1; pg.rotation.z -= car.velocity.x*dt*0.1; if (nowTime > car.recoverTime) { car.isDerailled = false; car.speed = 0; car.invulnerableUntil = nowTime + 3000; pg.rotation.set(0,0,0); pg.position.y = 0.2; if (car.id <= numCarsRef.current) vg.visible = true; } return; }
                                if (nowTime < car.invulnerableUntil) vg.visible = Math.floor(nowTime / 100) % 2 === 0; 
                                const cas = carAssetsRef.current[car.id]; if (vg && cas) { if (cas.rotation) { vg.rotation.x = cas.rotation[0]*Math.PI/180; vg.rotation.y = cas.rotation[1]*Math.PI/180; vg.rotation.z = cas.rotation[2]*Math.PI/180; } if (cas.yOffset !== undefined) vg.position.y = parseFloat(cas.yOffset); }
                                const oldDist = car.distance;
                                if (shouldMove) { if (car.speed < ts) car.speed += acc * dt; else if (car.speed > ts) car.speed -= acc * dt * (isB ? 4.0 : 1.5); if (car.speed < 0) car.speed = 0; car.distance += car.speed * dt; }
                                
                                if (hasRotonda && rallyPathRef.current.length > 0 && rallyDistancesRef.current.length > 0) {
                                    const rallyTotalLen = rallyDistancesRef.current[rallyDistancesRef.current.length - 1]; 
                                    if (car.distance >= rallyTotalLen) { 
                                        car.distance -= rallyTotalLen; 
                                        const registerLap = () => { if (car.lapStartTime > 0) { const lapTime = nowTime - car.lapStartTime; car.lastLapTime = lapTime; if (lapTime < car.bestLapTime) car.bestLapTime = lapTime; car.totalLapTime += lapTime; car.completedLaps++; } car.lapStartTime = nowTime; };
                                        if (raceStateRef.current === 'idle') { registerLap(); car.laps++; } else if (raceStateRef.current === 'racing') { registerLap(); car.laps--; if (car.laps <= 0) { raceStateRef.current = 'finished'; setRaceState('finished'); setWinnerId(car.id); if (timerIntervalRef.current) clearInterval(timerIntervalRef.current); playRaceSound('green'); } }
                                    }
                                    const finalPos = getRallyPositionByDist(car.distance);
                                    const tangentSample = getRallyPositionByDist(car.distance + 0.5);
                                    const dir = new THREE.Vector3().subVectors(tangentSample, finalPos).normalize();
                                    car.worldPos.copy(finalPos);
                                    pg.position.copy(finalPos).add(new THREE.Vector3(0, 0.2, 0));
                                    const targetMatrix = new THREE.Matrix4(); const up = new THREE.Vector3(0, 1, 0); targetMatrix.lookAt(finalPos, finalPos.clone().add(dir), up);
                                    const targetRotation = new THREE.Quaternion(); targetRotation.setFromRotationMatrix(targetMatrix);
                                    pg.quaternion.slerp(targetRotation, 20.0 * dt);
                                } else {
                                    let crossedFinish = false;
                                    if (car.distance >= totalDist) {
                                        const distAfterWrap = car.distance - totalDist;
                                        if (oldDist <= finishLineDist && totalDist > finishLineDist) crossedFinish = true; 
                                        if (finishLineDist <= distAfterWrap) crossedFinish = true;
                                        car.distance = distAfterWrap;
                                    } else { if (oldDist < finishLineDist && car.distance >= finishLineDist) crossedFinish = true; }

                                    if (crossedFinish && shouldMove) {
                                        if (!car.crossedStartLine) { car.crossedStartLine = true; } else {
                                            const lapDuration = nowTime - car.lapStartTime;
                                            if (raceStateRef.current === 'idle') { 
                                                car.lastLapTime = lapDuration; if(car.lastLapTime < car.bestLapTime) car.bestLapTime = car.lastLapTime; car.totalLapTime += car.lastLapTime; car.completedLaps++; car.lapStartTime = nowTime; car.laps++; 
                                            } else if (raceStateRef.current === 'racing') { 
                                                car.lastLapTime = lapDuration; if(car.lastLapTime < car.bestLapTime) car.bestLapTime = car.lastLapTime; car.totalLapTime += car.lastLapTime; car.completedLaps++; 
                                                
                                                if (['GRID', 'ANALOG', 'DIGITAL'].includes(activeButtonRef.current)) {
                                                    const currentSetup = carSetupsRef.current[car.id];
                                                    if (currentSetup) {
                                                        const lapData = { lap: car.completedLaps, time: lapDuration, motor: currentSetup.motorName, tire: currentSetup.tireName, gear: `${currentSetup.gearTeeth}/${currentSetup.pinionTeeth}`, voltage: trackVoltageRef.current, weight: currentSetup.weight };
                                                        if (!sessionDataRef.current[car.id]) sessionDataRef.current[car.id] = [];
                                                        sessionDataRef.current[car.id].push(lapData);
                                                    }
                                                }
                                                car.lapStartTime = nowTime; car.laps--; 
                                                if (car.laps <= 0) { 
                                                    raceStateRef.current = 'finished'; setRaceState('finished'); setWinnerId(car.id); 
                                                    if (['GRID', 'ANALOG', 'DIGITAL'].includes(activeButtonRef.current)) { setSessionResults({...sessionDataRef.current}); }
                                                    if (timerIntervalRef.current) clearInterval(timerIntervalRef.current); playRaceSound('green'); 
                                                } 
                                            }
                                        }
                                    }

                                    const lookAhead = 3.0; 
                                    const pl1 = getPositionAtDistance(rails.lane1, car.distance), pl2 = getPositionAtDistance(rails.lane2, car.distance), ppit = getPositionAtDistance(rails.pit, car.distance) || pl2;
                                    let mf = 0, mf_look = 0; 
                                    if (car.isChanging && cp) { 
                                        const len = cp.distEnd - cp.distStart; const local = car.distance - cp.distStart; car.changeProgress = local / len; mf = easeSine(car.changeProgress); 
                                        const localLook = local + lookAhead; if (localLook < len) { mf_look = easeSine(localLook / len); } else { mf_look = 1; }
                                    }
                                    const glv = (l) => l===LANE_PIT?ppit:(l===LANE_2?pl2:pl1);
                                    const fpos = new THREE.Vector3().lerpVectors(glv(car.currentLane), glv(car.targetLane), mf);
                                    const nxt = (car.distance + lookAhead) % totalDist;
                                    const fl1 = getPositionAtDistance(rails.lane1, nxt), fl2 = getPositionAtDistance(rails.lane2, nxt), fpit = getPositionAtDistance(rails.pit, nxt) || fl2;
                                    const glvf = (l) => l===LANE_PIT?fpit:(l===LANE_2?fl2:fl1);
                                    const flook = new THREE.Vector3().lerpVectors(glvf(car.currentLane), glvf(car.targetLane), mf_look);
                                    const tan = new THREE.Vector3().subVectors(flook, fpos).normalize(); 
                                    car.worldPos.copy(fpos); pg.position.copy(fpos).add(new THREE.Vector3(0, 0.2, 0)); pg.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, 1), tan);
                                    
                                    if (cp) {
                                        if (car.lastPieceIndex !== cp.index) { 
                                            car.lastPieceIndex = cp.index; 
                                            if (car.isChanging) { car.isChanging = false; car.currentLane = car.targetLane; }
                                            if (car.currentLane === LANE_PIT && !cp.isPitSection) { car.currentLane = (car.targetLane === LANE_PIT) ? LANE_2 : car.targetLane; car.targetLane = car.currentLane; }
                                            if (car.targetLane === LANE_PIT && cp.isPitSection) car.currentLane = LANE_PIT; else if (car.currentLane !== LANE_PIT) car.currentLane = car.targetLane;
                                        }
                                        const distInPiece = car.distance - cp.distStart;
                                        const pieceLen = cp.distEnd - cp.distStart;
                                        const isEarlyInPiece = distInPiece < (pieceLen * 0.35); 
                                        if (!car.isChanging && laneActiveRef.current && cp.canChangeLane && shouldMove) {
                                            let nl = car.currentLane, sc = false, isPlayer = (car.id === selectedCarIdRef.current && activeButtonRef.current === 'DIGITAL');
                                            if (car.currentLane !== LANE_PIT && isEarlyInPiece) {
                                                if (isPlayer) {
                                                    const wc = laneChangePressedRef.current || (autoLaneChangeRef.current && Math.random()>0.5);
                                                    const wp = car.wantsToPit; 
                                                    if (cp.type === 'pit_entry') { if (car.currentLane === (cp.invert?LANE_1:LANE_2) && wp) { nl = LANE_PIT; sc = true; } }
                                                    else if (wc) { if (cp.subtype === 'digital_x') { nl = (car.currentLane===LANE_1?LANE_2:LANE_1); sc = true; } else if (cp.subtype === 'change_right' && car.currentLane === LANE_1) { nl = LANE_2; sc = true; } else if (cp.subtype === 'change_left' && car.currentLane === LANE_2) { nl = LANE_1; sc = true; } }
                                                } else { if (cp.subtype === 'digital_x' && Math.random()>0.5) { nl = (car.currentLane===LANE_1?LANE_2:LANE_1); sc = true; } else if (cp.type === 'pit_entry' && car.currentLane === (cp.invert?LANE_1:LANE_2) && car.wantsToPit) { nl = LANE_PIT; sc = true; } }
                                            }
                                            if (cp.type === 'pit_exit' && car.currentLane === LANE_PIT) { nl = cp.invert?LANE_1:LANE_2; sc = true; }
                                            if (sc) { car.isChanging = true; car.targetLane = nl; car.changeProgress = distInPiece / pieceLen; }
                                        }
                                    }
                                }
                            });
                            if (shouldMove && numCarsRef.current >= 2) { 
                                const ac = physicsState.current.filter(c => c.id <= numCarsRef.current && !c.isDerailled);
                                for (let i=0; i<ac.length; i++) for (let j=i+1; j<ac.length; j++) if(nowTime > ac[i].invulnerableUntil && nowTime > ac[j].invulnerableUntil) if(ac[i].worldPos.distanceTo(ac[j].worldPos) < 3.5) [ac[i], ac[j]].forEach(c => { c.isDerailled=true; c.recoverTime=nowTime+2000; c.velocity.set((Math.random()-0.5)*50, 10+Math.random()*20, (Math.random()-0.5)*50); });
                            }
                            if (nowTime - lastUIUpdate.current > 100) {
                                const currentTrackLen = (hasRotonda && rallyDistancesRef.current.length > 0) ? rallyDistancesRef.current[rallyDistancesRef.current.length - 1] : totalDist;
                                const ac = physicsState.current.filter(c => c.id <= numCarsRef.current);
                                const sc = ac.map(c => ({ ...c, sc: (raceStateRef.current !== 'idle' ? targetLapsRef.current - c.laps : c.laps) + c.distance/currentTrackLen })).sort((a,b)=>b.sc-a.sc);
                                setTelemetry(physicsState.current.map(c => ({ id: c.id, speed: Math.round(c.speed * 1.15), lastLap: c.lastLapTime, bestLap: c.bestLapTime===Infinity?0:c.bestLapTime, laps: c.laps, position: sc.findIndex(x=>x.id===c.id)+1, fuel: c.fuel })));
                                lastUIUpdate.current = nowTime;
                            }
                        } 
                        renderer.render(scene, camera); 
                    };
                    animate(); 
                    window.addEventListener('resize', onResize); 
                    renderer.domElement.addEventListener('mousedown', onMouseDown); 
                    window.addEventListener('mousemove', onMouseMove); 
                    window.addEventListener('mouseup', onMouseUp); 
                    renderer.domElement.addEventListener('wheel', onWheel, {passive:false});
                    renderer.domElement.addEventListener('touchstart', onTouchStart, {passive: false});
                    window.addEventListener('touchmove', onTouchMove, {passive: false});
                    window.addEventListener('touchend', onTouchEnd);
                    
                    setTimeout(() => {
                        if (activeButtonRef.current === 'DIGITAL') {
                             physicsState.current.forEach((car, i) => {
                                const startData = getStartingPosition(i, 'digital');
                                car.distance = startData.pos;
                                car.currentLane = startData.lane;
                                car.targetLane = startData.lane;
                            });
                        } else if (activeButtonRef.current === 'GRID' || activeButtonRef.current === 'ANALOG') {
                             physicsState.current.forEach((car, i) => {
                                const startData = getStartingPosition(i, 'analog');
                                car.distance = startData.pos;
                                car.currentLane = startData.lane;
                                car.targetLane = startData.lane;
                            });
                        }
                    }, 100);
                };
                init3D(); 
                return () => { window.removeEventListener('resize', onResize); if(renderer){ renderer.domElement.removeEventListener('mousedown', onMouseDown); if(animationId) cancelAnimationFrame(animationId); renderer.dispose(); } };
            }, [circuitData]); 

            return ( 
                <div className="absolute inset-0 z-50 bg-[#3b5f7d] text-white font-sans overflow-hidden animate-in"> 
                    <div ref={containerRef} className="absolute inset-0 w-full h-full" /> 
                    {validationError && (
                        <div className="absolute top-20 left-1/2 transform -translate-x-1/2 bg-red-600/90 text-white px-6 py-4 rounded-xl shadow-[0_0_20px_rgba(220,38,38,0.6)] flex items-center gap-4 z-[100] animate-in backdrop-blur-md border border-red-400">
                            <AlertTriangle size={32} className="animate-bounce"/>
                            <div><h3 className="font-bold text-lg leading-tight">IMPOSIBLE INICIAR</h3><p className="text-sm opacity-90">{validationError}</p></div>
                        </div>
                    )}
                    <button onClick={toggleFullscreen} className="absolute top-6 right-6 z-[80] w-12 h-12 flex items-center justify-center rounded-lg bg-black/60 border-2 border-orange-500 text-orange-500 hover:bg-orange-500 hover:text-black transition-all duration-300 backdrop-blur-md shadow-[0_0_15px_rgba(249,115,22,0.5)] pointer-events-auto group animate-pulse hover:animate-none">{isFullscreen ? <Minimize size={24}/> : <Maximize size={24}/>}</button>
                    {activeButton === 'DIGITAL' && (
                        <div className="absolute inset-0 pointer-events-none flex flex-col items-center pt-48 z-[60]">
                            <div className="w-full flex flex-wrap justify-center gap-x-2 gap-y-2 px-4 mt-4 pointer-events-none perspective-1000">
                                {telemetry.filter(t => t.id <= numCars).sort((a,b) => a.position - b.position).map((car) => {
                                    const config = carSetups[car.id];
                                    let gap = car.position === 1 ? "LIDER" : `+${Math.random().toFixed(1)}s`, fuelColor = car.fuel > 75 ? config.color : (car.fuel > 50 ? '#eab308' : (car.fuel > 25 ? '#f97316' : '#ef4444'));
                                    return (
                                        <div key={car.id} className="relative w-[170px] h-[130px] pointer-events-auto transition-all duration-500 ease-out" style={{order: car.position}}>
                                            <div className={`absolute top-0 left-0 origin-top-left transform scale-[0.52] bg-[#050a05]/95 border-2 rounded-xl w-80 overflow-hidden backdrop-blur-xl animate-in transition-all duration-300 hover:scale-[0.55] hover:z-50 ${car.id === selectedCarId ? 'border-[#39ff14] shadow-[0_0_30px_rgba(57,255,20,0.2)]' : 'border-gray-700 opacity-90'}`} style={{borderColor: car.id === selectedCarId ? '#39ff14' : config.color}}>
                                                <div className="px-4 py-1.5 flex justify-between items-center" style={{backgroundColor: car.id === selectedCarId ? '#39ff14' : '#1e293b'}}>
                                                    <div className="flex items-center gap-2"><Zap size={14} className={car.id === selectedCarId ? "text-black animate-pulse" : "text-gray-400"}/><span className={`font-black text-[10px] tracking-[0.3em] uppercase ${car.id === selectedCarId ? 'text-black' : 'text-white'}`}>{config.name}</span></div>
                                                    <span className={`px-2 rounded text-[9px] font-bold font-mono ${car.id === selectedCarId ? 'bg-black/20 text-black' : 'bg-black/40 text-gray-400'}`}>ID:{car.id}</span>
                                                </div>
                                                <div className="p-4 flex flex-col gap-3 relative">
                                                    <div className="absolute inset-0 opacity-10 pointer-events-none" style={{backgroundImage: `linear-gradient(transparent 11px, ${config.color} 1px), linear-gradient(90deg, transparent 11px, ${config.color} 1px)`, backgroundSize: '12px 12px'}}></div>
                                                    <div className="flex justify-between items-end border-b border-gray-700/50 pb-2 relative z-10">
                                                        <div><span className="text-[9px] text-gray-500 font-bold uppercase tracking-widest block mb-[-2px]">POSICIÓN</span><div className="flex items-baseline gap-1"><span className="font-digital text-6xl font-black text-white italic drop-shadow-[0_0_10px_rgba(255,255,255,0.5)] leading-none">{car.position}</span></div></div>
                                                        <div className="flex flex-col items-end"><span className="text-[8px] text-gray-400 font-bold uppercase tracking-widest bg-black/40 px-1 rounded mb-1">GAP</span><span className={`font-mono text-2xl font-bold tracking-tight ${car.position === 1 ? 'text-[#39ff14]' : 'text-yellow-400'}`}>{gap}</span></div>
                                                    </div>
                                                    <div className="grid grid-cols-2 gap-2 relative z-10">
                                                        <div className="bg-white/5 border border-white/10 rounded p-1.5 flex flex-col"><span className="text-[7px] text-gray-400 font-bold uppercase mb-0.5">VUELTA</span><span className="font-digital text-lg text-white tracking-wider">{formatRaceTime(car.currentLap || 0)}</span></div>
                                                        <div className="bg-white/5 border border-white/10 rounded p-1.5 flex flex-col text-right"><span className="text-[7px] text-[#39ff14] font-bold uppercase mb-0.5">MEJOR</span><span className="font-digital text-lg text-[#39ff14] tracking-wider drop-shadow-[0_0_5px_rgba(57,255,20,0.5)]">{car.bestLap ? (car.bestLap/1000).toFixed(3) : '--.---'}</span></div>
                                                    </div>
                                                    <div className="relative z-10 pt-1">
                                                        <div className="flex justify-between items-end mb-1"><div className="flex items-center gap-1 text-gray-400"><Fuel size={12} /><span className="text-[8px] font-black tracking-[0.2em] uppercase">FUEL</span></div><span className={`font-mono text-[10px] font-bold ${car.fuel < 25 ? 'text-red-500 animate-pulse' : 'text-white'}`}>{Math.round(car.fuel)}%</span></div>
                                                        <div className="h-4 w-full bg-gray-900 rounded border border-gray-600 relative overflow-hidden shadow-[inset_0_0_10px_rgba(0,0,0,1)]"><div className="h-full transition-all duration-300 ease-out" style={{width: `${car.fuel}%`, backgroundColor: fuelColor}}></div></div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    )}
                    {activeButton === 'ANALOG' ? (
                        <AnalogDashboard telemetry={telemetry.slice(0,2)} carSetups={carSetups} raceState={raceState} activeLights={activeLights} elapsedTime={elapsedTime} targetLaps={targetLaps} />
                    ) : (
                        <div className="absolute top-10 left-1/2 transform -translate-x-1/2 z-[70] flex items-start gap-20 pointer-events-none w-full justify-center px-10">
                            <div className={`flex flex-col gap-3 pt-4 pointer-events-auto animate-in items-center transition-opacity duration-300 ${activeButton === 'DIGITAL' ? 'opacity-0 pointer-events-none' : 'opacity-100'}`}>
                                <button onClick={enterGridMode} className={`px-5 py-2.5 rounded-lg text-[10px] font-black tracking-[0.2em] border-2 uppercase transition-all duration-300 w-40 ${activeButton === 'GRID' ? 'bg-[#22d3ee] border-[#22d3ee] text-black shadow-[0_0_30px_rgba(34,211,238,0.8)]' : 'bg-gray-900/80 border-gray-700 text-gray-400'}`}>PREPARACIÓN</button>
                                <button onClick={startPracticeMode} className={`px-5 py-2.5 rounded-lg text-[10px] font-black tracking-[0.2em] border-2 uppercase transition-all duration-300 w-40 ${activeButton === 'PRACTICE' ? 'bg-[#a3e635] border-[#a3e635] text-black shadow-[0_0_30px_rgba(163,230,53,0.8)]' : 'bg-gray-900/80 border-gray-700 text-gray-400'}`}>{hasRotonda ? 'CRONO RALLY' : 'PRACTICAR'}</button>
                            </div>
                            <div className="flex flex-col items-center -mt-1 mx-2 shrink-0">
                                <div className="bg-black px-5 py-4 rounded-[1.5rem] border-4 border-gray-800 flex gap-4 shadow-[0_0_60px_black] backdrop-blur-md relative z-10">
                                    {[1, 2, 3, 4, 5].map(n => {
                                        const isRed = raceState === 'countdown' && activeLights >= n, isGreen = raceState === 'racing';
                                        return <div key={n} className={`w-10 h-10 rounded-full border-4 ${isGreen?'bg-[#39ff14] border-[#39ff14] shadow-[0_0_40px_#39ff14]':(isRed?'bg-[#ff0000] border-[#ff0000] shadow-[0_0_40px_#ff0000]':'bg-[#0a0a0a] border-gray-800')} transition-all duration-100`}></div>
                                    })}
                                </div>
                                {(activeButton === 'GRID' || activeButton === 'DIGITAL') && (
                                    <div className="mt-2 bg-black/80 border-2 border-[#39ff14] px-4 py-2 rounded-xl shadow-[0_0_30px_rgba(57,255,20,0.4)] backdrop-blur-md w-[420px]">
                                        <span className="text-white font-normal text-5xl tracking-widest font-timer tabular-nums text-center w-full block">{formatRaceTime(elapsedTime)}</span>
                                    </div>
                                )}
                            </div>
                            <div className={`flex flex-col gap-3 pt-4 pointer-events-auto animate-in items-center transition-opacity duration-300 ${activeButton === 'DIGITAL' ? 'opacity-0 pointer-events-none' : 'opacity-100'}`}>
                                {!hasRotonda && (
                                    <>
                                        <button onClick={handleAnalogMode} className={`px-5 py-2.5 rounded-lg text-[10px] font-black tracking-[0.2em] border-2 uppercase transition-all duration-300 w-40 ${activeButton === 'ANALOG' ? 'bg-[#fbbf24] border-[#fbbf24] text-black shadow-[0_0_30px_rgba(251,191,36,0.8)]' : 'bg-gray-900/80 border-gray-700 text-gray-400'}`}>ANALÓGICO</button>
                                        <button onClick={handleDigitalMode} className={`px-5 py-2.5 rounded-lg text-[10px] font-black tracking-[0.2em] border-2 uppercase transition-all duration-300 w-40 ${activeButton === 'DIGITAL' ? 'bg-[#d946ef] border-[#d946ef] text-black shadow-[0_0_30px_rgba(217,70,239,0.8)]' : 'bg-gray-900/80 border-gray-700 text-gray-400'}`}>DIGITAL</button>
                                    </>
                                )}
                                {hasRotonda && (
                                    <div className="px-5 py-2.5 rounded-lg text-[10px] font-black tracking-[0.2em] border-2 border-[#39ff14] bg-[#39ff14]/10 text-[#39ff14] shadow-[0_0_20px_rgba(57,255,20,0.3)] w-40 text-center animate-pulse">
                                        MODO RALLY
                                    </div>
                                )}
                            </div>
                        </div>
                    )}
                    {(activeButton === 'PRACTICE' || activeButton === 'ANALOG' || activeButton === 'DIGITAL') && (
                        <div className="absolute right-8 bottom-36 z-[90] pointer-events-auto flex flex-col items-center">
                            <div className="bg-[#0f172a]/95 backdrop-blur-xl border-2 border-gray-700 rounded-[2rem] p-3 shadow-[0_0_60px_rgba(0,0,0,0.8)] flex flex-col gap-3 w-[100px] relative">
                                {activeButton === 'DIGITAL' && (
                                    <>
                                        <div className="w-full bg-black/60 rounded-xl p-1.5 border border-gray-800 flex justify-between items-center shadow-inner relative overflow-hidden relative z-30">
                                            <button onClick={() => setSelectedCarId(prev => Math.max(1, prev - 1))} className="w-6 h-8 flex items-center justify-center bg-gray-800 rounded-lg text-gray-400"><ArrowLeft size={10}/></button>
                                            <div className="flex flex-col items-center leading-none z-10"><span className="text-[6px] text-gray-500 font-bold">ID</span><span className="text-xl font-black text-[#39ff14] font-digital">{selectedCarId}</span></div>
                                            <button onClick={() => setSelectedCarId(prev => Math.min(numCars, prev + 1))} className="w-6 h-8 flex items-center justify-center bg-gray-800 rounded-lg text-gray-400"><ArrowRight size={10}/></button>
                                        </div>
                                        <div className="grid grid-cols-1 gap-1.5 w-full relative z-30">
                                            <button 
                                                onPointerDown={(e) => { e.preventDefault(); setLaneChangePressed(true); }} 
                                                onPointerUp={(e) => { e.preventDefault(); setLaneChangePressed(false); }} 
                                                onPointerLeave={() => setLaneChangePressed(false)}
                                                onContextMenu={(e) => e.preventDefault()}
                                                className={`h-12 w-full rounded-xl flex items-center justify-center gap-2 border transition-all active:scale-95 touch-none select-none ${laneChangePressed?'bg-[#39ff14] text-black border-white shadow-[0_0_15px_#39ff14]':'bg-gray-800 text-gray-300 border-gray-600'}`}
                                            >
                                                <GitCommit size={20} className="rotate-90"/><span className="font-black text-[10px]">LC</span>
                                            </button>
                                            <button 
                                                onPointerDown={(e) => { e.preventDefault(); setPitPressed(true); }} 
                                                onPointerUp={(e) => { e.preventDefault(); setPitPressed(false); }}
                                                onPointerLeave={() => setPitPressed(false)}
                                                onContextMenu={(e) => e.preventDefault()}
                                                className={`h-10 w-full rounded-xl flex items-center justify-center gap-2 border transition-all active:scale-95 touch-none select-none ${pitPressed?'bg-blue-600 text-white shadow-[0_0_15px_blue]':'bg-gray-800 text-gray-400 border-gray-600'}`}
                                            >
                                                <Fuel size={16}/><span className="font-bold text-[9px]">BOX</span>
                                            </button>
                                        </div>
                                    </>
                                )}
                                <div className="relative w-full h-[240px] bg-black/50 rounded-xl overflow-hidden border border-gray-800 z-10">
                                    <div className="absolute bottom-0 left-0 w-full" style={{ height: `${manualThrottle}%`, background: `linear-gradient(to top, ${manualThrottle>90?'#ef4444':'#39ff14'} 0%, transparent 100%)`, boxShadow: `0 0 20px ${manualThrottle>90?'#ef4444':'#39ff14'}` }}></div>
                                    <input type="range" min="0" max="100" value={manualThrottle} onChange={(e)=>setManualThrottle(parseFloat(e.target.value))} className="absolute -bottom-[85px] -left-[90px] w-[280px] h-[240px] opacity-0 cursor-pointer z-20" style={{ transform: 'rotate(-90deg)', transformOrigin: '50% 50%' }}/>
                                    <div className="absolute top-2 left-0 w-full text-center pointer-events-none"><span className="font-digital text-xl font-black">{Math.round(manualThrottle)}</span><span className="text-[6px] block text-gray-500 font-bold uppercase">GAS</span></div>
                                </div>
                                {activeButton === 'DIGITAL' && (
                                    <button onClick={() => setAutoLaneChange(!autoLaneChange)} className={`w-full py-1.5 rounded-lg text-[8px] font-bold transition-all border relative z-30 ${autoLaneChange?'bg-purple-900/40 border-purple-500 text-purple-300':'bg-transparent border-transparent text-gray-600'}`}>{autoLaneChange ? 'AI ASIST' : 'MANUAL'}</button>
                                )}
                            </div>
                        </div>
                    )}
                    {activeButton === 'GRID' && (
                        <div className="absolute top-60 left-1/2 transform -translate-x-1/2 scale-[0.85] origin-top z-[60] flex flex-col items-center gap-4 pointer-events-auto bg-black/40 p-6 rounded-3xl border border-white/5 backdrop-blur-md shadow-2xl">
                            <div className="flex gap-4 items-start">
                                <MotorShowcase selectedCarId={selectedCarId} currentConfig={carSetups[selectedCarId]} onUpdate={handleUpdateConfig} />
                                <TireShowcase selectedCarId={selectedCarId} currentConfig={carSetups[selectedCarId]} onUpdate={handleUpdateConfig} />
                                <div className="flex flex-col gap-4"><GearShowcase selectedCarId={selectedCarId} currentConfig={carSetups[selectedCarId]} onUpdate={handleUpdateConfig} /><PinionShowcase selectedCarId={selectedCarId} currentConfig={carSetups[selectedCarId]} onUpdate={handleUpdateConfig} /></div>
                                <div className="flex flex-col gap-4"><VoltageShowcase voltage={trackVoltage} setVoltage={setTrackVoltage}/><WeightShowcase selectedCarId={selectedCarId} currentConfig={carSetups[selectedCarId]} onUpdate={handleUpdateConfig} /></div>
                            </div>
                        </div>
                    )}
                    {activeButton !== 'ANALOG' && activeButton !== 'DIGITAL' && (
                        <div className="absolute bottom-28 left-6 pointer-events-auto z-[60]"><TelemetryPanel carId={selectedCarId} data={telemetry.find(t => t.id === selectedCarId)} config={carSetups[selectedCarId]} /></div>
                    )}
                    {raceState === 'finished' && winnerId && (
                        <div className="absolute inset-0 z-[200] flex flex-col items-center justify-center bg-black/90 backdrop-blur-xl animate-in p-6 overflow-auto">
                            {activeButton === 'DIGITAL' && sessionResults ? (
                                <div className="w-full max-w-4xl flex flex-col items-center gap-6">
                                    <div className="text-center mb-4">
                                        <h1 className="text-5xl font-black italic tracking-tighter text-white uppercase drop-shadow-[0_0_15px_rgba(255,255,255,0.5)]">RESULTADOS GP</h1>
                                        <div className="h-1 w-32 bg-[#39ff14] mx-auto mt-2 rounded-full shadow-[0_0_10px_#39ff14]"></div>
                                    </div>
                                    <div className="flex items-end justify-center gap-4 mb-4 w-full h-64">
                                        {telemetry.find(t => t.position === 2) && (() => {
                                            const p2 = telemetry.find(t => t.position === 2);
                                            const s2 = carSetups[p2.id];
                                            return (
                                                <div className="flex flex-col items-center w-1/3 animate-in slide-in-bottom duration-700 delay-100">
                                                    <div className="mb-2 text-center">
                                                        <span className="text-2xl font-bold text-gray-400 block uppercase tracking-wider">{s2.name}</span>
                                                        <span className="text-xs text-gray-500 font-mono">MEJOR: {formatRaceTime(p2.bestLap)}</span>
                                                    </div>
                                                    <div className="w-full bg-gradient-to-t from-gray-800 to-gray-700 h-32 rounded-t-xl border-t-4 border-l-2 border-r-2 border-gray-500 relative flex flex-col justify-end items-center pb-4 shadow-[0_0_30px_rgba(0,0,0,0.5)]">
                                                        <div className="text-6xl font-black text-gray-400/20 absolute top-2">2</div>
                                                        <Trophy size={40} className="text-gray-300 mb-2 drop-shadow-lg" />
                                                        <div className="w-16 h-1 rounded-full" style={{backgroundColor: s2.color}}></div>
                                                    </div>
                                                </div>
                                            )
                                        })()}
                                        {telemetry.find(t => t.position === 1) && (() => {
                                            const p1 = telemetry.find(t => t.position === 1);
                                            const s1 = carSetups[p1.id];
                                            return (
                                                <div className="flex flex-col items-center w-1/3 z-10 animate-in slide-in-bottom duration-700">
                                                    <div className="mb-2 text-center">
                                                        <Zap size={32} className="text-[#39ff14] mx-auto mb-1 animate-bounce" />
                                                        <span className="text-4xl font-black text-white block uppercase tracking-tighter drop-shadow-[0_0_10px_rgba(255,255,255,0.8)]">{s1.name}</span>
                                                        <span className="text-sm text-[#39ff14] font-bold font-mono bg-[#39ff14]/10 px-2 rounded border border-[#39ff14]/30">MEJOR: {formatRaceTime(p1.bestLap)}</span>
                                                    </div>
                                                    <div className="w-full bg-gradient-to-t from-yellow-900/40 to-yellow-600 h-48 rounded-t-xl border-t-4 border-l-2 border-r-2 border-yellow-400 relative flex flex-col justify-end items-center pb-6 shadow-[0_0_50px_rgba(234,179,8,0.4)]">
                                                        <div className="text-8xl font-black text-yellow-300/20 absolute top-2">1</div>
                                                        <Trophy size={64} className="text-yellow-400 mb-2 drop-shadow-[0_0_15px_rgba(250,204,21,0.8)]" />
                                                        <div className="w-20 h-1.5 rounded-full shadow-[0_0_10px_white]" style={{backgroundColor: s1.color}}></div>
                                                    </div>
                                                </div>
                                            )
                                        })()}
                                        {telemetry.find(t => t.position === 3) && (() => {
                                            const p3 = telemetry.find(t => t.position === 3);
                                            const s3 = carSetups[p3.id];
                                            return (
                                                <div className="flex flex-col items-center w-1/3 animate-in slide-in-bottom duration-700 delay-200">
                                                    <div className="mb-2 text-center">
                                                        <span className="text-xl font-bold text-amber-700 block uppercase tracking-wider">{s3.name}</span>
                                                        <span className="text-xs text-gray-500 font-mono">MEJOR: {formatRaceTime(p3.bestLap)}</span>
                                                    </div>
                                                    <div className="w-full bg-gradient-to-t from-orange-900/40 to-orange-800 h-24 rounded-t-xl border-t-4 border-l-2 border-r-2 border-orange-700 relative flex flex-col justify-end items-center pb-4 shadow-[0_0_30px_rgba(0,0,0,0.5)]">
                                                        <div className="text-5xl font-black text-orange-500/20 absolute top-2">3</div>
                                                        <Trophy size={32} className="text-orange-600 mb-2 drop-shadow-lg" />
                                                        <div className="w-16 h-1 rounded-full" style={{backgroundColor: s3.color}}></div>
                                                    </div>
                                                </div>
                                            )
                                        })()}
                                    </div>
                                    <div className="mt-4 flex gap-4">
                                        <button onClick={enterGridMode} className="px-10 py-4 bg-[#39ff14] text-black font-black text-lg rounded-full shadow-[0_0_30px_rgba(57,255,20,0.6)] hover:bg-white hover:scale-105 transition-all uppercase tracking-widest flex items-center gap-2">
                                            <Repeat size={24}/> NUEVA CARRERA
                                        </button>
                                        <button onClick={() => setRaceState('grid')} className="px-8 py-4 bg-gray-800 text-white font-bold text-lg rounded-full border-2 border-gray-600 hover:bg-gray-700 hover:border-white transition-all uppercase tracking-widest">
                                            SALIR
                                        </button>
                                    </div>
                                </div>
                            ) : (activeButton === 'GRID' || activeButton === 'ANALOG') && sessionResults ? (
                                <div className="w-full max-w-5xl flex flex-col items-center">
                                    <div id="engineering-report" className="w-full bg-[#0a0a0a] p-8 rounded-2xl border border-gray-800 shadow-2xl relative">
                                        <div className="flex items-center gap-4 mb-6 border-b border-gray-800 pb-4">
                                            <Settings size={48} className="text-[#39ff14]" />
                                            <div className="flex flex-col">
                                                <h1 className="text-4xl font-black italic tracking-tighter text-white uppercase">ANÁLISIS DE CARRERA</h1>
                                                <span className="text-[#39ff14] font-mono text-sm">INFORME DE INGENIERÍA - SESIÓN {new Date().toLocaleTimeString()}</span>
                                            </div>
                                        </div>
                                        <div className="mb-6"><LapTimeChart results={sessionResults} carSetups={carSetups} /></div>
                                        <div className="flex gap-4 w-full justify-center flex-wrap">
                                            {[1, 2].map(cId => {
                                                const data = sessionResults[cId]; if (!data || data.length === 0) return null;
                                                const bestLap = [...data].sort((a,b) => a.time - b.time)[0];
                                                return (
                                                    <div key={cId} className="flex-1 min-w-[350px] bg-[#0f172a] border border-gray-700 rounded-xl overflow-hidden shadow-2xl">
                                                        <div className="bg-gray-900 px-4 py-3 border-b border-gray-700 flex justify-between items-center">
                                                            <div className="flex items-center gap-2">
                                                                <div className="w-3 h-3 rounded-full" style={{backgroundColor: carSetups[cId]?.color}}></div>
                                                                <span className="font-bold text-white uppercase">{carSetups[cId]?.name}</span>
                                                            </div>
                                                            <span className="text-[10px] bg-[#39ff14]/10 text-[#39ff14] border border-[#39ff14]/30 px-2 py-0.5 rounded font-mono">MEJOR: {formatRaceTime(bestLap?.time)} (V{bestLap?.lap})</span>
                                                        </div>
                                                        <div className="overflow-x-auto">
                                                            <table className="w-full text-left border-collapse">
                                                                <thead>
                                                                    <tr className="bg-black/40 text-[9px] text-gray-400 uppercase tracking-wider">
                                                                        <th className="px-3 py-2 font-bold">#</th><th className="px-3 py-2 font-bold">TIEMPO</th><th className="px-3 py-2 font-bold">MOTOR</th><th className="px-3 py-2 font-bold">GOMAS</th><th className="px-3 py-2 font-bold">REL.</th><th className="px-3 py-2 font-bold">VOLT</th>
                                                                    </tr>
                                                                </thead>
                                                                <tbody className="divide-y divide-gray-800 text-[10px] font-mono text-gray-300">
                                                                    {data.map((lap, idx) => {
                                                                        const isBest = lap.time === bestLap.time;
                                                                        return (
                                                                            <tr key={idx} className={`${isBest ? 'bg-[#39ff14]/10 text-white' : 'hover:bg-white/5'}`}>
                                                                                <td className="px-3 py-1.5 font-bold text-gray-500">{lap.lap}</td>
                                                                                <td className={`px-3 py-1.5 font-bold ${isBest ? 'text-[#39ff14]' : ''}`}>{formatRaceTime(lap.time)}</td>
                                                                                <td className="px-3 py-1.5 truncate max-w-[80px]" title={lap.motor}>{lap.motor}</td>
                                                                                <td className="px-3 py-1.5 truncate max-w-[60px]" title={lap.tire}>{lap.tire}</td>
                                                                                <td className="px-3 py-1.5">{lap.gear}</td>
                                                                                <td className="px-3 py-1.5">{lap.voltage.toFixed(1)}v</td>
                                                                            </tr>
                                                                        );
                                                                    })}
                                                                </tbody>
                                                            </table>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                    <div className="mt-8 flex gap-4">
                                        <button onClick={activeButton === 'ANALOG' ? handleAnalogMode : enterGridMode} className="px-8 py-3 bg-[#39ff14] text-black font-black text-sm rounded-full shadow-[0_0_20px_rgba(57,255,20,0.5)] hover:bg-white transition-all uppercase tracking-widest flex items-center gap-2"><Repeat size={16}/> NUEVA SESIÓN</button>
                                        <button onClick={exportToPDF} disabled={isGeneratingPDF} className="px-8 py-3 bg-blue-600 text-white font-bold text-sm rounded-full shadow-[0_0_20px_rgba(37,99,235,0.5)] hover:bg-blue-500 transition-all uppercase tracking-widest flex items-center gap-2 disabled:opacity-50 disabled:cursor-wait">
                                            {isGeneratingPDF ? <span className="animate-spin">⏳</span> : <FileText size={16}/>} {isGeneratingPDF ? 'GENERANDO...' : 'GUARDAR PDF'}
                                        </button>
                                        <button onClick={() => setRaceState('grid')} className="px-8 py-3 bg-gray-800 text-white font-bold text-sm rounded-full border border-gray-600 hover:bg-gray-700 transition-all uppercase tracking-widest">CERRAR</button>
                                    </div>
                                </div>
                            ) : (
                                <>
                                    <h1 className="text-6xl md:text-8xl font-black italic tracking-tighter text-transparent bg-clip-text bg-gradient-to-br from-white via-gray-200 to-gray-500 mb-4">¡GANADOR!</h1>
                                    <div className={`p-8 rounded-3xl border-4 shadow-[0_0_100px_currentColor] animate-bounce ${winnerId === 1 ? 'bg-red-900/50 border-red-500 text-red-500' : 'bg-blue-900/50 border-blue-500 text-blue-500'}`}>
                                        <h2 className="text-4xl font-bold flex items-center gap-4"><span className="text-6xl">🏆</span> {carSetups[winnerId]?.name}</h2>
                                    </div>
                                    <button onClick={resetPractice} className="mt-10 px-8 py-4 bg-white text-black font-black text-xl rounded-full shadow-[0_0_30px_white]">CONTINUAR</button>
                                </>
                            )}
                        </div>
                    )}
                    <div className="absolute bottom-12 left-6 pointer-events-auto z-[70] flex items-center gap-4">
                        <button onClick={onClose} className="flex items-center gap-2 bg-red-600/90 hover:bg-red-500 text-white border border-red-400 px-6 py-3 rounded-full font-bold text-sm h-12 transition shadow-lg"><X size={20}/> VOLVER</button>
                        <div className="flex gap-6 items-center bg-black/80 px-6 py-2 rounded-full border border-white/10 backdrop-blur-xl shadow-[0_0_30px_rgba(0,0,0,0.5)] h-12">
                            <div className="flex items-center gap-2">
                                <div className="flex flex-col items-end mr-1"><span className="text-[8px] text-gray-500 font-bold uppercase leading-none">TOTAL</span><span className="text-[8px] text-[#39ff14] font-bold uppercase leading-none">VUELTAS</span></div>
                                <button onClick={() => setTargetLaps(Math.max(1, targetLaps - 1))} className="w-6 h-6 flex items-center justify-center rounded-full bg-gray-900 border border-gray-600 transition-all"><Minus size={10} /></button>
                                <div className="bg-black border border-[#39ff14]/30 rounded px-2 w-10 text-center"><span className="font-digital text-lg text-[#39ff14]">{targetLaps}</span></div>
                                <button onClick={() => setTargetLaps(targetLaps + 1)} className="w-6 h-6 flex items-center justify-center rounded-full bg-gray-900 border border-gray-600 transition-all"><Plus size={10} /></button>
                            </div>
                            <div className="w-px h-6 bg-white/20"></div>
                            <div className="flex gap-2">
                                <button onClick={() => { if (raceState === 'grid') startRaceSequence(); else setPaused(false); }} className="px-5 py-1.5 rounded-full font-black text-[10px] tracking-widest border border-[#39ff14] bg-[#39ff14]/10 text-[#39ff14] hover:bg-[#39ff14] hover:text-black transition-all flex items-center gap-2"><Play size={12} fill="currentColor"/> EMPEZAR</button>
                                <button onClick={togglePause} className="px-5 py-1.5 rounded-full font-black text-[10px] tracking-widest border border-yellow-500 bg-yellow-500/10 text-yellow-500 hover:bg-yellow-500 hover:text-black transition-all flex items-center gap-2"><Pause size={12} fill="currentColor"/> {paused ? "REANUDAR" : "PAUSA"}</button>
                            </div>
                            <div className="w-px h-6 bg-white/20"></div>
                            <div className="flex items-center gap-2">
                                <div className="flex flex-col items-end mr-1"><span className="text-[8px] text-gray-500 font-bold uppercase leading-none">TOTAL</span><span className="text-[8px] text-[#39ff14] font-bold uppercase leading-none">PILOTOS</span></div>
                                <button onClick={() => setNumCars(Math.max(1, numCars - 1))} className="w-6 h-6 flex items-center justify-center rounded-full bg-gray-900 border border-gray-600 transition-all"><Minus size={10} /></button>
                                <div className="bg-black border border-[#39ff14]/30 rounded px-2 w-10 text-center"><span className="font-digital text-lg text-[#39ff14]">{numCars}</span></div>
                                <button onClick={() => setNumCars(Math.min(8, numCars + 1))} className="w-6 h-6 flex items-center justify-center rounded-full bg-gray-900 border border-gray-600 transition-all"><Plus size={10} /></button>
                            </div>
                            <div className="w-px h-6 bg-white/20"></div>
                            <button onClick={enterGridMode} className="px-4 py-1.5 rounded-full font-black text-[10px] bg-gray-800 text-gray-400 hover:text-white transition-all">MENU</button>
                        </div>
                    </div>
                </div> 
            );
        };
        
        function Slot3DPlayer() {
          const [circuitData, setCircuitData] = useState(null);
          const [carSettings, setCarSettings] = useState(Array(8).fill(null).map((_, i) => ({ id: i + 1, name: `PILOTO ${i + 1}`, color: ['#ef4444', '#3b82f6', '#22c55e', '#eab308', '#a855f7', '#ec4899', '#f97316', '#64748b'][i % 8] })));
          const [customCarAssets] = useState(Object.fromEntries(Array.from({length: 8}, (_, i) => [i + 1, { obj: null, rotation: [0, 180, 0], yOffset: 0 }])));

          useEffect(() => { const ls = document.getElementById('loading-screen'); if (ls) { ls.style.opacity = '0'; setTimeout(() => ls.style.display = 'none', 1000); } }, []);

          const loadCircuit = (e) => { 
            const f = e.target.files[0]; if (!f) return; 
            const r = new FileReader(); 
            r.onload = (ev) => { 
                try { 
                    const d = JSON.parse(ev.target.result); 
                    if (d.brand && d.pieces) { 
                        setCircuitData({ brand: d.brand, pieces: d.pieces }); 
                    } else {
                        alert("Formato de circuito inválido");
                    }
                } catch (err) { alert("Error al leer JSON"); } 
            }; 
            r.readAsText(f); 
          };

          if (circuitData) {
            return (
                <Telemetry3DViewer 
                    circuitData={circuitData} 
                    carSettings={carSettings} 
                    customCarAssets={customCarAssets} 
                    onClose={() => setCircuitData(null)} 
                />
            );
          }

          return (
            <div className="flex flex-col h-[100dvh] w-full bg-[#0a0a0a] overflow-hidden font-sans select-none text-gray-200 justify-center items-center relative">
                {/* LOBBY SCREEN */}
                <div className="absolute inset-0 opacity-20 pointer-events-none" style={{backgroundImage: 'radial-gradient(#39ff14 1px, transparent 1px)', backgroundSize: '40px 40px'}}></div>
                <div className="z-10 flex flex-col items-center gap-8 animate-in">
                    <div className="text-center">
                        <Activity size={80} className="text-[#39ff14] mx-auto mb-4 animate-pulse drop-shadow-[0_0_30px_rgba(57,255,20,0.6)]"/>
                        <h1 className="text-5xl md:text-7xl font-black italic tracking-tighter text-white uppercase drop-shadow-xl">TRACKS & TELEMETRY</h1>
                        <p className="text-[#39ff14] font-mono text-xl tracking-[0.5em] mt-2 font-bold">3D PLAYER</p>
                    </div>

                    <div className="bg-black/50 p-10 rounded-3xl border border-white/10 backdrop-blur-xl shadow-2xl flex flex-col items-center gap-6 w-full max-w-lg">
                        <div className="text-center space-y-2">
                            <h2 className="text-2xl font-bold text-white">CARGAR CIRCUITO</h2>
                            <p className="text-gray-400 text-sm">Selecciona el archivo .JSON generado en el diseñador</p>
                        </div>
                        
                        <label className="group relative cursor-pointer block">
                            <div className="absolute -inset-1 bg-gradient-to-r from-[#39ff14] to-cyan-500 rounded-xl blur opacity-25 group-hover:opacity-75 transition duration-1000 group-hover:duration-200"></div>
                            <div className="relative px-8 py-6 bg-gray-900 ring-1 ring-gray-900/5 rounded-xl leading-none flex items-center justify-center space-x-6">
                                <CloudUpload className="w-8 h-8 text-cyan-400 group-hover:text-[#39ff14] transition-colors" />
                                <span className="text-gray-300 group-hover:text-white transition-colors font-bold uppercase tracking-wider">SELECCIONAR ARCHIVO</span>
                            </div>
                            <input type="file" accept=".json" onChange={loadCircuit} className="hidden" />
                        </label>
                    </div>

                    <div className="text-[10px] text-gray-600 font-mono absolute bottom-4">V.2.0 PLAYER - POWERED BY REACT & THREE.JS</div>
                </div>
            </div>
          );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<Slot3DPlayer />);
    </script>
</body>
</html>