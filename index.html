<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Diseñador de Circuitos Slot</title>
    
    <!-- METADATOS PARA PANTALLA COMPLETA EN MÓVILES -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0a0a0a">
    
    <!-- LIBRERÍAS EXTERNAS (CDN BLINDADO - CLOUDFLARE) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React Core (Fijado v18.2.0) -->
    <script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <!-- React DOM (Fijado v18.2.0) -->
    <script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <!-- Babel Standalone (Fijado v7.23.5 - Estable) -->
    <script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.263.1/dist/umd/lucide.min.js"></script>
    
    <!-- FUENTE DIGITAL -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <!-- THREE.JS Y LOADERS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <!-- NUEVAS LIBRERÍAS PARA EL VISOR HOMO (GLB + CONTROLES) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        /* ESTILOS GLOBALES */
        script { display: none !important; }
        body { background-color: #0a0a0a; color: white; margin: 0; overflow: hidden; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; user-select: none; touch-action: none; }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .animate-in { animation: fadeIn 0.5s ease-out forwards; }
        
        /* PANTALLA DE CARGA */
        #loading-screen { position: fixed; inset: 0; background: radial-gradient(circle at center, #1e293b 0%, #020617 100%); color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 9999; text-align: center; padding: 20px; transition: opacity 0.8s ease-out; }
        .loader-title { font-size: 3rem; font-weight: 900; color: #39ff14; text-transform: uppercase; letter-spacing: -2px; margin-bottom: 2rem; text-shadow: 0 0 15px rgba(57, 255, 20, 0.8); animation: pulse-neon 2s infinite alternate; }
        .loader-bar-bg { width: 300px; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; position: relative; margin-bottom: 1rem; }
        .loader-bar-fill { position: absolute; top: 0; left: 0; bottom: 0; width: 40%; background: #39ff14; box-shadow: 0 0 10px #39ff14; animation: load-scan 1s linear infinite; }
        .loader-subtitle { font-size: 0.8rem; color: #94a3b8; letter-spacing: 2px; font-weight: bold; }
        @keyframes pulse-neon { 0% { text-shadow: 0 0 15px rgba(57, 255, 20, 0.8); opacity: 0.9; transform: scale(1); } 100% { text-shadow: 0 0 30px rgba(57, 255, 20, 1); opacity: 1; transform: scale(1.02); } }
        @keyframes load-scan { 0% { left: -40%; } 100% { left: 100%; } }
        
        /* Animación botón */
        @keyframes shimmer-slide { 0% { transform: translateX(-150%) skewX(-20deg); } 100% { transform: translateX(250%) skewX(-20deg); } }
        .btn-spectacular-shimmer::after {
            content: ''; position: absolute; top: 0; left: 0; width: 50%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(57, 255, 20, 0.6), transparent);
            transform: translateX(-150%) skewX(-20deg);
            animation: shimmer-slide 3s infinite cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* UI HELPERS */
        #error-msg { color: #ef4444; margin-top: 20px; max-width: 600px; display: none; border: 1px solid #ef4444; padding: 10px; border-radius: 8px; background: rgba(0,0,0,0.8); }
        .cursor-grab { cursor: grab; } .cursor-grabbing { cursor: grabbing; } .cursor-crosshair { cursor: crosshair; }
        
        .font-digital { 
            font-family: 'Share Tech Mono', monospace; 
            font-variant-numeric: tabular-nums; 
            letter-spacing: 1px;
        }
        
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 12px; width: 12px; border-radius: 50%; background: #39ff14; cursor: pointer; margin-top: -4px; box-shadow: 0 0 5px rgba(57,255,20,0.8); }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: rgba(255,255,255,0.2); border-radius: 2px; }
    </style>
</head>
<body>
    <div id="loading-screen">
        <h1 class="loader-title">TRACKS & TELEMETRY</h1>
        <div class="loader-bar-bg"><div class="loader-bar-fill"></div></div>
        <div class="loader-subtitle">INICIALIZANDO SISTEMAS...</div>
        <div id="error-msg"></div>
    </div>
    <div id="root"></div>
    
    <script>
        window.onerror = function(msg, url, line, col, error) {
            const ls = document.getElementById('loading-screen'); 
            const ed = document.getElementById('error-msg');
            if(ls && ed) { 
                ls.style.zIndex="10000"; ls.style.display="flex"; ls.style.opacity="1"; 
                ed.style.display="block"; 
                ed.innerHTML=`<strong>Error Detectado:</strong><br>${msg}<br><small>Línea: ${line}</small>`; 
            }
            return false;
        };
    </script>

    <script type="text/babel" data-presets="react,env">
        // :: MODO DE EDICIÓN RÁPIDA ACTIVADO :: 
        // Las líneas 1-3, Telemetry3DViewer y definiciones masivas están ocultas.
        // Solo se mostrarán los cambios.
        const { useState, useEffect, useRef } = React;

        class ErrorBoundary extends React.Component {
            constructor(props) { super(props); this.state = { hasError: false }; }
            static getDerivedStateFromError(error) { return { hasError: true }; }
            componentDidCatch(error, errorInfo) { console.error("System Crash:", error, errorInfo); }
            render() { if (this.state.hasError) return this.props.fallback || null; return this.props.children; }
        }

        const TRACK_DEFINITIONS = {
          NINCO: { name: 'NINCO', themeColor: 'red', neonColor: '#ef4444', uiClass: 'border-red-500/50 text-red-400 shadow-[0_0_15px_rgba(239,68,68,0.3)] hover:bg-red-950/30', activeClass: 'bg-red-600 text-white shadow-[0_0_20px_rgba(239,68,68,0.6)] border-red-500', trackColor: '#111111', railColor: '#dcdcdc', slotColor: '#000000', width: 18.0, laneSpacing: 9.0, connectionBoxColor: '#ef4444',
            pieces: [ { id: 'n_40', label: 'Recta 40cm', type: 'straight', length: 40.0, cat: 'Rectas' }, { id: 'n_20', label: 'Media 20cm', type: 'straight', length: 20.0, cat: 'Rectas' }, 
              { id: 'n_sl_1', label: 'Recta 1C (40)', type: 'straight', length: 40.0, subtype: 'single_lane_1', cat: 'RALLY' }, { id: 'n_sl_2', label: 'Recta 2C (40)', type: 'straight', length: 40.0, subtype: 'single_lane_2', cat: 'RALLY' },
              { id: 'n_grid', label: 'Media Parrilla', type: 'straight', length: 20.0, subtype: 'starting_grid', cat: 'Rectas' }, { id: 'n_10', label: 'Cuarto 10cm', type: 'straight', length: 10.0, cat: 'Rectas' }, { id: 'n_05', label: 'Cierre 5cm', type: 'straight', length: 5.0, cat: 'Rectas' }, { id: 'n_connect', label: 'Conexiones', type: 'straight', length: 40.0, subtype: 'analog_connect', cat: 'Rectas' }, { id: 'n_cross', label: 'Cruce 40cm', type: 'straight', length: 40.0, subtype: 'crossing', cat: 'Rectas' }, { id: 'n_r1', label: 'R1 (Int)', type: 'curve', radius: 20.0, angle: 45, cat: 'Curvas' }, { id: 'n_r1_22', label: 'R1 (22.5°)', type: 'curve', radius: 20.0, angle: 22.5, cat: 'Curvas' }, { id: 'n_r2', label: 'R2 (Std)', type: 'curve', radius: 38.0, angle: 45, cat: 'Curvas' }, { id: 'n_r2_22', label: 'R2 (22.5°)', type: 'curve', radius: 38.0, angle: 22.5, cat: 'Curvas' }, { id: 'n_r3', label: 'R3 (Ext)', type: 'curve', radius: 56.0, angle: 22.5, cat: 'Curvas' }, { id: 'n_r4', label: 'R4 (Super)', type: 'curve', radius: 74.0, angle: 22.5, cat: 'Curvas' }, { id: 'n_r5', label: 'R5 (Ultra)', type: 'curve', radius: 92.0, angle: 22.5, cat: 'Curvas' }, { id: 'n_rotonda', label: 'Rotonda + Recta 10', type: 'curve', radius: 14.5, angle: 180, subtype: 'rotonda', cat: 'RALLY' }, { id: 'n_console', label: 'Centralita', type: 'straight', length: 20.0, subtype: 'digital_console', cat: 'Digital' }, { id: 'n_x', label: 'Cambio X', type: 'straight', length: 40.0, subtype: 'digital_x', cat: 'Digital' }, { id: 'n_ch_r', label: 'Cambio Der', type: 'straight', length: 40.0, subtype: 'change_right', cat: 'Digital' }, { id: 'n_ch_l', label: 'Cambio Izq', type: 'straight', length: 40.0, subtype: 'change_left', cat: 'Digital' }, { id: 'n_pit_in', label: 'Entrada Pit', type: 'pit_entry', length: 40.0, cat: 'Boxes' }, { id: 'n_pit_fuel', label: 'Zona Fuel', type: 'straight', length: 40.0, subtype: 'pit_parallel', cat: 'Boxes' }, { id: 'n_pit_box_x', label: 'Boxes + Cambio X', type: 'straight', length: 40.0, subtype: 'pit_parallel_double_x', cat: 'Boxes' }, { id: 'n_pit_straight', label: 'Recta Pit', type: 'straight', length: 40.0, subtype: 'pit_parallel_black', cat: 'Boxes' }, { id: 'n_pit_out', label: 'Salida Pit', type: 'pit_exit', length: 40.0, cat: 'Boxes' } ] },
          SCX_ANALOG: { name: 'SCALEXTRIC', themeColor: 'yellow', neonColor: '#facc15', uiClass: 'border-yellow-500/50 text-yellow-400 shadow-[0_0_15px_rgba(250,204,21,0.3)] hover:bg-yellow-950/30', activeClass: 'bg-yellow-500 text-black shadow-[0_0_20px_rgba(250,204,21,0.6)] border-yellow-400 font-bold', trackColor: '#5a5a5a', railColor: '#d0d0d0', slotColor: '#1a1a1a', width: 15.6, laneSpacing: 7.7, connectionBoxColor: '#ef4444', 
            pieces: [ { id: 's_360', label: 'Recta 360', type: 'straight', length: 36.0, cat: 'Rectas' }, { id: 's_180', label: 'Media 180', type: 'straight', length: 18.0, cat: 'Rectas' },
              { id: 's_sl_1', label: 'Recta 1C (360)', type: 'straight', length: 36.0, subtype: 'single_lane_1', cat: 'RALLY' }, { id: 's_sl_2', label: 'Recta 2C (360)', type: 'straight', length: 36.0, subtype: 'single_lane_2', cat: 'RALLY' },
              { id: 's_grid', label: 'Media Parrilla', type: 'straight', length: 18.0, subtype: 'starting_grid', cat: 'Rectas' }, { id: 's_90', label: 'Cierre 90', type: 'straight', length: 9.0, cat: 'Rectas' }, { id: 's_connect', label: 'Conexión', type: 'straight', length: 36.0, subtype: 'analog_connect', cat: 'Rectas' }, { id: 's_cross', label: 'Recta Cruce', type: 'straight', length: 36.0, subtype: 'crossing', cat: 'Rectas' }, { id: 's_chicane_in', label: 'Entrada Chicane', type: 'straight', length: 36.0, subtype: 'chicane_entry', cat: 'Rectas' }, { id: 's_chicane_mid', label: 'Recta Chicane', type: 'straight', length: 36.0, subtype: 'chicane_middle', cat: 'Rectas' }, { id: 's_chicane_out', label: 'Salida Chicane', type: 'straight', length: 36.0, subtype: 'chicane_exit', cat: 'Rectas' }, { id: 's_r1', label: 'R1 (Int)', type: 'curve', radius: 15.0, angle: 45, cat: 'Curvas' }, { id: 's_r2', label: 'R2 (Std)', type: 'curve', radius: 30.6, angle: 45, cat: 'Curvas' }, { id: 's_r2_ice', label: 'R2 (Hielo)', type: 'curve', radius: 30.6, angle: 45, subtype: 'ice', cat: 'Curvas' }, { id: 's_r3', label: 'R3 (Ext)', type: 'curve', radius: 46.2, angle: 22.5, cat: 'Curvas' }, { id: 's_r4', label: 'R4 (Super)', type: 'curve', radius: 61.8, angle: 22.5, cat: 'Curvas' }, { id: 's_rotonda_10', label: 'Rotonda + Recta 10', type: 'curve', radius: 15.0, angle: 180, subtype: 'rotonda', cat: 'RALLY' } ] },
          SCX_ADVANCE: { name: 'SCX ADVANCE', themeColor: 'blue', neonColor: '#3b82f6', uiClass: 'border-blue-500/50 text-blue-400 shadow-[0_0_15px_rgba(59,130,246,0.3)] hover:bg-blue-950/30', activeClass: 'bg-blue-600 text-white shadow-[0_0_20px_rgba(59,130,246,0.6)] border-blue-400 font-bold', trackColor: '#5a5a5a', railColor: '#d0d0d0', slotColor: '#1a1a1a', width: 15.6, laneSpacing: 7.7, connectionBoxColor: '#ef4444',
            pieces: [ { id: 'adv_360', label: 'Recta 360', type: 'straight', length: 36.0, cat: 'Rectas' }, { id: 'adv_180', label: 'Media 180', type: 'straight', length: 18.0, cat: 'Rectas' }, 
              { id: 'adv_sl_1', label: 'Recta 1C (360)', type: 'straight', length: 36.0, subtype: 'single_lane_1', cat: 'RALLY' }, { id: 'adv_sl_2', label: 'Recta 2C (360)', type: 'straight', length: 36.0, subtype: 'single_lane_2', cat: 'RALLY' },
              { id: 'adv_grid', label: 'Media Parrilla', type: 'straight', length: 18.0, subtype: 'starting_grid', cat: 'Rectas' }, { id: 'adv_90', label: 'Cierre 90', type: 'straight', length: 9.0, cat: 'Rectas' }, { id: 'adv_connect', label: 'Bluetooth', type: 'straight', length: 36.0, subtype: 'connection', cat: 'Digital' }, { id: 'adv_x', label: 'Cambio Recta', type: 'straight', length: 36.0, subtype: 'digital_x', cat: 'Digital' }, { id: 'adv_cr', label: 'Cambio Curva', type: 'curve', radius: 30.6, angle: 45, subtype: 'change_curve_r', cat: 'Digital' }, { id: 'adv_pit_in', label: 'Entrada Pit', type: 'pit_entry', length: 36.0, cat: 'Boxes' }, { id: 'adv_pit_fuel', label: 'Recta Fuel', type: 'straight', length: 36.0, subtype: 'pit_parallel', cat: 'Boxes' }, { id: 'adv_pit_box_x', label: 'Boxes + Cambio X', type: 'straight', length: 36.0, subtype: 'pit_parallel_double_x', cat: 'Boxes' }, { id: 'adv_pit_straight', label: 'Recta Pit', type: 'straight', length: 36.0, subtype: 'pit_parallel_black', cat: 'Boxes' }, { id: 'adv_pit_out', label: 'Salida Pit', type: 'pit_exit', length: 36.0, cat: 'Boxes' }, { id: 'adv_r1', label: 'R1 (Int)', type: 'curve', radius: 15.0, angle: 45, cat: 'Curvas' }, { id: 'adv_r2', label: 'R2 (Std)', type: 'curve', radius: 30.6, angle: 45, cat: 'Curvas' }, { id: 'adv_r3', label: 'R3 (Ext)', type: 'curve', radius: 46.2, angle: 22.5, cat: 'Curvas' }, { id: 'adv_r4', label: 'R4 (Super)', type: 'curve', radius: 61.8, angle: 22.5, cat: 'Curvas' } ] },
          POLICAR: { name: 'POLICAR', themeColor: 'orange', neonColor: '#f97316', uiClass: 'border-orange-500/50 text-orange-400 shadow-[0_0_15px_rgba(249,115,22,0.3)] hover:bg-orange-950/30', activeClass: 'bg-orange-600 text-white shadow-[0_0_20px_rgba(249,115,22,0.6)] border-orange-500 font-bold', trackColor: '#1a1a1a', railColor: '#dcdcdc', slotColor: '#000000', width: 17.9, laneSpacing: 9.0, connectionBoxColor: '#333',
            pieces: [ { id: 'pol_358', label: 'Recta 358', type: 'straight', length: 35.8, cat: 'Rectas' }, { id: 'pol_179', label: 'Media 179', type: 'straight', length: 17.9, cat: 'Rectas' }, { id: 'pol_grid', label: 'Media Parrilla', type: 'straight', length: 17.9, subtype: 'starting_grid', cat: 'Rectas' }, { id: 'pol_89', label: 'Cuarto 89', type: 'straight', length: 8.9, cat: 'Rectas' }, { id: 'pol_connect', label: 'Conexiones', type: 'straight', length: 35.8, subtype: 'analog_connect', cat: 'Rectas' }, { id: 'pol_cross', label: 'Cruce 358', type: 'straight', length: 35.8, subtype: 'crossing', cat: 'Rectas' }, { id: 'pol_r1', label: 'R1 (45°)', type: 'curve', radius: 17.9, angle: 45, cat: 'Curvas' }, { id: 'pol_r1_22', label: 'R1 (22.5°)', type: 'curve', radius: 17.9, angle: 22.5, cat: 'Curvas' }, { id: 'pol_r2', label: 'R2 (45°)', type: 'curve', radius: 35.8, angle: 45, cat: 'Curvas' }, { id: 'pol_r2_22', label: 'R2 (22.5°)', type: 'curve', radius: 35.8, angle: 22.5, cat: 'Curvas' }, { id: 'pol_r3', label: 'R3 (22.5°)', type: 'curve', radius: 53.7, angle: 22.5, cat: 'Curvas' }, { id: 'pol_r4', label: 'R4 (22.5°)', type: 'curve', radius: 71.6, angle: 22.5, cat: 'Curvas' } ] },
          SCALEAUTO: { name: 'SCALEAUTO', themeColor: 'lime', neonColor: '#84cc16', uiClass: 'border-lime-500/50 text-lime-400 shadow-[0_0_15px_rgba(132,204,22,0.3)] hover:bg-lime-950/30', activeClass: 'bg-lime-500 text-black shadow-[0_0_20px_rgba(132,204,22,0.6)] border-lime-400 font-bold', trackColor: '#4d4d4d', railColor: '#e0e0e0', slotColor: '#111111', width: 20.0, laneSpacing: 10.0, connectionBoxColor: '#9ca3af',
            pieces: [ { id: 'sca_40', label: 'Recta Pro 40', type: 'straight', length: 40.0, cat: 'Rectas' }, { id: 'sca_20', label: 'Media 20', type: 'straight', length: 20.0, cat: 'Rectas' }, { id: 'sca_grid', label: 'Media Parrilla', type: 'straight', length: 20.0, subtype: 'starting_grid', cat: 'Rectas' }, { id: 'sca_10', label: 'Cuarto 10', type: 'straight', length: 10.0, cat: 'Rectas' }, { id: 'sca_connect', label: 'Conexiones', type: 'straight', length: 40.0, subtype: 'analog_connect', cat: 'Rectas' }, { id: 'sca_r1', label: 'R1 (45°)', type: 'curve', radius: 20.0, angle: 45, cat: 'Curvas' }, { id: 'sca_r1_22', label: 'R1 (22.5°)', type: 'curve', radius: 20.0, angle: 22.5, cat: 'Curvas' }, { id: 'sca_r2', label: 'R2 (45°)', type: 'curve', radius: 40.0, angle: 45, cat: 'Curvas' }, { id: 'sca_r2_22', label: 'R2 (22.5°)', type: 'curve', radius: 40.0, angle: 22.5, cat: 'Curvas' }, { id: 'sca_r3', label: 'R3 (22.5°)', type: 'curve', radius: 60.0, angle: 22.5, cat: 'Curvas' }, { id: 'sca_r4', label: 'R4 (22.5°)', type: 'curve', radius: 80.0, angle: 22.5, cat: 'Curvas' } ] }
        };

        const IconWrapper = ({ name, size = 24, className, ...props }) => {
            if (typeof lucide === 'undefined' || !lucide.icons) return null;
            const iconData = lucide.icons[name];
            if (!iconData) return null;
            const [tag, attrs, children = []] = iconData;
            return <svg {...attrs} width={size} height={size} className={className} {...props}>{Array.isArray(children) && children.map(([childTag, childAttrs], index) => React.createElement(childTag, { ...childAttrs, key: index }))}</svg>;
        };
        const icons = ['Trash2','Image','Fuel','Move','Zap','Bluetooth','RotateCw','X','Repeat','PenTool','ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Square','FolderOpen','Save','FileText','Activity','Play','Pause','Flag','GitCommit','ZoomIn','ZoomOut','Crosshair','Undo2','Redo2','Layers','Clock','Hash','Plus','Minus','AlertTriangle', 'Cloud', 'CloudUpload', 'CloudDownload', 'Settings', 'Battery', 'Scale', 'Maximize', 'Minimize', 'User'].reduce((acc, name) => { acc[name] = (p) => <IconWrapper name={name} {...p} />; return acc; }, {});
        const { Trash2, Image: ImageIcon, Fuel, Move, Zap, Bluetooth, RotateCw, X, Repeat, PenTool, ArrowUp, ArrowDown, ArrowLeft, ArrowRight, Square, FolderOpen, Save, FileText, Activity, Play, Pause, Flag, GitCommit, ZoomIn, ZoomOut, Crosshair, Undo2, Redo2, Layers, Clock, Hash, Plus, Minus, AlertTriangle, Cloud, CloudUpload, CloudDownload, Settings, Battery, Scale, Maximize, Minimize, User } = icons;

        const MotorSVG = ({ type, color, label }) => {
            const safeLabel = (label || 'unk_motor').toString();
            const safeId = safeLabel.replace(/[^a-zA-Z0-9-_]/g, '_');
            return (
                <svg viewBox="0 0 100 60" className="w-full h-full drop-shadow-lg filter transition-transform duration-500 hover:scale-105">
                    <defs>
                        <linearGradient id={`motor-body-${safeId}`} x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" stopColor="#e2e8f0" />
                            <stop offset="50%" stopColor="#94a3b8" />
                            <stop offset="100%" stopColor="#64748b" />
                        </linearGradient>
                        <linearGradient id={`label-grad-${safeId}`} x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" stopColor={color || '#666'} />
                            <stop offset="100%" stopColor="#000" stopOpacity="0.5" />
                        </linearGradient>
                        <pattern id="copper-coil" width="4" height="4" patternUnits="userSpaceOnUse">
                            <path d="M0,4 L4,0 M-1,1 L1,-1 M3,5 L5,3" stroke="#b45309" strokeWidth="1" />
                        </pattern>
                    </defs>
                    <rect x="2" y="28" width="12" height="4" fill="#cbd5e1" stroke="#64748b" strokeWidth="0.5" />
                    <path d="M4,26 L8,26 L9,24 L11,24 L12,26 L12,34 L11,36 L9,36 L8,34 L4,34 Z" fill="#fbbf24" stroke="#b45309" strokeWidth="0.5" />
                    {type === 'Long Can' && ( <g> <rect x="14" y="15" width="76" height="30" rx="2" fill={`url(#motor-body-${safeId})`} stroke="#475569" strokeWidth="1" /> <rect x="22" y="18" width="60" height="24" rx="1" fill={`url(#label-grad-${safeId})`} /> <path d="M28,20 L38,20 L38,23 L28,23 Z" fill="url(#copper-coil)" stroke="#000" strokeWidth="0.5" /> <path d="M48,20 L58,20 L58,23 L48,23 Z" fill="url(#copper-coil)" stroke="#000" strokeWidth="0.5" /> <path d="M68,20 L78,20 L78,23 L68,23 Z" fill="url(#copper-coil)" stroke="#000" strokeWidth="0.5" /> <path d="M28,37 L38,37 L38,40 L28,40 Z" fill="#1a1a1a" /> <path d="M48,37 L58,37 L58,40 L48,40 Z" fill="#1a1a1a" /> <path d="M68,37 L78,37 L78,40 L68,40 Z" fill="#1a1a1a" /> </g> )}
                    {type === 'Short Can' && ( <g> <rect x="20" y="12" width="56" height="36" rx="6" fill={`url(#motor-body-${safeId})`} stroke="#475569" strokeWidth="1" /> <ellipse cx="48" cy="30" rx="22" ry="14" fill={`url(#label-grad-${safeId})`} stroke="rgba(255,255,255,0.2)" strokeWidth="1" /> <circle cx="30" cy="30" r="1.5" fill="#1e293b" /> <circle cx="66" cy="30" r="1.5" fill="#1e293b" /> <path d="M25,16 L35,16 L35,18 L25,18 Z" fill="url(#copper-coil)" opacity="0.8"/> <path d="M61,16 L71,16 L71,18 L61,18 Z" fill="url(#copper-coil)" opacity="0.8"/> </g> )}
                    {type === 'Flat' && ( <g> <rect x="14" y="20" width="76" height="20" rx="1" fill={`url(#motor-body-${safeId})`} stroke="#475569" strokeWidth="1" /> <rect x="14" y="18" width="76" height="2" fill="#334155" /> <rect x="14" y="40" width="76" height="2" fill="#334155" /> <rect x="24" y="22" width="56" height="16" rx="2" fill="#111" stroke="#333" strokeWidth="0.5" /> <rect x="26" y="24" width="52" height="12" rx="1" fill="url(#copper-coil)" /> <path d="M20,20 L40,20 L35,40 L20,40 Z" fill={color || '#666'} opacity="0.9" /> </g> )}
                    <text x="50" y="33" fontSize="7" fontWeight="900" fill="white" textAnchor="middle" style={{textShadow: '0 1px 2px black'}} fontFamily="Arial, sans-serif" letterSpacing="0.5px">{safeLabel}</text>
                    <path d="M90,24 L94,24 L94,18 L96,18 L96,26 L90,26 Z" fill="#fbbf24" stroke="#b45309" strokeWidth="0.5" /> <path d="M90,36 L94,36 L94,42 L96,42 L96,34 L90,34 Z" fill="#fbbf24" stroke="#b45309" strokeWidth="0.5" /> <path d="M96,22 C100,22 100,10 100,5" stroke="#ef4444" strokeWidth="1" fill="none" opacity="0.6"/> <path d="M96,38 C100,38 100,50 100,55" stroke="#111" strokeWidth="1" fill="none" opacity="0.6"/>
                </svg>
            );
        };

        const TireSVG = ({ type, rimColor, label, compoundColor }) => {
            const safeLabel = (label || 'unk_tire').toString();
            const safeId = safeLabel.replace(/[^a-zA-Z0-9-_]/g, '_');
            return (
                <svg viewBox="0 0 60 60" className="w-full h-full drop-shadow-lg filter transition-transform duration-500 hover:scale-110">
                    <defs> <radialGradient id={`rim-metal-${safeId}`} cx="50%" cy="50%" r="50%"> <stop offset="0%" stopColor="#e2e8f0" /> <stop offset="100%" stopColor="#64748b" /> </radialGradient> <linearGradient id="tread-shine" x1="0%" y1="0%" x2="100%" y2="0%"> <stop offset="0%" stopColor="#333" /> <stop offset="50%" stopColor="#555" /> <stop offset="100%" stopColor="#333" /> </linearGradient> </defs>
                    <circle cx="30" cy="30" r="28" fill="#1a1a1a" stroke="#000" strokeWidth="0.5" /> <circle cx="30" cy="30" r="25" fill="transparent" stroke={compoundColor || '#fff'} strokeWidth="0.5" opacity="0.8" />
                    {type === 'Lluvia' ? ( <g stroke="#111" strokeWidth="1.5" fill="none" opacity="0.8"> <path d="M14,18 Q30,12 46,18" /> <path d="M10,30 Q30,24 50,30" /> <path d="M14,42 Q30,48 46,42" /> <line x1="30" y1="10" x2="30" y2="50" strokeWidth="1" strokeDasharray="2 1" /> </g> ) : ( <ellipse cx="30" cy="20" rx="15" ry="8" fill="url(#tread-shine)" opacity="0.15" transform="rotate(-15 30 20)" /> )}
                    <circle cx="30" cy="30" r="16" fill={`url(#rim-metal-${safeId})`} stroke="#475569" strokeWidth="1" /> <circle cx="30" cy="30" r="14" fill={rimColor || '#ccc'} opacity="0.2" /> <g stroke="#cbd5e1" strokeWidth="1.5" strokeLinecap="round"> {[0, 45, 90, 135, 180, 225, 270, 315].map(deg => { const rad = deg * Math.PI / 180; return <line key={deg} x1={30 + Math.cos(rad)*5} y1={30 + Math.sin(rad)*5} x2={30 + Math.cos(rad)*14} y2={30 + Math.sin(rad)*14} />; })} </g> <circle cx="30" cy="30" r="2.5" fill="#000" stroke="#64748b" strokeWidth="0.5" /> <path id={`curve-${safeId}`} d="M 12 30 A 18 18 0 0 1 48 30" fill="none"/> <text fontSize="4.5" fontWeight="900" fill={compoundColor || '#fff'} textAnchor="middle" opacity="0.9" letterSpacing="1.5" style={{textShadow: '0 0 2px rgba(0,0,0,0.8)'}}><textPath href={`#curve-${safeId}`} startOffset="50%">{safeLabel}</textPath></text>
                </svg>
            );
        };

        const GearSVG = ({ teeth, color, material }) => {
            const numTeeth = parseInt(teeth) || 24; const radius = 28; 
            const safeColor = (color || '#666').replace('#','');
            const safeMat = material || 'Standard';
            const renderTeeth = () => { const teethPath = []; for (let i = 0; i < numTeeth; i++) { const angle = (i / numTeeth) * Math.PI * 2; const toothH = 4; const outerX = 30 + Math.cos(angle) * radius; const outerY = 30 + Math.sin(angle) * radius; const innerX = 30 + Math.cos(angle) * (radius - toothH); const innerY = 30 + Math.sin(angle) * (radius - toothH); const tW = (Math.PI * radius / numTeeth) * 0.6; const dx = Math.cos(angle + Math.PI/2) * tW; const dy = Math.sin(angle + Math.PI/2) * tW; teethPath.push(`M ${innerX - dx/2} ${innerY - dy/2} L ${outerX - dx/4} ${outerY - dy/4} L ${outerX + dx/4} ${outerY + dy/4} L ${innerX + dx/2} ${innerY + dy/2} Z`); } return teethPath.join(' '); }; const isMetal = safeMat === 'Bronce' || safeMat === 'Latón';
            return (
                <svg viewBox="0 0 60 60" className="w-full h-full drop-shadow-lg filter transition-transform duration-500 hover:rotate-180">
                    <defs> <radialGradient id={`gear-body-${teeth}-${safeColor}`} cx="50%" cy="50%" r="50%"> <stop offset="60%" stopColor={color || '#666'} /> <stop offset="95%" stopColor="#1a1a1a" /> <stop offset="100%" stopColor="#000" /> </radialGradient> <linearGradient id="metal-shine" x1="0%" y1="0%" x2="100%" y2="100%"> <stop offset="0%" stopColor="#fff" stopOpacity="0.8"/> <stop offset="50%" stopColor="transparent" stopOpacity="0"/> <stop offset="100%" stopColor="#fff" stopOpacity="0.3"/> </linearGradient> </defs>
                    <path d={renderTeeth()} fill={isMetal ? '#d97706' : '#e5e7eb'} stroke="#4b5563" strokeWidth="0.5" /> <circle cx="30" cy="30" r={radius - 2} fill={`url(#gear-body-${teeth}-${safeColor})`} stroke={isMetal ? '#b45309' : '#333'} strokeWidth="1" /> <circle cx="30" cy="30" r="radius - 3" fill="url(#metal-shine)" style={{mixBlendMode: 'overlay'}} /> <g fill="#0a0a0a" stroke={color || '#666'} strokeWidth="0.5" opacity="0.8"> {[0, 60, 120, 180, 240, 300].map(deg => ( <circle key={deg} cx={30 + Math.cos(deg*Math.PI/180)*14} cy={30 + Math.sin(deg*Math.PI/180)*14} r="3.5" /> ))} </g> <circle cx="30" cy="30" r="6" fill={safeMat.includes('Aluminio') || safeMat.includes('Dural') ? '#cbd5e1' : '#d97706'} stroke="#000" strokeWidth="1" /> <circle cx="30" cy="30" r="2.5" fill="#000" /> <circle cx="30" cy="26" r="1" fill="#333" /> <text x="30" y="44" fontSize="5" fontWeight="900" fill="white" textAnchor="middle" style={{textShadow: '0 1px 2px black'}} fontFamily="monospace" letterSpacing="1px">{teeth}</text>
                </svg>
            );
        };

        const PinionSVG = ({ teeth, material, diameter }) => {
            const numTeeth = parseInt(teeth) || 9; const radius = parseFloat(diameter) * 2.5; 
            const safeMatRaw = material || 'Acero';
            const safeMat = safeMatRaw.replace(/[^a-zA-Z0-9]/g, ''); 
            const matColors = { 'Latón': '#d97706', 'Acero': '#94a3b8', 'Nylon': '#f8fafc', 'Ergal': '#ef4444', 'Bronce': '#b45309' }; const baseColor = matColors[safeMatRaw] || '#cbd5e1'; const isNylon = safeMatRaw === 'Nylon';
            const renderTeeth = () => { const teethPath = []; for (let i = 0; i < numTeeth; i++) { const angle = (i / numTeeth) * Math.PI * 2; const toothH = 3; const outerX = 30 + Math.cos(angle) * radius; const outerY = 30 + Math.sin(angle) * radius; const innerX = 30 + Math.cos(angle) * (radius - toothH); const innerY = 30 + Math.sin(angle) * (radius - toothH); const tW = (Math.PI * radius / numTeeth) * 0.5; const dx = Math.cos(angle + Math.PI/2) * tW; const dy = Math.sin(angle + Math.PI/2) * tW; teethPath.push(`M ${innerX - dx} ${innerY - dy} Q ${outerX} ${outerY} ${innerX + dx} ${innerY + dy}`); } return teethPath.join(' '); };
            return (
                <svg viewBox="0 0 60 60" className="w-full h-full drop-shadow-lg filter transition-transform duration-500 hover:rotate-90">
                    <defs> <radialGradient id={`pinion-grad-${teeth}-${safeMat}`} cx="30%" cy="30%" r="70%"> <stop offset="0%" stopColor={isNylon ? '#fff' : '#fff'} stopOpacity={isNylon ? 0.9 : 0.6} /> <stop offset="100%" stopColor={baseColor} /> </radialGradient> </defs>
                    <path d={renderTeeth()} fill="none" stroke={baseColor} strokeWidth="2" strokeLinecap="round" /> <circle cx="30" cy="30" r={radius - 1.5} fill={`url(#pinion-grad-${teeth}-${safeMat})`} stroke={baseColor} strokeWidth="0.5" /> <circle cx="30" cy="30" r="4" fill="#111" stroke="#000" strokeWidth="0.5" /> <path d="M30,26 L30,34 M26,30 L34,30" stroke="#333" strokeWidth="0.5" /> <text x="30" y="54" fontSize="6" fontWeight="bold" fill={isNylon ? '#333' : '#fff'} textAnchor="middle" style={{textShadow: '0 1px 1px black'}} fontFamily="monospace">{teeth}</text> <rect x="38" y="8" width="18" height="8" rx="2" fill="rgba(0,0,0,0.7)" /> <text x="47" y="14" fontSize="4" fill="#39ff14" textAnchor="middle">Ø{diameter}</text>
                </svg>
            );
        };

        const MotorShowcase = ({ selectedCarId, currentConfig, onUpdate }) => {
            const motors = { "NINCO (CLÁSICOS)": [ { name: "NC-5 Speeder", type: "Long Can", rpm: "20.000", torque: "290", color: "#a855f7", label: "NC-5" }, { name: "NC-6 Crusher", type: "Long Can", rpm: "23.500", torque: "350", color: "#facc15", label: "NC-6" }, { name: "NC-1", type: "Short Can", rpm: "15.700", torque: "100", color: "#94a3b8", label: "NC-1" }, { name: "NC-14 Speeder+", type: "Long Can", rpm: "20.600", torque: "280", color: "#14b8a6", label: "NC-14" } ], "SCALEXTRIC (SCX)": [ { name: "RX-41", type: "Short Can", rpm: "14.300", torque: "120", color: "#cbd5e1", label: "RX-41" }, { name: "RX-42B", type: "Short Can", rpm: "19.000", torque: "145", color: "#ef4444", label: "RX-42B" }, { name: "Pro Speed", type: "Long Can", rpm: "20.000", torque: "240", color: "#f97316", label: "PRO" }, { name: "Pro Double", type: "Long Can", rpm: "21.000", torque: "280", color: "#22c55e", label: "4x4" } ], "NSR (COMPETICIÓN)": [ { name: "King 21 EVO3", type: "Long Can", rpm: "21.400", torque: "350", color: "#f97316", label: "KING 21" }, { name: "King 25 EVO3", type: "Long Can", rpm: "25.000", torque: "385", color: "#fbbf24", label: "KING 25" }, { name: "Shark 25", type: "Short Can", rpm: "25.000", torque: "176", color: "#ef4444", label: "SHARK" }, { name: "Baby King", type: "Long Can", rpm: "17.000", torque: "245", color: "#cbd5e1", label: "BABY" } ], "SLOT.IT (FLAT / V12)": [ { name: "V12/4", type: "Short Can", rpm: "23.000", torque: "170", color: "#fbbf24", label: "V12-4" }, { name: "Boxer 2", type: "Long Can", rpm: "21.500", torque: "340", color: "#f97316", label: "BOXER" }, { name: "Flat-6 R", type: "Flat", rpm: "22.000", torque: "220", color: "#ef4444", label: "FLAT-R" }, { name: "Flat-6 S", type: "Flat", rpm: "20.500", torque: "200", color: "#facc15", label: "FLAT-S" } ], "SCALEAUTO (TECH)": [ { name: "Tech-1 (SC-11)", type: "Short Can", rpm: "20.000", torque: "170", color: "#f97316", label: "SC-11" }, { name: "Sprinter Jr", type: "Long Can", rpm: "21.000", torque: "320", color: "#3b82f6", label: "SC-29" }, { name: "Endurance", type: "Long Can", rpm: "22.000", torque: "310", color: "#ef4444", label: "SC-26" } ] };
            const translateType = (type) => { if (type === 'Long Can') return 'Caja Larga'; if (type === 'Short Can') return 'Caja Corta'; if (type === 'Flat') return 'Perfil Bajo'; return type; };
            return (
                <div className="w-64 h-[21rem] shrink-0 flex flex-col rounded-sm overflow-hidden border border-[#39ff14]/30 shadow-[0_0_20px_rgba(57,255,20,0.1)] bg-[#050a05]/90 backdrop-blur-md animate-in z-50 transition-all hover:border-[#39ff14]/80 hover:shadow-[0_0_30px_rgba(57,255,20,0.2)] group relative">
                    <div className="absolute top-0 left-0 w-2 h-2 border-t-2 border-l-2 border-[#39ff14]"></div> <div className="absolute top-0 right-0 w-2 h-2 border-t-2 border-r-2 border-[#39ff14]"></div> <div className="absolute bottom-0 left-0 w-2 h-2 border-b-2 border-l-2 border-[#39ff14]"></div> <div className="absolute bottom-0 right-0 w-2 h-2 border-b-2 border-r-2 border-[#39ff14]"></div> <div className="absolute inset-0 opacity-5 pointer-events-none" style={{backgroundImage: 'linear-gradient(#39ff14 1px, transparent 1px), linear-gradient(90deg, #39ff14 1px, transparent 1px)', backgroundSize: '20px 20px'}}></div>
                    <div className="p-2 border-b border-[#39ff14]/20 bg-[#39ff14]/5 flex justify-between items-center shrink-0 relative z-10"> <div className="flex items-center gap-2"> <Zap className="text-[#39ff14]" size={14} /> <h2 className="text-[10px] font-black text-white tracking-[0.2em] uppercase drop-shadow-[0_0_5px_rgba(57,255,20,0.8)]">BANCO DE MOTORES</h2> </div> <div className="flex items-center gap-1"> <div className="w-1.5 h-1.5 rounded-full bg-[#39ff14] animate-pulse"></div> <span className="text-[8px] text-[#39ff14]/70 font-mono">C{selectedCarId}</span> </div> </div>
                    <div className="flex-1 overflow-y-auto p-2 space-y-3 workshop-scroll relative z-10">
                        {Object.entries(motors).map(([brand, list]) => ( <div key={brand}> <div className="flex items-center gap-2 mb-1.5 pl-1"> <div className="h-px w-2 bg-[#39ff14]/50"></div> <h3 className="text-[9px] font-bold text-[#39ff14] uppercase tracking-wider">{brand}</h3> <div className="h-px flex-1 bg-gradient-to-r from-[#39ff14]/30 to-transparent"></div> </div> <div className="space-y-1"> {list.map((motor, idx) => { const isSelected = currentConfig.motorName === motor.label; return ( <div key={idx} onClick={() => onUpdate('motor', motor)} className={`rounded-sm p-1.5 flex gap-2 transition-all group/item items-center cursor-pointer border ${isSelected ? 'bg-[#39ff14]/20 border-[#39ff14] shadow-[0_0_10px_#39ff14]' : 'bg-black/40 border-[#39ff14]/10 hover:bg-[#39ff14]/10 hover:border-[#39ff14]/40'}`}> <div className="w-12 h-8 shrink-0 flex items-center justify-center opacity-90 group-hover/item:opacity-100 transition-opacity"> <MotorSVG type={motor.type} color={motor.color} label={motor.label} /> </div> <div className="flex-1 min-w-0"> <div className="flex justify-between items-baseline"> <h4 className={`font-bold text-[9px] truncate transition-colors ${isSelected ? 'text-white' : 'text-gray-300 group-hover/item:text-white'}`}>{motor.name}</h4> <span className="text-[7px] text-[#39ff14]/60 font-mono">{translateType(motor.type)}</span> </div> <div className="flex gap-2 text-[8px] mt-0.5 font-mono"> <span className={`${isSelected ? 'text-[#39ff14]' : 'text-gray-500 group-hover/item:text-[#39ff14]'} transition-colors`}>{motor.rpm} rpm</span> <span className={`${isSelected ? 'text-[#39ff14]' : 'text-gray-600 group-hover/item:text-[#39ff14]'} transition-colors`}>{motor.torque} g/cm</span> </div> </div> </div> ); })} </div> </div> ))}
                    </div>
                </div>
            );
        };

        const TireShowcase = ({ selectedCarId, currentConfig, onUpdate }) => {
            const tires = { "SCALEAUTO (1/32)": [ { name: "Spirits", type: "Slick", compound: "Blando", grip: 95, color: "#cbd5e1", text: "#fff", label: "SPIRITS" }, { name: "AS-25", type: "Slick", compound: "Duro", grip: 40, color: "#94a3b8", text: "#94a3b8", label: "AS-25" }, { name: "Zero Grip", type: "Slick", compound: "Delantero", grip: 5, color: "#475569", text: "#475569", label: "ZERO" } ], "SLOT.IT (P6/F22)": [ { name: "P6", type: "Slick", compound: "Medio", grip: 70, color: "#fdba74", text: "#f97316", label: "P6" }, { name: "F22", type: "Slick", compound: "Blando", grip: 85, color: "#86efac", text: "#22c55e", label: "F22" }, { name: "N18", type: "Slick", compound: "Duro", grip: 50, color: "#fca5a5", text: "#ef4444", label: "N18" }, { name: "G25", type: "Slick", compound: "Ex-Blando", grip: 90, color: "#fde047", text: "#eab308", label: "G25" } ], "NSR (RACING)": [ { name: "Supergrip", type: "Slick", compound: "Blando", grip: 80, color: "#ef4444", text: "#ef4444", label: "SUPER" }, { name: "Ultragrip", type: "Slick", compound: "Muy Blando", grip: 92, color: "#a855f7", text: "#a855f7", label: "ULTRA" }, { name: "Extreme", type: "Slick", compound: "Extremo", grip: 98, color: "#dc2626", text: "#dc2626", label: "XTREM" }, { name: "Rain", type: "Lluvia", compound: "Mojado", grip: 88, color: "#3b82f6", text: "#3b82f6", label: "RAIN" } ], "MITOOS": [ { name: "S1", type: "Slick", compound: "Blando", grip: 85, color: "#f472b6", text: "#ec4899", label: "S1" }, { name: "S2", type: "Slick", compound: "Medio", grip: 70, color: "#c084fc", text: "#9333ea", label: "S2" } ] };
            return (
                <div className="w-64 h-[21rem] shrink-0 flex flex-col rounded-sm overflow-hidden border border-[#39ff14]/30 shadow-[0_0_20px_rgba(57,255,20,0.1)] bg-[#050a05]/90 backdrop-blur-md animate-in z-50 transition-all hover:border-[#39ff14]/80 hover:shadow-[0_0_30px_rgba(57,255,20,0.2)] group relative">
                    <div className="absolute top-0 left-0 w-2 h-2 border-t-2 border-l-2 border-[#39ff14]"></div> <div className="absolute top-0 right-0 w-2 h-2 border-t-2 border-r-2 border-[#39ff14]"></div> <div className="absolute bottom-0 left-0 w-2 h-2 border-b-2 border-l-2 border-[#39ff14]"></div> <div className="absolute bottom-0 right-0 w-2 h-2 border-b-2 border-r-2 border-[#39ff14]"></div> <div className="absolute inset-0 opacity-5 pointer-events-none" style={{backgroundImage: 'linear-gradient(#39ff14 1px, transparent 1px), linear-gradient(90deg, #39ff14 1px, transparent 1px)', backgroundSize: '20px 20px'}}></div>
                    <div className="p-2 border-b border-[#39ff14]/20 bg-[#39ff14]/5 flex justify-between items-center shrink-0 relative z-10"> <div className="flex items-center gap-2"> <RotateCw className="text-[#39ff14]" size={14} /> <h2 className="text-[10px] font-black text-white tracking-[0.2em] uppercase drop-shadow-[0_0_5px_rgba(57,255,20,0.8)]">COMPUESTOS Y GOMAS</h2> </div> <div className="flex items-center gap-1"> <div className="w-1.5 h-1.5 rounded-full bg-[#39ff14] animate-pulse"></div> <span className="text-[8px] text-[#39ff14]/70 font-mono">C{selectedCarId}</span> </div> </div>
                    <div className="flex-1 overflow-y-auto p-2 space-y-3 workshop-scroll relative z-10">
                        {Object.entries(tires).map(([brand, list]) => ( <div key={brand}> <div className="flex items-center gap-2 mb-1.5 pl-1"> <div className="h-px w-2 bg-[#39ff14]/50"></div> <h3 className="text-[9px] font-bold text-[#39ff14] uppercase tracking-wider">{brand}</h3> <div className="h-px flex-1 bg-gradient-to-r from-[#39ff14]/30 to-transparent"></div> </div> <div className="space-y-1"> {list.map((tire, idx) => { const isSelected = currentConfig.tireName === tire.label; return ( <div key={idx} onClick={() => onUpdate('tire', tire)} className={`rounded-sm p-1.5 flex gap-2 transition-all group/item items-center cursor-pointer border ${isSelected ? 'bg-[#39ff14]/20 border-[#39ff14] shadow-[0_0_10px_#39ff14]' : 'bg-black/40 border-[#39ff14]/10 hover:bg-[#39ff14]/10 hover:border-[#39ff14]/40'}`}> <div className="w-8 h-8 shrink-0 flex items-center justify-center opacity-90 group-hover/item:opacity-100 transition-opacity"> <TireSVG type={tire.type} rimColor={tire.color} label={tire.label} compoundColor={tire.text} /> </div> <div className="flex-1 min-w-0 pl-1"> <div className="flex justify-between items-baseline"> <h4 className={`font-bold text-[9px] truncate transition-colors ${isSelected ? 'text-white' : 'text-gray-300 group-hover/item:text-white'}`}>{tire.name}</h4> <span className="text-[7px] text-[#39ff14]/60 font-mono">{tire.type === 'Rain' ? 'Lluvia' : tire.type}</span> </div> <div className="flex flex-col gap-0.5 mt-0.5"> <div className="flex justify-between text-[7px] text-gray-500"> <span>{tire.compound}</span> <span className="text-[#39ff14]">{tire.grip}% Grip</span> </div> <div className="h-1 w-full bg-gray-800 rounded-full overflow-hidden"> <div className="h-full bg-gradient-to-r from-gray-600 to-[#39ff14]" style={{width: `${tire.grip}%`}}></div> </div> </div> </div> </div> ); })} </div> </div> ))}
                    </div>
                </div>
            );
        };

        const GearShowcase = ({ selectedCarId, currentConfig, onUpdate }) => {
            const gears = { "SLOT.IT (EN LÍNEA)": [ { teeth: "24z", color: "#22c55e", type: "Aluminio", label: "GRN" }, { teeth: "25z", color: "#78350f", type: "Bronce", label: "BRN" }, { teeth: "26z", color: "#3b82f6", type: "Bronce", label: "BLU" }, { teeth: "27z", color: "#eab308", type: "Aluminio", label: "YEL" }, { teeth: "28z", color: "#f97316", type: "Aluminio", label: "ORG" } ], "NSR (ANGLEWINDER)": [ { teeth: "29z", color: "#ec4899", type: "Aluminio", label: "PNK" }, { teeth: "30z", color: "#ef4444", type: "Aluminio", label: "RED" }, { teeth: "31z", color: "#111111", type: "Aluminio", label: "BLK" }, { teeth: "32z", color: "#a855f7", type: "Aluminio", label: "PUR" } ], "SLOTING PLUS (DURAL)": [ { teeth: "28z", color: "#dc2626", type: "Dural", label: "RED" }, { teeth: "30z", color: "#9333ea", type: "Dural", label: "PUR" }, { teeth: "32z", color: "#2563eb", type: "Dural", label: "BLU" }, { teeth: "34z", color: "#eab308", type: "Dural", label: "GLD" } ] };
            return (
                <div className="w-64 h-40 shrink-0 flex flex-col rounded-sm overflow-hidden border border-[#39ff14]/30 shadow-[0_0_20px_rgba(57,255,20,0.1)] bg-[#050a05]/90 backdrop-blur-md animate-in z-50 transition-all hover:border-[#39ff14]/80 hover:shadow-[0_0_30px_rgba(57,255,20,0.2)] group relative">
                    <div className="absolute top-0 right-0 w-3 h-3 border-t-2 border-r-2 border-[#39ff14]"></div> <div className="absolute bottom-0 left-0 w-3 h-3 border-b-2 border-l-2 border-[#39ff14]"></div>
                    <div className="p-2 border-b border-[#39ff14]/20 bg-[#39ff14]/5 flex justify-between items-center shrink-0"> <div className="flex items-center gap-2"> <Settings className="text-[#39ff14]" size={14} /> <h2 className="text-[10px] font-black text-white tracking-[0.2em] uppercase">RELACIÓN TRANSMISIÓN</h2> </div> <span className="text-[8px] text-[#39ff14]/70 font-mono">CORONAS</span> </div>
                    <div className="flex-1 overflow-y-auto p-2 space-y-3 workshop-scroll relative z-10">
                        {Object.entries(gears).map(([brand, list]) => ( <div key={brand}> <div className="flex items-center gap-2 mb-1.5 pl-1"> <div className="w-1 h-1 bg-[#39ff14] rounded-full"></div> <h3 className="text-[9px] font-bold text-[#39ff14]/80 uppercase tracking-wide">{brand}</h3> </div> <div className="grid grid-cols-4 gap-2"> {list.map((gear, idx) => { const isSelected = currentConfig.gearTeeth === parseInt(gear.teeth); return ( <div key={idx} onClick={() => onUpdate('gear', gear)} className={`flex flex-col items-center gap-1 group/gear cursor-pointer p-1 rounded transition-all border ${isSelected ? 'bg-[#39ff14]/20 border-[#39ff14] shadow-[0_0_10px_#39ff14]' : 'border-transparent hover:bg-[#39ff14]/10'}`} title={`${gear.teeth} - ${gear.type}`}> <div className="w-10 h-10 transition-transform duration-300 group-hover/gear:scale-110"> <GearSVG teeth={gear.teeth} color={gear.color} material={gear.type} /> </div> <div className={`text-[8px] font-mono transition-colors ${isSelected ? 'text-[#39ff14]' : 'text-gray-400 group-hover/gear:text-white'}`}>{gear.teeth}</div> </div> ); })} </div> </div> ))}
                    </div>
                </div>
            );
        };

        const PinionShowcase = ({ selectedCarId, currentConfig, onUpdate }) => {
            const pinions = { "SLOT.IT (5.5mm / 6.5mm)": [ { teeth: "9z", type: "Latón", diameter: "5.5" }, { teeth: "10z", type: "Latón", diameter: "5.5" }, { teeth: "11z", type: "Bronce", diameter: "6.5" }, { teeth: "12z", type: "Bronce", diameter: "6.5" } ], "NSR (RACING)": [ { teeth: "10z", type: "Acero", diameter: "5.5" }, { teeth: "11z", type: "Acero", diameter: "6.5" }, { teeth: "12z", type: "Acero", diameter: "7.5" }, { teeth: "13z", type: "Acero", diameter: "7.5" } ], "SLOTING PLUS (MODULAR)": [ { teeth: "10z", type: "Nylon", diameter: "6.5" }, { teeth: "11z", type: "Nylon", diameter: "6.5" }, { teeth: "12z", type: "Acero", diameter: "6.5" }, { teeth: "13z", type: "Latón", diameter: "6.5" } ], "SCALEAUTO (ACERO)": [ { teeth: "8z", type: "Acero", diameter: "5.0" }, { teeth: "9z", type: "Acero", diameter: "5.5" }, { teeth: "10z", type: "Acero", diameter: "6.0" } ] };
            return (
                <div className="w-64 h-40 shrink-0 flex flex-col rounded-sm overflow-hidden border border-[#39ff14]/30 shadow-[0_0_20px_rgba(57,255,20,0.1)] bg-[#050a05]/90 backdrop-blur-md animate-in z-50 transition-all hover:border-[#39ff14]/80 hover:shadow-[0_0_30px_rgba(57,255,20,0.2)] group relative">
                    <div className="absolute top-0 right-0 w-3 h-3 border-t-2 border-r-2 border-[#39ff14]"></div> <div className="absolute bottom-0 left-0 w-3 h-3 border-b-2 border-l-2 border-[#39ff14]"></div>
                    <div className="p-2 border-b border-[#39ff14]/20 bg-[#39ff14]/5 flex justify-between items-center shrink-0"> <div className="flex items-center gap-2"> <Settings className="text-[#39ff14]" size={14} /> <h2 className="text-[10px] font-black text-white tracking-[0.2em] uppercase">PIÑONES MOTOR</h2> </div> <span className="text-[8px] text-[#39ff14]/70 font-mono">EJE MOTOR</span> </div>
                    <div className="flex-1 overflow-y-auto p-2 space-y-3 workshop-scroll relative z-10">
                        {Object.entries(pinions).map(([brand, list]) => ( <div key={brand}> <div className="flex items-center gap-2 mb-1.5 pl-1"> <div className="w-1 h-1 bg-[#39ff14] rounded-full"></div> <h3 className="text-[9px] font-bold text-[#39ff14]/80 uppercase tracking-wide">{brand}</h3> </div> <div className="grid grid-cols-4 gap-2"> {list.map((pinion, idx) => { const isSelected = currentConfig.pinionTeeth === parseInt(pinion.teeth); return ( <div key={idx} onClick={() => onUpdate('pinion', pinion)} className={`flex flex-col items-center gap-1 group/pinion cursor-pointer p-1 rounded transition-all border ${isSelected ? 'bg-[#39ff14]/20 border-[#39ff14] shadow-[0_0_10px_#39ff14]' : 'border-transparent hover:bg-[#39ff14]/10'}`} title={`${pinion.teeth} - ${pinion.type}`}> <div className="w-10 h-10 transition-transform duration-300 group-hover/pinion:scale-110"> <PinionSVG teeth={pinion.teeth} material={pinion.type} diameter={pinion.diameter} /> </div> <div className={`text-[8px] font-mono transition-colors ${isSelected ? 'text-[#39ff14]' : 'text-gray-400 group-hover/pinion:text-white'}`}>{pinion.teeth}</div> </div> ); })} </div> </div> ))}
                    </div>
                </div>
            );
        };

        const VoltageShowcase = ({ voltage, setVoltage }) => {
            const [amps, setAmps] = useState(1.2); const [history, setHistory] = useState(new Array(24).fill(0.2));
            useEffect(() => { const interval = setInterval(() => { const baseAmps = (voltage / 12) * 1.5; const noise = (Math.random() - 0.5) * 0.15; const newAmps = Math.max(0, baseAmps + noise); setAmps(newAmps); setHistory(prev => { const barHeight = Math.min(1, Math.max(0.1, newAmps / 3)); return [...prev.slice(1), barHeight]; }); }, 100); return () => clearInterval(interval); }, [voltage]);
            return (
                <div className="w-64 h-40 shrink-0 flex flex-col rounded-sm overflow-hidden border border-[#39ff14]/30 shadow-[0_0_20px_rgba(57,255,20,0.1)] bg-[#050a05]/90 backdrop-blur-md animate-in z-50 transition-all hover:border-[#39ff14]/80 hover:shadow-[0_0_30px_rgba(57,255,20,0.2)] relative group">
                    <svg className="absolute top-0 left-0 w-6 h-6 pointer-events-none opacity-50" viewBox="0 0 32 32"><path d="M1 1 L10 1 L10 2 L2 2 L2 10 L1 10 Z" fill="#39ff14"/></svg> <svg className="absolute top-0 right-0 w-6 h-6 pointer-events-none opacity-50" viewBox="0 0 32 32"><path d="M31 1 L22 1 L22 2 L30 2 L30 10 L31 10 Z" fill="#39ff14"/></svg> <svg className="absolute bottom-0 left-0 w-6 h-6 pointer-events-none opacity-50" viewBox="0 0 32 32"><path d="M1 31 L10 31 L10 30 L2 30 L2 22 L1 22 Z" fill="#39ff14"/></svg> <svg className="absolute bottom-0 right-0 w-6 h-6 pointer-events-none opacity-50" viewBox="0 0 32 32"><path d="M31 31 L22 31 L22 30 L30 30 L30 22 L31 22 Z" fill="#39ff14"/></svg>
                    <div className="p-2 border-b border-[#39ff14]/20 bg-[#39ff14]/5 flex justify-between items-center shrink-0 relative z-10"> <div className="flex items-center gap-2"> <Battery className="text-[#39ff14]" size={14} /> <h2 className="text-[10px] font-black text-white tracking-[0.2em] uppercase">FUENTE DS-3</h2> </div> <div className="flex items-center gap-1"> <div className="w-1.5 h-1.5 bg-red-500 rounded-full animate-pulse"></div> <span className="text-[8px] text-[#39ff14]/70 font-mono">ON AIR</span> </div> </div>
                    <div className="flex flex-col p-2 gap-2 h-full relative z-10"> <div className="grid grid-cols-2 gap-2 h-16"> <div className="bg-black border border-[#39ff14]/30 rounded relative flex flex-col items-center justify-center shadow-[inset_0_0_15px_rgba(0,0,0,1)]"> <span className="absolute top-0.5 left-1 text-[6px] text-[#39ff14]/60 font-bold tracking-wider">VOLTAJE</span> <div className="flex items-baseline gap-0.5 mt-1"> <span className="font-digital text-2xl font-black text-white drop-shadow-[0_0_5px_white] tracking-widest">{voltage.toFixed(1)}</span> <span className="text-[10px] font-bold text-[#39ff14]">V</span> </div> </div> <div className="bg-black border border-[#39ff14]/30 rounded relative flex flex-col items-center justify-center shadow-[inset_0_0_15px_rgba(0,0,0,1)]"> <span className="absolute top-0.5 left-1 text-[6px] text-[#39ff14]/60 font-bold tracking-wider">CORRIENTE</span> <div className="flex items-baseline gap-0.5 mt-1"> <span className="font-digital text-2xl font-black text-[#39ff14] drop-shadow-[0_0_8px_#39ff14] tracking-widest">{amps.toFixed(2)}</span> <span className="text-[10px] font-bold text-[#39ff14]">A</span> </div> <div className="absolute top-1 right-1 w-1 h-1 bg-red-500 rounded-full animate-pulse shadow-[0_0_5px_red]"></div> </div> </div> <div className="flex-1 bg-black/50 border border-[#39ff14]/20 rounded flex items-end px-0.5 gap-[1px] relative overflow-hidden"> <div className="absolute inset-0 opacity-20" style={{backgroundImage: 'linear-gradient(transparent 3px, #39ff14 3px)', backgroundSize: '100% 4px'}}></div> {history.map((h, i) => ( <div key={i} className="flex-1 bg-[#39ff14]/60 shadow-[0_0_5px_#39ff14]" style={{height: `${h * 100}%`, transition: 'height 0.1s ease'}}></div> ))} <span className="absolute top-0.5 right-1 text-[6px] text-[#39ff14]/50 font-mono">LOAD MONITOR</span> </div> <div className="flex items-center gap-2"> <button onClick={() => setVoltage(Math.max(10, voltage - 0.5))} className="w-8 h-6 rounded bg-gray-900 border border-gray-700 hover:border-[#39ff14] hover:bg-[#39ff14]/20 text-gray-400 hover:text-[#39ff14] flex items-center justify-center transition-all active:scale-95"><Minus size={12}/></button> <div className="flex-1 h-1.5 bg-gray-900 rounded-full overflow-hidden border border-gray-700 relative group-hover:border-[#39ff14]/30 transition-colors"> <div className="h-full bg-gradient-to-r from-[#39ff14]/40 to-[#39ff14] shadow-[0_0_10px_#39ff14] relative transition-all duration-300" style={{width: `${((voltage - 10) / 10) * 100}%`}}></div> </div> <button onClick={() => setVoltage(Math.min(20, voltage + 0.5))} className="w-8 h-6 rounded bg-gray-900 border border-gray-700 hover:border-[#39ff14] hover:bg-[#39ff14]/20 text-gray-400 hover:text-[#39ff14] flex items-center justify-center transition-all active:scale-95"><Plus size={12}/></button> </div> </div>
                </div>
            );
        };

        const WeightShowcase = ({ selectedCarId, currentConfig, onUpdate }) => {
            const weightItems = [ { id: 'body', label: "CARROCERÍA", val: 24.5 }, { id: 'chassis', label: "CHASIS 3D", val: 16.2 }, { id: 'trans', label: "EJES/TRANS", val: 12.8 }, { id: 'wheels', label: "LLANTAS", val: 8.4 }, { id: 'cockpit', label: "COCKPIT", val: 2.1 } ];
            const baseWeight = weightItems.reduce((acc, item) => acc + item.val, 0); const currentWeight = currentConfig.weight || baseWeight;
            
            return (
                <div className="w-64 h-40 shrink-0 flex flex-col rounded-sm overflow-hidden border border-[#39ff14]/30 shadow-[0_0_20px_rgba(57,255,20,0.1)] bg-[#050a05]/90 backdrop-blur-md animate-in z-50 transition-all hover:border-[#39ff14]/80 hover:shadow-[0_0_30px_rgba(57,255,20,0.2)] relative group cursor-pointer" onClick={() => onUpdate('weight', currentWeight > 80 ? 60 : 85)} title="Click para Aligerar/Lastrar Chasis">
                    <div className="absolute inset-0 opacity-10 pointer-events-none" style={{backgroundImage: 'radial-gradient(#39ff14 1px, transparent 1px)', backgroundSize: '10px 10px'}}></div>
                    <div className="p-2 border-b border-[#39ff14]/20 bg-[#39ff14]/5 flex justify-between items-center shrink-0 relative z-10"> <div className="flex items-center gap-2"> <Scale className="text-[#39ff14]" size={14} /> <h2 className="text-[10px] font-black text-white tracking-[0.2em] uppercase">BÁSCULA DIGITAL</h2> </div> <div className="flex items-center gap-1"><div className="w-1 h-1 rounded-full bg-[#39ff14] animate-pulse"></div><span className="text-[8px] text-[#39ff14]/70 font-mono">C{selectedCarId}</span></div> </div>
                    <div className="flex flex-row flex-1 p-2 gap-2 relative z-10 overflow-hidden"> <div className="flex-1 flex flex-col justify-between pr-2 border-r border-[#39ff14]/10"> {weightItems.map((w, i) => ( <div key={i} className="flex items-center justify-between group/row"> <span className="text-[8px] text-gray-400 font-bold uppercase tracking-tighter group-hover/row:text-white transition-colors">{w.label}</span> <span className="text-[9px] font-mono text-[#39ff14]">{w.val}</span> </div> ))} </div> <div className="w-24 flex flex-col justify-between items-end"> <div className="text-right mt-1"> <span className="text-[7px] text-[#39ff14]/60 font-bold tracking-widest uppercase block mb-0.5">PESO TOTAL</span> <div className="relative inline-block bg-black/40 px-2 py-1 rounded border border-[#39ff14]/20 shadow-[inset_0_0_10px_rgba(0,0,0,1)]"> <span className="font-digital text-3xl font-black text-white drop-shadow-[0_0_10px_rgba(57,255,20,0.8)] leading-none block">{currentWeight.toFixed(1)}</span> <span className="absolute -bottom-2 -right-1 text-[10px] font-bold text-[#39ff14]">g</span> </div> </div> <div className="w-full flex items-end gap-[2px] h-10 mt-2 opacity-80"> {weightItems.map((w, i) => ( <div key={i} className="flex-1 bg-[#39ff14]/20 rounded-sm relative group/bar hover:bg-[#39ff14]/40 transition-colors"> <div className="absolute bottom-0 w-full bg-[#39ff14] rounded-sm transition-all duration-500 shadow-[0_0_5px_#39ff14]" style={{height: `${(w.val / 30) * 100}%`}}></div> </div> ))} </div> </div> </div>
                </div>
            );
        };

        // --- NUEVO: PANEL DE TELEMETRÍA EN VIVO (BLINDAJE TOTAL V2 + DRAGGABLE) ---
        const TelemetryPanel = ({ carId, data, config, onDragStart, style }) => {
            if (!data) return null;
            const safeConfig = config || {}; 
            const safeMotor = String(safeConfig.motorName || 'STD');
            const safeTire = String(safeConfig.tireName || 'STD');
            const rawRatio = safeConfig.gearRatio;
            const safeRatio = (typeof rawRatio === 'number' && !isNaN(rawRatio)) 
                ? rawRatio.toFixed(2) 
                : parseFloat(rawRatio || 3.0).toFixed(2);

            const speedPercent = Math.min(100, (data.speed / 400) * 100);
            const rpmPercent = Math.min(100, (data.speed / 300) * 90 + Math.random()*10);
            
            return (
                <div 
                    className="w-64 bg-[#050a05]/95 shrink-0 border-2 border-[#39ff14] rounded-xl overflow-hidden shadow-[0_0_40px_rgba(57,255,20,0.2)] backdrop-blur-xl animate-in absolute z-[100]"
                    style={style}
                >
                    <div 
                        className="bg-[#39ff14] text-black px-3 py-2 flex justify-between items-center cursor-move hover:bg-[#32e612] transition-colors"
                        onPointerDown={onDragStart}
                    > 
                        <div className="flex items-center gap-2 pointer-events-none"> 
                            <Activity size={14} className="animate-pulse"/> 
                            <h2 className="font-black text-[10px] tracking-[0.2em] uppercase select-none">TELEMETRÍA</h2> 
                        </div> 
                        <div className="flex items-center gap-2">
                            <Move size={10} className="opacity-50"/>
                            <span className="font-mono font-bold text-[9px] bg-black/20 px-2 py-0.5 rounded pointer-events-none select-none">COCHE {carId}</span> 
                        </div>
                    </div>

                    <div className="p-3 grid grid-cols-2 gap-3 relative"> 
                        <div className="absolute inset-0 opacity-10 pointer-events-none" style={{backgroundImage: 'linear-gradient(transparent 9px, #39ff14 1px), linear-gradient(90deg, transparent 9px, #39ff14 1px)', backgroundSize: '20px 20px'}}></div> 
                        
                        <div className="col-span-2 flex items-end justify-between border-b border-[#39ff14]/30 pb-2"> 
                            <div> 
                                <span className="text-[8px] text-[#39ff14]/60 font-bold uppercase block">VELOCIDAD</span> 
                                <span className="font-digital text-4xl text-white drop-shadow-[0_0_10px_rgba(57,255,20,0.8)] leading-none">{data.speed}</span> 
                                <span className="text-[10px] text-[#39ff14] font-bold ml-1">Km/h</span> 
                            </div> 
                            <div className="w-1/2 flex flex-col items-end"> 
                                <div className="w-full h-1.5 bg-gray-900 rounded-full overflow-hidden border border-[#39ff14]/30"> 
                                    <div className="h-full bg-gradient-to-r from-[#39ff14]/40 via-[#39ff14] to-white transition-all duration-75" style={{width: `${rpmPercent}%`}}></div> 
                                </div> 
                                <span className="text-[7px] text-[#39ff14] font-mono mt-1">RPM: {(rpmPercent * 250).toFixed(0)}0</span> 
                            </div> 
                        </div> 

                        <div className="space-y-1.5"> 
                            <div className="flex justify-between items-center"> 
                                <span className="text-[8px] text-gray-400 font-bold">MOTOR</span> 
                                <span className="text-[8px] text-[#39ff14] font-mono border border-[#39ff14]/30 px-1 rounded">{safeMotor}</span> 
                            </div> 
                            <div className="flex justify-between items-center"> 
                                <span className="text-[8px] text-gray-400 font-bold">GOMAS</span> 
                                <span className="text-[8px] text-[#39ff14] font-mono border border-[#39ff14]/30 px-1 rounded">{safeTire}</span> 
                            </div> 
                            <div className="flex justify-between items-center"> 
                                <span className="text-[8px] text-gray-400 font-bold">RELACIÓN</span> 
                                <span className="text-[8px] text-[#39ff14] font-mono border border-[#39ff14]/30 px-1 rounded">{safeRatio}</span> 
                            </div> 
                        </div> 

                        <div className="text-right space-y-1"> 
                            <div> <span className="text-[7px] text-gray-500 block uppercase">ÚLTIMA VUELTA</span> <span className="font-digital text-base text-white">{data.lastLap > 0 ? (data.lastLap/1000).toFixed(3) : '--.---'}</span> </div> 
                            <div> <span className="text-[7px] text-[#39ff14]/80 block uppercase">MEJOR VUELTA</span> <span className="font-digital text-base text-[#39ff14] drop-shadow-[0_0_5px_rgba(57,255,20,0.5)]">{data.bestLap > 0 && data.bestLap !== Infinity ? (data.bestLap/1000).toFixed(3) : '--.---'}</span> </div> 
                        </div> 
                        
                        <div className="absolute top-14 left-1/2 -translate-x-1/2 w-12 h-12 border border-[#39ff14]/20 rounded-full flex items-center justify-center pointer-events-none"> 
                            <div className="w-1 h-1 bg-[#39ff14] rounded-full shadow-[0_0_5px_#39ff14] transition-transform duration-100" style={{transform: `translate(${(Math.random()-0.5)*15}px, ${(Math.random()-0.5)*15}px)`}}></div> 
                            <span className="absolute -bottom-2 text-[6px] text-[#39ff14]/50">G-FORCE</span> 
                        </div> 
                    </div>
                </div>
            );
        };
        
        const DrawEngine2D = {
            drawRails: (ctx, l, off, brand) => {
                ctx.strokeStyle = brand.railColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, -off); ctx.lineTo(l, -off); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, off); ctx.lineTo(l, off); ctx.stroke();
                ctx.strokeStyle = brand.slotColor; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, -off); ctx.lineTo(l, -off); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, off); ctx.lineTo(l, off); ctx.stroke();
            },
            drawDigitalWedge: (ctx, l, startLaneY, directionY, s) => {
               ctx.fillStyle = '#d1d5db'; ctx.strokeStyle = '#6b7280'; ctx.lineWidth = 1; ctx.beginPath(); const xStart = l * 0.15, xEnd = l * 0.40, indent = 3 * (s/5), yStraight = startLaneY + (directionY * 1.5), wedgeW = 12 * (s/5); 
               ctx.moveTo(xStart, yStraight); ctx.lineTo(xEnd, yStraight); ctx.lineTo(xEnd - indent, (yStraight + yStraight + directionY*wedgeW)/2); ctx.lineTo(xEnd, yStraight + directionY*wedgeW); ctx.quadraticCurveTo(xStart + (xEnd-xStart)*0.5, yStraight + (directionY * wedgeW * 0.3), xStart, yStraight); ctx.fill(); ctx.stroke();
            },
            drawHazardZone: (ctx, pathFn, s, color = '#facc15') => { ctx.save(); ctx.beginPath(); pathFn(ctx); ctx.clip(); ctx.strokeStyle = color; ctx.lineWidth = 2; const diagSpace = 8 * (s/5); for(let dx = -1000; dx < 1000; dx += diagSpace) { ctx.beginPath(); ctx.moveTo(dx, -500); ctx.lineTo(dx - 500, 500); ctx.stroke(); } ctx.restore(); },
            renderTrack: (ctx, pieces, view, circuitOrigin, activeBrand, selectedPieceId, imageCache, isCircuitMoveMode, boardPoints, boardClosed) => {
                const brand = TRACK_DEFINITIONS[activeBrand]; let cx = view.x + circuitOrigin.x * view.scale, cy = view.y + circuitOrigin.y * view.scale, angle = 0; const newPiecePositions = []; 
                if (boardPoints && boardPoints.length > 0) {
                    ctx.save(); ctx.translate(view.x, view.y); ctx.scale(view.scale, view.scale);
                    if (boardPoints.length > 1) {
                        ctx.beginPath(); ctx.moveTo(boardPoints[0].x, boardPoints[0].y); for(let i=1; i<boardPoints.length; i++) { ctx.lineTo(boardPoints[i].x, boardPoints[i].y); }
                        if (boardClosed) { 
                            ctx.closePath(); 
                            ctx.fillStyle = 'rgba(34, 197, 94, 0.5)'; // Color Verde más intenso
                            ctx.fill(); 
                        } 
                        ctx.lineWidth = 3 / view.scale; ctx.strokeStyle = '#4ade80'; ctx.stroke();
                        if (boardClosed) { ctx.shadowColor = '#4ade80'; ctx.shadowBlur = 15; ctx.stroke(); ctx.shadowBlur = 0; }
                    }
                    boardPoints.forEach((p, i) => { 
                        ctx.beginPath(); 
                        if (i === boardPoints.length - 1 && !boardClosed) { 
                            ctx.fillStyle = '#ef4444'; 
                            const r = (6 + ((Date.now() % 500)/500) * 3) / view.scale; // Parpadeo más rápido para indicar punto activo
                            ctx.arc(p.x, p.y, r, 0, Math.PI*2); 
                            ctx.fill();
                            // Indicador de "Último Punto"
                            ctx.fillStyle = "#fff";
                            ctx.font = `bold ${12/view.scale}px Arial`;
                            ctx.fillText("FIN", p.x + 10/view.scale, p.y);
                        } else { 
                            ctx.fillStyle = '#ffffff'; 
                            ctx.arc(p.x, p.y, 4 / view.scale, 0, Math.PI*2); 
                            ctx.fill();
                        } 
                    }); 
                    ctx.restore();
                }
                
                // INDICADOR DE ORIGEN (MOVIMIENTO DE PISTA)
                if (isCircuitMoveMode) { 
                    ctx.save(); 
                    ctx.translate(cx, cy); 
                    // Cruz más visible y grande
                    ctx.strokeStyle = '#22d3ee'; // Cian brillante
                    ctx.lineWidth = 3; 
                    ctx.shadowColor = '#22d3ee';
                    ctx.shadowBlur = 10;
                    const axisLen = 30; // Más larga
                    ctx.beginPath(); 
                    ctx.moveTo(-axisLen, 0); ctx.lineTo(axisLen, 0); 
                    ctx.moveTo(0, -axisLen); ctx.lineTo(0, axisLen); 
                    ctx.stroke(); 
                    
                    // Círculo central
                    ctx.fillStyle = '#22d3ee';
                    ctx.beginPath(); ctx.arc(0,0, 4, 0, Math.PI*2); ctx.fill();

                    ctx.fillStyle = '#fff'; 
                    ctx.font = 'bold 14px monospace'; 
                    ctx.fillText("ORIGEN PISTA", 8, -8); 
                    ctx.restore(); 
                }

                pieces.forEach((p, index) => {
                    newPiecePositions.push({ uid: p.uid, x: cx, y: cy }); ctx.save(); ctx.translate(cx, cy); ctx.rotate(angle); if (p.invert) ctx.rotate(Math.PI);
                    if (p.uid === selectedPieceId) { ctx.shadowColor = brand.neonColor; ctx.shadowBlur = 30; }
                    const s = view.scale, w = brand.width * s, hw = w / 2, l = p.length * s, laneOff = (brand.laneSpacing / 2) * s, laneSpacing = brand.laneSpacing * s;
                    if (p.customImage && imageCache.current.get(p.uid)) { const img = imageCache.current.get(p.uid); if (p.type === 'straight' || p.type.includes('pit')) ctx.drawImage(img, 0, -hw, l, w); else { const r = p.radius * s; ctx.translate(0, p.direction==='left'?-r:-r); ctx.drawImage(img, 0, p.direction==='left'?0:-r, r, r); } } 
                    else {
                       ctx.lineCap = 'butt'; ctx.lineJoin = 'round';
                       if (p.type === 'straight') {
                            if (['digital_x', 'change_right', 'change_left'].includes(p.subtype)) {
                                ctx.fillStyle = brand.trackColor; ctx.fillRect(0, -hw, l, w); ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.strokeRect(0, -hw, l, w); DrawEngine2D.drawRails(ctx, l, laneOff, brand); ctx.strokeStyle = brand.railColor; ctx.lineWidth = 2.5; ctx.beginPath();
                                if (p.subtype !== 'change_left') { ctx.moveTo(0, -laneOff); ctx.bezierCurveTo(l*0.4, -laneOff, l*0.6, laneOff, l, laneOff); } if (p.subtype !== 'change_right') { ctx.moveTo(0, laneOff); ctx.bezierCurveTo(l*0.4, laneOff, l*0.6, -laneOff, l, -laneOff); } ctx.stroke();
                                if (p.subtype !== 'change_left') DrawEngine2D.drawDigitalWedge(ctx, l, -laneOff, 1, s); if (p.subtype !== 'change_right') DrawEngine2D.drawDigitalWedge(ctx, l, laneOff, -1, s);
                            } else if (p.subtype && p.subtype.includes('single_lane')) {
                                const isLane1 = p.subtype === 'single_lane_1';
                                const yStart = isLane1 ? -hw : 0;
                                const yEnd = isLane1 ? 0 : hw;
                                const railY = isLane1 ? -laneOff : laneOff;
                                ctx.fillStyle = brand.trackColor; 
                                ctx.fillRect(0, yStart, l, hw); 
                                ctx.strokeStyle = '#222'; 
                                ctx.strokeRect(0, yStart, l, hw);
                                ctx.strokeStyle = brand.railColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, railY); ctx.lineTo(l, railY); ctx.stroke();
                                ctx.strokeStyle = brand.slotColor; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, railY); ctx.lineTo(l, railY); ctx.stroke();
                            } else if (p.subtype && p.subtype.includes('pit_parallel')) {
                                const pitW = w/2 + 2*s; const pitY = laneOff + laneSpacing; ctx.fillStyle = brand.trackColor; ctx.fillRect(0, -hw, l, w); ctx.fillRect(0, pitY - pitW/2, l, pitW); ctx.strokeStyle = '#222'; ctx.strokeRect(0, -hw, l, w); ctx.strokeRect(0, pitY - pitW/2, l, pitW);
                                if (p.subtype === 'pit_parallel' || p.subtype === 'pit_parallel_double_x') { const boxMargin = 4 * (s/5); DrawEngine2D.drawHazardZone(ctx, (c) => { c.rect(boxMargin, pitY - pitW/2 + boxMargin, l - boxMargin*2, pitW - boxMargin*2); }, s); ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(boxMargin, pitY - pitW/2 + boxMargin, l - boxMargin*2, pitW - boxMargin*2); ctx.strokeStyle = '#facc15'; ctx.strokeRect(boxMargin, pitY - pitW/2 + boxMargin, l - boxMargin*2, pitW - boxMargin*2); ctx.fillStyle = '#fff'; ctx.font = `bold ${10 * (s/5)}px Arial`; ctx.textAlign = "center"; ctx.fillText("BOXES", l/2, pitY); }
                                if (p.subtype === 'pit_parallel_double_x') { ctx.strokeStyle = brand.railColor; ctx.lineWidth = 2.5; ctx.beginPath(); ctx.moveTo(0, -laneOff); ctx.bezierCurveTo(l*0.4, -laneOff, l*0.6, laneOff, l, laneOff); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, laneOff); ctx.bezierCurveTo(l*0.4, laneOff, l*0.6, -laneOff, l, -laneOff); ctx.stroke(); DrawEngine2D.drawDigitalWedge(ctx, l, -laneOff, 1, s); DrawEngine2D.drawDigitalWedge(ctx, l, laneOff, -1, s); }
                                DrawEngine2D.drawRails(ctx, l, laneOff, brand); ctx.strokeStyle = brand.railColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, pitY); ctx.lineTo(l, pitY); ctx.stroke(); ctx.strokeStyle = brand.slotColor; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, pitY); ctx.lineTo(l, pitY); ctx.stroke();
                            } else if (p.subtype === 'starting_grid') {
                                ctx.fillStyle = brand.trackColor; ctx.fillRect(0, -hw, l, w); ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.strokeRect(0, -hw, l, w); DrawEngine2D.drawRails(ctx, l, laneOff, brand); ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2.5; const boxLen = 14 * (s/5); const boxWid = laneOff * 1.2; 
                                const p1X = l * 0.7; const p1Y = -laneOff; ctx.beginPath(); ctx.moveTo(p1X - boxLen, p1Y - boxWid/2); ctx.lineTo(p1X, p1Y - boxWid/2); ctx.lineTo(p1X, p1Y + boxWid/2); ctx.lineTo(p1X - boxLen, p1Y + boxWid/2); ctx.stroke();
                                const p2X = l * 0.3; const p2Y = laneOff; ctx.beginPath(); ctx.moveTo(p2X - boxLen, p2Y - boxWid/2); ctx.lineTo(p2X, p2Y - boxWid/2); ctx.lineTo(p2X, p2Y + boxWid/2); ctx.lineTo(p2X - boxLen, p2Y + boxWid/2); ctx.stroke();
                            } else if (p.subtype === 'digital_console') {
                                ctx.fillStyle = brand.trackColor; ctx.fillRect(0, -hw, l, w); ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.strokeRect(0, -hw, l, w); DrawEngine2D.drawRails(ctx, l, laneOff, brand); const consoleH = w * 0.65; const consoleY = hw; ctx.fillStyle = '#b91c1c'; ctx.beginPath(); if (ctx.roundRect) { ctx.roundRect(l*0.1, consoleY, l*0.8, consoleH, 15 * (s/5)); } else { ctx.rect(l*0.1, consoleY, l*0.8, consoleH); } ctx.fill(); ctx.strokeStyle = '#7f1d1d'; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = '#000'; ctx.beginPath(); if (ctx.roundRect) { ctx.roundRect(l*0.2, consoleY + 8*(s/5), l*0.6, consoleH*0.55, 4*(s/5)); } else { ctx.rect(l*0.2, consoleY + 8*(s/5), l*0.6, consoleH*0.55); } ctx.fill(); ctx.fillStyle = '#4ade80'; ctx.font = `bold ${9*(s/5)}px monospace`; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText("00:00", l/2, consoleY + consoleH*0.35); ctx.fillStyle = '#ffcccc'; ctx.font = `bold ${6*(s/5)}px Arial`; ctx.fillText("NINCO", l/2, consoleY + consoleH*0.8);
                            } else if (p.subtype === 'crossing') {
                                ctx.fillStyle = brand.trackColor; ctx.fillRect(0, -hw, l, w); ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.strokeRect(0, -hw, l, w); ctx.strokeStyle = brand.railColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, -laneOff); ctx.bezierCurveTo(l*0.4, -laneOff, l*0.6, laneOff, l, laneOff); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, laneOff); ctx.bezierCurveTo(l*0.4, laneOff, l*0.6, -laneOff, l, -laneOff); ctx.stroke(); ctx.strokeStyle = brand.slotColor; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, -laneOff); ctx.bezierCurveTo(l*0.4, -laneOff, l*0.6, laneOff, l, laneOff); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, laneOff); ctx.bezierCurveTo(l*0.4, laneOff, l*0.6, -laneOff, l, -laneOff); ctx.stroke();
                            } else if (p.subtype === 'chicane_entry') {
                                ctx.fillStyle = brand.trackColor; ctx.fillRect(0, -hw, l, w); ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.strokeRect(0, -hw, l, w); const narrowLane = laneOff * 0.2; ctx.strokeStyle = brand.railColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, -laneOff); ctx.bezierCurveTo(l*0.5, -laneOff, l*0.5, -narrowLane, l, -narrowLane); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, laneOff); ctx.bezierCurveTo(l*0.5, laneOff, l*0.5, narrowLane, l, narrowLane); ctx.stroke(); ctx.strokeStyle = brand.slotColor; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, -laneOff); ctx.bezierCurveTo(l*0.5, -laneOff, l*0.5, -narrowLane, l, -narrowLane); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, laneOff); ctx.bezierCurveTo(l*0.5, laneOff, l*0.5, narrowLane, l, narrowLane); ctx.stroke();
                            } else if (p.subtype === 'chicane_middle') {
                                ctx.fillStyle = brand.trackColor; ctx.fillRect(0, -hw, l, w); ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.strokeRect(0, -hw, l, w); const narrowLane = laneOff * 0.2; DrawEngine2D.drawRails(ctx, l, narrowLane, brand);
                            } else if (p.subtype === 'chicane_exit') {
                                ctx.fillStyle = brand.trackColor; ctx.fillRect(0, -hw, l, w); ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.strokeRect(0, -hw, l, w); const narrowLane = laneOff * 0.2; ctx.strokeStyle = brand.railColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, -narrowLane); ctx.bezierCurveTo(l*0.5, -narrowLane, l*0.5, -laneOff, l, -laneOff); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, narrowLane); ctx.bezierCurveTo(l*0.5, narrowLane, l*0.5, laneOff, l, laneOff); ctx.stroke(); ctx.strokeStyle = brand.slotColor; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, -narrowLane); ctx.bezierCurveTo(l*0.5, -narrowLane, l*0.5, -laneOff, l, -laneOff); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, narrowLane); ctx.bezierCurveTo(l*0.5, narrowLane, l*0.5, laneOff, l, laneOff); ctx.stroke();
                            } else {
                                ctx.fillStyle = brand.trackColor; ctx.fillRect(0, -hw, l, w); ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.strokeRect(0, -hw, l, w); if (p.subtype === 'analog_connect') { DrawEngine2D.drawRails(ctx, l, laneOff, brand); const boxW = l * 0.3; const boxH = w * 0.3; const boxX = (l - boxW) / 2; const boxY = hw; ctx.fillStyle = brand.connectionBoxColor || '#ef4444'; ctx.fillRect(boxX, boxY, boxW, boxH); ctx.strokeStyle = '#222'; ctx.strokeRect(boxX, boxY, boxW, boxH); ctx.fillStyle = '#ffffff'; ctx.font = `bold ${8 * (s/5)}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(brand.name, l/2, boxY + boxH/2); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.setLineDash([10, 10]); ctx.beginPath(); ctx.moveTo(l/2, -hw); ctx.lineTo(l/2, hw); ctx.stroke(); ctx.setLineDash([]); } else if (p.subtype === 'connection') { DrawEngine2D.drawRails(ctx, l, laneOff, brand); const boxW = l * 0.25; const boxH = w * 0.4; const boxX = (l - boxW) / 2; const boxY = hw; ctx.fillStyle = '#111'; ctx.fillRect(boxX, boxY, boxW, boxH); ctx.strokeStyle = '#333'; ctx.strokeRect(boxX, boxY, boxW, boxH); ctx.fillStyle = '#3b82f6'; ctx.beginPath(); ctx.arc(l/2, boxY + boxH/2, boxH*0.3, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.5; const cx = l/2, cy = boxY + boxH/2, r = boxH*0.15; ctx.beginPath(); ctx.moveTo(cx-r/2, cy-r); ctx.lineTo(cx+r/2, cy); ctx.lineTo(cx-r/2, cy+r); ctx.moveTo(cx+r/2, cy-r); ctx.lineTo(cx-r/2, cy+r); ctx.moveTo(cx, cy-r*1.2); ctx.lineTo(cx, cy+r*1.2); ctx.stroke(); ctx.fillStyle = '#fff'; ctx.font = `bold ${6 * (s/5)}px Arial`; ctx.textAlign = 'center'; ctx.fillText("CONEXIÓN", l/2, boxY + boxH * 0.85); } else { DrawEngine2D.drawRails(ctx, l, laneOff, brand); }
                            }
                       } else if (p.type === 'pit_entry') {
                            const pitY = laneOff + laneSpacing; ctx.fillStyle = brand.trackColor; ctx.beginPath(); ctx.moveTo(0, -hw); ctx.lineTo(l, -hw); ctx.lineTo(l, hw); ctx.lineTo(l, pitY + (w/2 * 0.6)); ctx.bezierCurveTo(l*0.5, pitY, l*0.3, hw, 0, hw); ctx.fill(); ctx.strokeStyle = '#222'; ctx.stroke(); DrawEngine2D.drawHazardZone(ctx, (c) => { c.beginPath(); c.moveTo(l, hw); c.lineTo(l, pitY + (w/2 * 0.6)); c.bezierCurveTo(l*0.5, pitY, l*0.3, hw, 0, hw); c.closePath(); }, s); DrawEngine2D.drawRails(ctx, l, laneOff, brand); ctx.strokeStyle = brand.railColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, laneOff); ctx.bezierCurveTo(l*0.3, laneOff, l*0.6, pitY, l, pitY); ctx.stroke(); ctx.strokeStyle = brand.slotColor; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, laneOff); ctx.bezierCurveTo(l*0.3, laneOff, l*0.6, pitY, l, pitY); ctx.stroke(); ctx.fillStyle = '#333'; ctx.beginPath(); ctx.moveTo(l*0.2, laneOff); ctx.lineTo(l*0.25, laneOff+5); ctx.lineTo(l*0.25, laneOff-5); ctx.fill();
                       } else if (p.type === 'pit_exit') {
                            const pitY = laneOff + laneSpacing; const pitBottom = pitY + (w/2 * 0.6); ctx.fillStyle = brand.trackColor; ctx.beginPath(); ctx.moveTo(0, -hw); ctx.lineTo(l, -hw); ctx.lineTo(l, hw); ctx.bezierCurveTo(l*0.7, hw, l*0.5, pitY, 0, pitBottom); ctx.lineTo(0, -hw); ctx.fill(); ctx.strokeStyle = '#222'; ctx.stroke(); DrawEngine2D.drawHazardZone(ctx, (c) => { c.beginPath(); c.moveTo(0, hw); c.lineTo(l, hw); c.bezierCurveTo(l*0.7, hw, l*0.5, pitY, 0, pitBottom); c.closePath(); }, s); DrawEngine2D.drawRails(ctx, l, laneOff, brand); ctx.strokeStyle = brand.railColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, pitY); ctx.bezierCurveTo(l*0.4, pitY, l*0.7, laneOff, l, laneOff); ctx.stroke(); ctx.strokeStyle = brand.slotColor; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, pitY); ctx.bezierCurveTo(l*0.4, pitY, l*0.7, laneOff, l, laneOff); ctx.stroke();
                       } else if (p.type === 'curve') {
                           const r = p.radius * s, isLeft = p.direction === 'left', startA = isLeft ? Math.PI/2 : -Math.PI/2, sweep = (p.angle * Math.PI / 180) * (isLeft ? -1 : 1); 
                           
                           // RENDERIZADO ESPECIAL PARA ROTONDA 3DP (HobbyClassic)
                           if (p.subtype === 'rotonda') {
                               const straightLen = 10.0 * s; // Longitud de la recta añadida
                               const loopRadius = r; 
                               const loopCenterX = r * 1.3; 
                               const singleTrackWidth = (brand.width / 2) * s; 

                               // DIBUJAR RECTA DE ENTRADA/SALIDA (Base del módulo)
                               // Al ser una rotonda que retorna, dibujamos un bloque rectangular previo al loop
                               ctx.fillStyle = brand.trackColor;
                               ctx.fillRect(0, -hw, straightLen, w);
                               ctx.strokeStyle = '#222';
                               ctx.lineWidth = 1;
                               ctx.strokeRect(0, -hw, straightLen, w);
                               
                               // Raíles de la recta
                               DrawEngine2D.drawRails(ctx, straightLen, laneOff, brand);

                               // DESPLAZAR EL LOOP AL FINAL DE LA RECTA
                               ctx.save();
                               ctx.translate(straightLen, 0);

                               // 0. RELLENO INTERIOR (ISLA GRIS)
                               ctx.save();
                               const innerRadius = loopRadius - (singleTrackWidth / 2) - (1 * s); 
                               
                               ctx.beginPath();
                               ctx.moveTo(0, 0); 
                               
                               // Trazamos el contorno interior (Isla)
                               const innerCtrl = loopCenterX * 0.35;
                               ctx.bezierCurveTo(innerCtrl, 0, innerCtrl, -innerRadius, loopCenterX, -innerRadius);
                               ctx.arc(loopCenterX, 0, innerRadius, -Math.PI/2, Math.PI/2, false);
                               ctx.bezierCurveTo(innerCtrl, innerRadius, innerCtrl, 0, 0, 0);
                               ctx.closePath();
                               ctx.clip();

                               // 1. Fondo Gris (Estilo Cemento/Hormigón)
                               ctx.fillStyle = '#64748b'; 
                               ctx.fill();

                               // Borde sutil para la isla
                               ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                               ctx.lineWidth = 1;
                               ctx.stroke();
                               ctx.restore();

                               const defineLoopPath = (ctx) => {
                                   ctx.beginPath();
                                   ctx.moveTo(0, -laneOff);
                                   const controlX = loopCenterX * 0.4;
                                   ctx.bezierCurveTo(controlX, -laneOff, controlX, -loopRadius, loopCenterX, -loopRadius);
                                   ctx.arc(loopCenterX, 0, loopRadius, -Math.PI/2, Math.PI/2, false);
                                   ctx.bezierCurveTo(controlX, loopRadius, controlX, laneOff, 0, laneOff);
                               };

                               // 1. ASFALTO (Estilo NINCO estándar)
                               ctx.lineCap = 'butt';
                               ctx.lineJoin = 'round';
                               
                               // Borde exterior
                               ctx.strokeStyle = '#222'; 
                               ctx.lineWidth = singleTrackWidth + (2 * s); 
                               defineLoopPath(ctx);
                               ctx.stroke();

                               // Superficie de rodadura (Color de la marca, ej: Ninco)
                               ctx.strokeStyle = brand.trackColor; 
                               ctx.lineWidth = singleTrackWidth;
                               defineLoopPath(ctx);
                               ctx.stroke();

                               // Texto discreto
                               ctx.save();
                               ctx.fillStyle = 'rgba(255,255,255,0.2)';
                               ctx.font = `bold ${5 * (s/5)}px Arial`;
                               ctx.textAlign = 'center';
                               ctx.textBaseline = 'middle';
                               ctx.fillText("HC +10", loopCenterX, 0);
                               ctx.restore();

                               // 2. RIELES (Estilo estándar limpio)
                               // Rail metálico sólido (sin discontinuas)
                               ctx.strokeStyle = brand.railColor; 
                               ctx.lineWidth = 3;
                               ctx.setLineDash([]); 
                               defineLoopPath(ctx);
                               ctx.stroke();

                               // Slot negro central
                               ctx.strokeStyle = brand.slotColor; 
                               ctx.lineWidth = 1;
                               defineLoopPath(ctx);
                               ctx.stroke();
                               
                               ctx.restore(); // Restaurar translación del loop

                           } else {
                               // RENDERIZADO CURVA ESTÁNDAR
                               ctx.strokeStyle = brand.trackColor; ctx.lineWidth = w; ctx.beginPath(); ctx.arc(0, isLeft ? -r : r, r, startA, startA + sweep, isLeft); ctx.stroke(); 
                               if (p.subtype === 'ice') { ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = w; ctx.stroke(); } 
                               ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0, isLeft ? -r : r, r - hw, startA, startA + sweep, isLeft); ctx.stroke(); ctx.beginPath(); ctx.arc(0, isLeft ? -r : r, r + hw, startA, startA + sweep, isLeft); ctx.stroke(); 
                               ctx.strokeStyle = brand.railColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, isLeft ? -r : r, r-laneOff, startA, startA + sweep, isLeft); ctx.stroke(); ctx.beginPath(); ctx.arc(0, isLeft ? -r : r, r+laneOff, startA, startA + sweep, isLeft); ctx.stroke(); ctx.strokeStyle = brand.slotColor; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0, isLeft ? -r : r, r-laneOff, startA, startA + sweep, isLeft); ctx.stroke(); ctx.beginPath(); ctx.arc(0, isLeft ? -r : r, r+laneOff, startA, startA + sweep, isLeft); ctx.stroke();
                           }
                       }
                    }
                    if (index === 0) { ctx.fillStyle = brand.neonColor; ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI*2); ctx.fill(); } ctx.shadowBlur = 0; 
                    
                    let dx = 0, dy = 0, dAngle = 0; 
                    
                    if (p.subtype === 'rotonda') {
                        dx = 0;
                        dy = 0;
                        dAngle = Math.PI; 
                    } else if (p.type === 'straight' || p.type.includes('pit')) { 
                        dx = p.length * view.scale; 
                    } else if (p.type === 'curve') { 
                        const r = p.radius * view.scale, aRad = (p.angle * Math.PI) / 180; 
                        if (p.direction === 'left') { dx = r * Math.sin(aRad); dy = -r * (1 - Math.cos(aRad)); dAngle = -aRad; } 
                        else { dx = r * Math.sin(aRad); dy = r * (1 - Math.cos(aRad)); dAngle = aRad; } 
                    } 
                    if (p.invert && p.subtype !== 'rotonda') { dx = -dx; dy = -dy; } 
                    ctx.restore(); 
                    const cos = Math.cos(angle), sin = Math.sin(angle); cx += dx * cos - dy * sin; cy += dx * sin + dy * cos; angle += dAngle;
                });
                return newPiecePositions;
            }
        };

        const Telemetry3DViewer = ({ circuitData, carSettings, customCarAssets, onClose }) => {
            const containerRef = useRef(null);
            const isMountedRef = useRef(true);
            const [paused, setPaused] = useState(false);
            const [showSaveMenu, setShowSaveMenu] = useState(false); 
            
            // MODIFICADO: Inicializar en FALSE para que el Modo Preparación (Grid) sea siempre Analógico al entrar
            const [laneChangeActive, setLaneChangeActive] = useState(false); 
            
            const [raceState, setRaceState] = useState('grid'); 
            const [winnerId, setWinnerId] = useState(null); 
            const [activeLights, setActiveLights] = useState(0); 
            const [elapsedTime, setElapsedTime] = useState(0);
            const [targetLaps, setTargetLaps] = useState(10);
            const [validationError, setValidationError] = useState(null);
            const [trackVoltage, setTrackVoltage] = useState(12.0);
            const [activeButton, setActiveButton] = useState('GRID');
            const [bridgeStrategy, setBridgeStrategy] = useState('smart'); 
            const [telemetryPos, setTelemetryPos] = useState({ x: 360, y: window.innerHeight - 200 });
            const [isDraggingTelemetry, setIsDraggingTelemetry] = useState(false);
            const dragStartPos = useRef({ x: 0, y: 0 });
            const dragItemStartPos = useRef({ x: 0, y: 0 });

            // DETECCIÓN DE ROTONDA Y LÓGICA MONOCOCHE
            const hasRotonda = circuitData.pieces.some(p => p.subtype === 'rotonda');
            const MAX_CARS = 8;
            
            // ESTADO DE COCHES ACTIVOS: 1 para Rotonda, 2 por defecto
            const [activeCarCount, setActiveCarCount] = useState(hasRotonda ? 1 : 2);
            const activeCarCountRef = useRef(activeCarCount);
            useEffect(() => { activeCarCountRef.current = activeCarCount; }, [activeCarCount]);

            // REFERENCIA PARA INPUT DE CARGA
            const loadInputRef = useRef(null);
            
            // REF PARA BOTÓN ACTIVO (USADO EN BUCLE DE ANIMACIÓN)
            const activeButtonRef = useRef(activeButton);
            useEffect(() => { activeButtonRef.current = activeButton; }, [activeButton]);

            const saveCarConfig = (id) => {
                const config = carSetups[id];
                const carTelemetry = telemetry.find(t => t.id === id) || {};
                
                const fullData = {
                    timestamp: new Date().toISOString(),
                    driverId: id,
                    setup: config,
                    telemetry: {
                        laps: carTelemetry.laps,
                        lastLapTime: carTelemetry.lastLap,
                        bestLapTime: carTelemetry.bestLap,
                        averageLapTime: carTelemetry.averageLap,
                        currentSpeed: carTelemetry.speed,
                        averageSpeed: carTelemetry.avgSpeed,
                        position: carTelemetry.position
                    }
                };

                const blob = new Blob([JSON.stringify(fullData, null, 2)], { type: "application/json" });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `telemetria_piloto_${id}_${new Date().toISOString().slice(0,10)}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };

            const handleLoadConfig = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        if (data.setup) {
                            // Aplicar configuración al coche seleccionado actualmente
                            setCarSetups(prev => ({
                                ...prev,
                                [selectedCarId]: { ...prev[selectedCarId], ...data.setup }
                            }));
                            // Opcional: Si el archivo tiene historial de telemetría, podríamos cargarlo, 
                            // pero por ahora solo cargamos el setup mecánico.
                        } else {
                            alert("El archivo no contiene una configuración válida.");
                        }
                    } catch (err) {
                        console.error("Error al leer el archivo", err);
                        alert("Error al leer el archivo de configuración.");
                    }
                };
                reader.readAsText(file);
                e.target.value = ''; // Resetear input
            };

            const handleTelemetryDragStart = (e) => { e.stopPropagation(); e.target.setPointerCapture(e.pointerId); setIsDraggingTelemetry(true); dragStartPos.current = { x: e.clientX, y: e.clientY }; dragItemStartPos.current = { ...telemetryPos }; };
            const handleTelemetryDragMove = (e) => { if (!isDraggingTelemetry) return; e.stopPropagation(); const dx = e.clientX - dragStartPos.current.x; const dy = e.clientY - dragStartPos.current.y; setTelemetryPos({ x: dragItemStartPos.current.x + dx, y: dragItemStartPos.current.y + dy }); };
            const handleTelemetryDragUp = (e) => { if (isDraggingTelemetry) { e.target.releasePointerCapture(e.pointerId); setIsDraggingTelemetry(false); } };
            useEffect(() => { const handleResize = () => { setTelemetryPos(prev => ({ ...prev, y: Math.min(prev.y, window.innerHeight - 150) })); }; window.addEventListener('resize', handleResize); return () => window.removeEventListener('resize', handleResize); }, []);

            const [selectedCarId, setSelectedCarId] = useState(1); 
            
            // ACTUALIZADO: Inicialización dinámica para 8 coches
            const [carSetups, setCarSetups] = useState(() => {
                const setups = {};
                for (let i = 1; i <= 8; i++) {
                    setups[i] = { 
                        motorRPM: 20000, 
                        motorTorque: 240, 
                        motorName: 'Standard 20k', 
                        tireGrip: 80, 
                        tireName: 'Slick Std', 
                        gearTeeth: 27, 
                        pinionTeeth: 9, 
                        gearRatio: 3.0, 
                        weight: 85 
                    };
                }
                return setups;
            });

            // GESTIÓN DE CAMBIO DE NÚMERO DE PILOTOS
            const updateActiveCars = (newCount) => {
                const count = Math.max(1, Math.min(8, newCount));
                setActiveCarCount(count);
                // Al cambiar el número total, seleccionamos el último coche añadido (o el máximo actual) para configurar
                setSelectedCarId(count);
            };

            const handleUpdateConfig = (type, value) => { setCarSetups(prev => { const newSetup = { ...prev[selectedCarId] }; if (type === 'motor') { newSetup.motorRPM = parseInt(value.rpm.replace('.','')); newSetup.motorTorque = parseInt(value.torque); newSetup.motorName = value.label; } else if (type === 'tire') { newSetup.tireGrip = value.grip; newSetup.tireName = value.label; } else if (type === 'gear') { newSetup.gearTeeth = parseInt(value.teeth); newSetup.gearRatio = newSetup.gearTeeth / newSetup.pinionTeeth; } else if (type === 'pinion') { newSetup.pinionTeeth = parseInt(value.teeth); newSetup.gearRatio = newSetup.gearTeeth / newSetup.pinionTeeth; } else if (type === 'weight') { newSetup.weight = value; } return { ...prev, [selectedCarId]: newSetup }; }); };
            const carAssetsRef = useRef(customCarAssets); useEffect(() => { carAssetsRef.current = customCarAssets; }, [customCarAssets]);
            const targetLapsRef = useRef(10); useEffect(() => { targetLapsRef.current = targetLaps; }, [targetLaps]);
            
            // Inicializar telemetría para MAX_CARS
            const [telemetry, setTelemetry] = useState(Array(MAX_CARS).fill(null).map((_, i) => ({ id: i + 1, speed: 0, lastLap: 0, bestLap: 0, averageLap: 0, currentLap: 0, laps: 0, position: i + 1 })));
            
            const audioCtxRef = useRef(null); const timerIntervalRef = useRef(null); const pieceMapRef = useRef([]); const lastUIUpdate = useRef(0); 
            
            // NUEVO: Función para formatear tiempo (MM:SS:mmm)
            const formatTime = (ms) => {
                const min = Math.floor(ms / 60000);
                const sec = Math.floor((ms % 60000) / 1000);
                const mil = ms % 1000;
                return `${min.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}:${mil.toString().padStart(3, '0')}`;
            };

            const playRaceSound = (type) => { try { const AudioContext = window.AudioContext || window.webkitAudioContext; if (!audioCtxRef.current) audioCtxRef.current = new AudioContext(); if (audioCtxRef.current.state === 'suspended') audioCtxRef.current.resume(); const ctx = audioCtxRef.current; const t = ctx.currentTime; const masterGain = ctx.createGain(); masterGain.connect(ctx.destination); masterGain.gain.value = 0.6; if (type === 'red') { const osc1 = ctx.createOscillator(); osc1.type = 'square'; osc1.frequency.setValueAtTime(750, t); const osc2 = ctx.createOscillator(); osc2.type = 'square'; osc2.frequency.setValueAtTime(765, t); const gain = ctx.createGain(); gain.gain.setValueAtTime(0.0, t); gain.gain.linearRampToValueAtTime(0.3, t + 0.02); gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15); osc1.connect(gain); osc2.connect(gain); gain.connect(masterGain); osc1.start(t); osc1.stop(t + 0.15); osc2.start(t); osc2.stop(t + 0.15); } else if (type === 'green') { const notes = [110, 220, 277.18, 329.63, 440, 554.37]; notes.forEach((freq, i) => { [ -4, 4 ].forEach(detune => { const osc = ctx.createOscillator(); const gain = ctx.createGain(); osc.type = 'sawtooth'; osc.frequency.setValueAtTime(freq, t); osc.detune.value = detune; gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(0.1 / (i*0.5 + 1), t + 0.08); gain.gain.exponentialRampToValueAtTime(0.001, t + 3.5); osc.connect(gain); gain.connect(masterGain); osc.start(t); osc.stop(t + 3.5); }); }); const timpaniOsc = ctx.createOscillator(); const timpaniGain = ctx.createGain(); timpaniOsc.type = 'triangle'; timpaniOsc.frequency.setValueAtTime(90, t); timpaniOsc.frequency.exponentialRampToValueAtTime(40, t + 0.3); timpaniGain.gain.setValueAtTime(0, t); timpaniGain.gain.linearRampToValueAtTime(0.8, t + 0.02); timpaniGain.gain.exponentialRampToValueAtTime(0.001, t + 1.5); timpaniOsc.connect(timpaniGain); timpaniGain.connect(masterGain); timpaniOsc.start(t); timpaniOsc.stop(t + 1.5); } } catch (e) { console.error("Audio error", e); } };
            
            // MODIFICADO: Secuencia de salida adaptable (Test Drive vs Carrera)
            const startRaceSequence = () => { 
                if (raceState === 'grid') { 
                    setRaceState('countdown'); 
                    let currentLight = 1; 
                    const sequenceInterval = setInterval(() => { 
                        if (currentLight <= 5) { 
                            setActiveLights(currentLight); 
                            playRaceSound('red'); 
                            currentLight++; 
                        } else { 
                            clearInterval(sequenceInterval); 
                            setTimeout(() => { 
                                // LÓGICA IMPORTANTE:
                                // Si estamos en 'GRID' (Preparación), pasamos a 'idle' (Modo Test/Pruebas Infinitas).
                                // Si fuese una carrera competitiva, pasaríamos a 'racing'.
                                const nextState = activeButton === 'GRID' ? 'idle' : 'racing';
                                setRaceState(nextState); 
                                setActiveLights(0); 
                                playRaceSound('green'); 
                                
                                const startTime = Date.now(); 
                                physicsState.current.forEach(c => { 
                                    c.lapStartTime = startTime; 
                                    // En modo TEST (idle), las vueltas empiezan en 0 y suman.
                                    // En modo CARRERA (racing), empiezan en targetLaps y restan.
                                    c.laps = nextState === 'idle' ? 0 : targetLapsRef.current; 
                                    c.lastLapTime = 0; 
                                    c.totalLapTime = 0; 
                                    c.completedLaps = 0; 
                                }); 
                                
                                if (timerIntervalRef.current) clearInterval(timerIntervalRef.current); 
                                timerIntervalRef.current = setInterval(() => { 
                                    setElapsedTime(Date.now() - startTime); 
                                }, 37); 
                                setPaused(false); 
                            }, Math.random() * 1000 + 500); 
                        } 
                    }, 1000); 
                } else { 
                    setPaused(false); 
                } 
            };

            const handleStartClick = () => { if (activeButton === 'GRID' && raceState === 'grid') { startRaceSequence(); } else { setPaused(false); } };
            const checkRaceRequirements = () => { if (!circuitData || !circuitData.pieces) return "Error: Datos del circuito no válidos."; const hasGrid = circuitData.pieces.some(p => p.subtype === 'starting_grid'); const hasConnection = circuitData.pieces.some(p => p.subtype === 'analog_connect' || p.subtype === 'connection' || p.subtype === 'digital_console'); if (!hasGrid && !hasConnection) return "Faltan: Parrilla de Salida y Pista de Conexiones"; if (!hasGrid) return "Falta: Parrilla de Salida"; if (!hasConnection) return "Falta: Pista de Conexiones"; return null; };
            
            const handleStopRace = () => {
                setPaused(false);
                onClose(); // Cierra el visor 3D y vuelve al editor 2D
            };

            const LANE_1 = 0; const LANE_2 = 1; const LANE_PIT = 99;
            // Inicializar estado físico para MAX_CARS (8)
            const physicsState = useRef(Array(MAX_CARS).fill(null).map((_, i) => { const lane = i % 2 === 0 ? LANE_1 : LANE_2; const startOffset = -15 * Math.floor(i / 2); return { id: i + 1, color: parseInt(carSettings[i].color.replace('#','0x')), currentLane: lane, targetLane: lane, isChanging: false, changeProgress: 0, distance: startOffset, speed: 0, lastPieceIndex: -1, lapStartTime: 0, lastLapTime: 0, bestLapTime: Infinity, laps: 0, totalLapTime: 0, completedLaps: 0, isDerailled: false, derailTime: 0, velocity: new THREE.Vector3(0,0,0), worldPos: new THREE.Vector3(0,0,0), recoverTime: 0, invulnerableUntil: 0 }; }));
            const [leaderLaps, setLeaderLaps] = useState(10); const [racePositions, setRacePositions] = useState([1, 2]); const [globalFastestLap, setGlobalFastestLap] = useState(Infinity);
            const pausedRef = useRef(false); const laneActiveRef = useRef(false); const raceStateRef = useRef('idle'); const clock = useRef(new THREE.Clock()); const carSetupsRef = useRef(carSetups);
            useEffect(() => { carSetupsRef.current = carSetups; }, [carSetups]); useEffect(() => { pausedRef.current = paused; }, [paused]); useEffect(() => { laneActiveRef.current = laneChangeActive; }, [laneChangeActive]); useEffect(() => { raceStateRef.current = raceState; }, [raceState]);

            const enterGridMode = () => { 
                const error = checkRaceRequirements(); if (error) { setValidationError(error); setTimeout(() => setValidationError(null), 4000); return; } const gridPiece = pieceMapRef.current.find(p => p.subtype === 'starting_grid'); const gridStartPos = gridPiece ? gridPiece.distStart : 0; setRaceState('grid'); setWinnerId(null); setActiveLights(0); setElapsedTime(0); setActiveButton('GRID'); if (timerIntervalRef.current) clearInterval(timerIntervalRef.current); 
                
                // MODO PREPARACIÓN (GRID): SIEMPRE ANALÓGICO
                setLaneChangeActive(false);

                if (!hasRotonda) setActiveCarCount(2); // Vuelve a 2 coches por defecto
                physicsState.current.forEach((car, i) => { const gridOffset = -12 * Math.floor(i / 2); car.distance = gridStartPos + gridOffset; car.speed = 0; car.isChanging = false; car.currentLane = i % 2 === 0 ? LANE_1 : LANE_2; car.targetLane = car.currentLane; car.laps = targetLaps; car.lapStartTime = 0; car.lastLapTime = 0; car.totalLapTime = 0; car.completedLaps = 0; car.isDerailled = false; car.velocity.set(0,0,0); }); setPaused(false); 
            };
            const startPracticeMode = () => { 
                setRaceState('idle'); setWinnerId(null); setActiveLights(0); setElapsedTime(0); setActiveButton('PRACTICE'); if (timerIntervalRef.current) clearInterval(timerIntervalRef.current); 
                
                // MODO PRÁCTICA: Por defecto también desactivamos cambios (Analog logic)
                if (!hasRotonda) {
                    setActiveCarCount(2); 
                    setLaneChangeActive(false);
                }

                const startTime = Date.now(); physicsState.current.forEach((car, i) => { const setup = carSetupsRef.current[car.id]; const baseSpeed = (setup.motorRPM / 150) * (3.0 / setup.gearRatio); car.distance = -15 * Math.floor(i / 2); car.speed = baseSpeed; car.isChanging = false; car.laps = 0; car.lapStartTime = startTime; car.lastLapTime = 0; car.totalLapTime = 0; car.completedLaps = 0; car.isDerailled = false; }); timerIntervalRef.current = setInterval(() => { setElapsedTime(Date.now() - startTime); }, 37); setPaused(false); 
            };
            const resetPractice = () => { setRaceState('idle'); setWinnerId(null); setElapsedTime(0); setActiveButton('PRACTICE'); physicsState.current.forEach((car, i) => { car.laps = 0; car.lapStartTime = 0; car.lastLapTime = 0; car.bestLapTime = Infinity; car.totalLapTime = 0; car.completedLaps = 0; car.distance = -15 * Math.floor(i / 2); car.speed = 0; car.isDerailled = false; }); setPaused(true); };
            const handleAnalogMode = () => { 
                // MODO ANALÓGICO: Garantiza que no hay cambios de carril
                setLaneChangeActive(false); setActiveButton('ANALOG'); 
                if (!hasRotonda) setActiveCarCount(2); 
            };
            const handleDigitalMode = () => { 
                const digitalSubtypes = ['digital_x', 'change_right', 'change_left', 'change_curve_r', 'pit_entry', 'digital_console', 'connection']; const hasDigitalPieces = circuitData.pieces.some(p => digitalSubtypes.includes(p.subtype)); if (!hasDigitalPieces) { setValidationError("⚠️ ERROR: No hay pistas digitales en el circuito (Cambios o Boxes)."); setTimeout(() => setValidationError(null), 3000); return; } 
                // MODO DIGITAL: Activamos cambios
                setLaneChangeActive(true); setActiveButton('DIGITAL'); 
                if (!hasRotonda) setActiveCarCount(4); // 4 coches por defecto en Digital
            };
            useEffect(() => { return () => { if (timerIntervalRef.current) clearInterval(timerIntervalRef.current); }; }, []);

            // Variables de ruta compartidas
            const rallyPathRef = useRef([]);
            const rallyDistancesRef = useRef([]); // NEW: Store distances for rally path

            useEffect(() => {
                isMountedRef.current = true;
                if (!circuitData || !containerRef.current || typeof THREE === 'undefined') return;
                let renderer, scene, camera, animationId; let isDragging = false, previousTouch = { x: 0, y: 0 }; let spherical = { radius: 250, theta: Math.PI/4, phi: Math.PI/3 }; let carMeshes = []; pieceMapRef.current = [];
                let prevTouchDist = null; let cameraTarget = new THREE.Vector3(0, 0, 0);

                const brandData = TRACK_DEFINITIONS[circuitData.brand] || TRACK_DEFINITIONS.NINCO; const laneSpacing = brandData.laneSpacing || 9.0; const trackWidth = brandData.width || 18.0;
                // ... [UNCHANGED RENDERER SETUP] ...
                const onResize = () => { if (camera && renderer && containerRef.current) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); } };
                const onMouseDown = (e) => { isDragging=true; previousTouch={x:e.clientX, y:e.clientY}; };
                const onMouseMove = (e) => { if(!isDragging) return; spherical.theta -= (e.clientX-previousTouch.x)*0.005; spherical.phi -= (e.clientY-previousTouch.y)*0.005; previousTouch={x:e.clientX, y:e.clientY}; };
                const onMouseUp = () => isDragging=false;
                const onTouchStart = (e) => { if(e.touches.length === 1) { isDragging=true; previousTouch={x:e.touches[0].clientX, y:e.touches[0].clientY}; } else if (e.touches.length === 2) { isDragging = false; const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; prevTouchDist = Math.sqrt(dx * dx + dy * dy); } };
                const onTouchMove = (e) => { e.preventDefault(); if(e.touches.length === 1 && isDragging) { const touch = e.touches[0]; spherical.theta -= (touch.clientX - previousTouch.x)*0.005; spherical.phi -= (touch.clientY - previousTouch.y)*0.005; previousTouch={x:touch.clientX, y:touch.clientY}; } else if (e.touches.length === 2 && prevTouchDist !== null) { const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; const currentDist = Math.sqrt(dx * dx + dy * dy); const delta = prevTouchDist - currentDist; spherical.radius += delta * 2.5; prevTouchDist = currentDist; } };
                const onTouchEnd = () => { isDragging=false; prevTouchDist = null; };
                const onWheel = (e) => { e.preventDefault(); spherical.radius += e.deltaY * 0.5; };
                
                const createCar = (id, color) => { 
                    const physicsGroup = new THREE.Group(); const visualGroup = new THREE.Group(); physicsGroup.add(visualGroup);
                    const config = carAssetsRef.current[id] || {}; 
                    
                    // LÓGICA DE CARGA DE MODELOS (GLB AÑADIDO Y CORREGIDO)
                    if (config.glb && typeof THREE.GLTFLoader !== 'undefined') {
                        const loader = new THREE.GLTFLoader();
                        loader.load(config.glb, (gltf) => {
                            const object = gltf.scene;
                            // Normalizar Escala y Posición para la Pista
                            const box = new THREE.Box3().setFromObject(object);
                            const size = box.getSize(new THREE.Vector3());
                            const center = box.getCenter(new THREE.Vector3());
                            
                            // Centrar pivote
                            object.position.x -= center.x;
                            object.position.y -= center.y;
                            object.position.z -= center.z;
                            
                            // Escalar a tamaño coche Slot 1:32 (aprox 14.5 cm de largo)
                            const maxDim = Math.max(size.x, size.z); 
                            const targetSize = 14.5; 
                            const scale = targetSize / (maxDim || 1);
                            
                            object.scale.set(scale, scale, scale);
                            // AJUSTE ALTURA GLB: Base del modelo en 0 local
                            object.position.y += (size.y * scale) / 2; 
                            
                            // Rotación correcta: Math.PI (180º) para corregir si va marcha atrás
                            object.rotation.y = Math.PI; 

                            object.traverse((child) => { 
                                if (child.isMesh) { 
                                    child.castShadow = true; 
                                } 
                            }); 
                            visualGroup.add(object);
                        });
                    } else if (config.obj && config.obj.length > 0 && typeof THREE.OBJLoader !== 'undefined') {
                        // ... existing OBJ loader logic ...
                        const loadModel = (materials = null) => { const objLoader = new THREE.OBJLoader(); if (materials) { objLoader.setMaterials(materials); } objLoader.load(config.obj, (object) => { const box = new THREE.Box3().setFromObject(object); const size = box.getSize(new THREE.Vector3()); const center = box.getCenter(new THREE.Vector3()); object.position.x += (object.position.x - center.x); object.position.y += (object.position.y - center.y); object.position.z += (object.position.z - center.z); const maxDim = Math.max(size.x, size.y, size.z); const targetSize = 10.0; const scaleFactor = targetSize / maxDim; object.scale.set(scaleFactor, scaleFactor, scaleFactor); object.position.y += (size.y * scaleFactor) / 2; object.traverse((child) => { if (child.isMesh) { child.castShadow = true; if (!materials && !config.texture) { child.material = new THREE.MeshStandardMaterial({ color: color, metalness: 0.5, roughness: 0.5 }); } if (config.texture) { const texLoader = new THREE.TextureLoader(); texLoader.load(config.texture, (tex) => { child.material.map = tex; child.material.needsUpdate = true; }); } } }); visualGroup.add(object); }, undefined, (err) => { console.warn("Error cargando OBJ, usando geométrico", err); createGeometricCar(); }); };
                        if (config.mtl && config.mtl.length > 0 && typeof THREE.MTLLoader !== 'undefined') { const mtlLoader = new THREE.MTLLoader(); mtlLoader.load(config.mtl, (materials) => { materials.preload(); loadModel(materials); }, undefined, () => loadModel(null)); } else { loadModel(null); }
                    } else {
                        // Coche Geométrico por Defecto
                        const createGeometricCar = () => { const bodyMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2, metalness: 0.6 }); const bodyGeo = new THREE.BoxGeometry(4.5, 1.2, 9); const body = new THREE.Mesh(bodyGeo, bodyMat); body.position.y = 0.8; body.castShadow = true; visualGroup.add(body); const cockpitGeo = new THREE.BoxGeometry(3.5, 0.8, 4); const cockpitMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.1 }); const cockpit = new THREE.Mesh(cockpitGeo, cockpitMat); cockpit.position.y = 1.8; visualGroup.add(cockpit); const wheelGeo = new THREE.CylinderGeometry(1.2, 1.2, 0.8, 16); wheelGeo.rotateZ(Math.PI/2); const wheelMat = new THREE.MeshStandardMaterial({ color: 0x222222 }); [[-2.5, 3], [2.5, 3], [-2.5, -3], [2.5, -3]].forEach(p => { const w = new THREE.Mesh(wheelGeo, wheelMat); w.position.set(p[0], 1.2, p[1]); visualGroup.add(w); }); };
                        createGeometricCar();
                    } 
                    return physicsGroup; 
                };
                const createAsphaltTexture = (renderer, baseColor) => { const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512; const ctx = canvas.getContext('2d'); ctx.fillStyle = baseColor || '#080808'; ctx.fillRect(0, 0, 512, 512); for (let i = 0; i < 150000; i++) { const val = 15 + Math.floor(Math.random() * 30); ctx.fillStyle = `rgba(${val}, ${val}, ${val}, 0.2)`; ctx.fillRect(Math.random() * 512, Math.random() * 512, 1.5, 1.5); } for (let i = 0; i < 10000; i++) { const val = 40 + Math.floor(Math.random() * 40); ctx.fillStyle = `rgba(${val}, ${val}, ${val}, 0.15)`; ctx.fillRect(Math.random() * 512, Math.random() * 512, 1, 1); } const texture = new THREE.CanvasTexture(canvas); texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; texture.repeat.set(1, 1); if (renderer) texture.anisotropy = renderer.capabilities.getMaxAnisotropy(); return texture; };

                const init3D = () => {
                    const rails = { lane1: [], lane2: [], pit: [], changes: [] }; const vertexDistances = [0]; let accumulatedDist = 0;
                    const w = window.innerWidth, h = window.innerHeight; 
                    scene = new THREE.Scene(); const bgColor = 0x3b5f7d; scene.background = new THREE.Color(bgColor); scene.fog = new THREE.Fog(bgColor, 500, 3000); 
                    camera = new THREE.PerspectiveCamera(50, w / h, 1, 5000); 
                    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false }); renderer.setClearColor(bgColor, 1); renderer.setSize(w, h); renderer.setPixelRatio(window.devicePixelRatio); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
                    if (containerRef.current) { while(containerRef.current.firstChild) containerRef.current.removeChild(containerRef.current.firstChild); containerRef.current.appendChild(renderer.domElement); } else { return; }
                    
                    // ILUMINACIÓN AJUSTADA (MENOS INTENSA, MÁS NATURAL)
                    scene.add(new THREE.AmbientLight(0xffffff, 0.6)); // Bajado de 2.5 a 0.6
                    scene.add(new THREE.HemisphereLight(0xffffff, 0x222222, 0.6)); // Bajado de 1.5 a 0.6
                    
                    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2); // Bajado de 3.0 a 1.2
                    dirLight.position.set(100, 300, 50); dirLight.castShadow = true; dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048; scene.add(dirLight); 
                    
                    // Luz de relleno lateral suave
                    const fillLight = new THREE.DirectionalLight(0xffffff, 0.5); // Bajado de 1.5 a 0.5
                    fillLight.position.set(-100, 50, -50);
                    scene.add(fillLight);

                    const gridHelper = new THREE.GridHelper(4000, 200, 0x888888, 0xcccccc); gridHelper.position.y = -0.5; scene.add(gridHelper);
                    const asphaltTexture = createAsphaltTexture(renderer, brandData.trackColor);
                    const trackGroup = new THREE.Group(); const stdHalf = trackWidth / 2; const pitCenterDist = (laneSpacing / 2) + laneSpacing; const pitOuterEdge = pitCenterDist + (trackWidth / 2 + 1) / 2; 
                    const asphaltVerts = [], asphaltIndices = [], asphaltUVs = []; let aspVertCount = 0; 
                    const addAsphaltSlice = (cx, cz, angle, lW, rW, dist) => { const perpX = Math.cos(angle + Math.PI/2), perpZ = Math.sin(angle + Math.PI/2); asphaltVerts.push(cx - perpX * lW, 0, cz - perpZ * lW); asphaltVerts.push(cx + perpX * rW, 0, cz + perpZ * rW); const vCoord = dist * 0.2; asphaltUVs.push(0, vCoord); asphaltUVs.push(1, vCoord); if (aspVertCount > 0) { const base = (aspVertCount-1)*2; asphaltIndices.push(base, base+2, base+1, base+1, base+2, base+3); } aspVertCount++; };
                    let curX = 0, curZ = 0, curAngle = 0; let lane1Offset = -laneSpacing/2, lane2Offset = laneSpacing/2;
                    const addRailPoint = (x, z, angle, l1Off, l2Off, pitOff, distIncrement) => { const perpX = Math.cos(angle + Math.PI/2), perpZ = Math.sin(angle + Math.PI/2), yRail = 0.2; 
                        if (l1Off !== null) rails.lane1.push(new THREE.Vector3(x + perpX * l1Off, yRail, z + perpZ * l1Off)); else rails.lane1.push(null);
                        if (l2Off !== null) rails.lane2.push(new THREE.Vector3(x + perpX * l2Off, yRail, z + perpZ * l2Off)); else rails.lane2.push(null);
                        if (pitOff !== null) rails.pit.push(new THREE.Vector3(x + perpX * pitOff, yRail, z + perpZ * pitOff)); else rails.pit.push(null); if (distIncrement > 0) { accumulatedDist += distIncrement; vertexDistances.push(accumulatedDist); } 
                    };
                    addRailPoint(0,0,0, lane1Offset, lane2Offset, null, 0); addAsphaltSlice(0,0,0, stdHalf, stdHalf, 0); const easeSine = (t) => (1 - Math.cos(t * Math.PI)) / 2;
                    
                    circuitData.pieces.forEach((p, index) => {
                        // ... [PREVIOUS CODE REMAINS THE SAME FOR ROTONDA AND STANDARD PIECES] ...
                        if (p.subtype === 'rotonda') {
                            const steps = 40; 
                            const r = p.radius || 14.5;   
                            const loopCenterX = r * 1.3;
                            const laneOffVal = laneSpacing / 2;
                            const startX = curX;
                            const startZ = curZ;
                            const startAngle = curAngle;
                            const straightLen = 10.0;

                            const rotVertexIndex = rails.lane1.length;

                            rails.lane1.push(null);
                            rails.lane2.push(null);
                            rails.pit.push(null);
                            
                            vertexDistances.push(accumulatedDist);

                            const loopRailPoints = [];
                            const cubicBezier = (p0, p1, p2, p3, t) => { const u = 1 - t; return (u*u*u * p0) + (3*u*u*t * p1) + (3*u*t*t * p2) + (t*t*t * p3); };
                            const loopArcLength = Math.PI * r; 
                            const straightParts = loopCenterX * 2; 
                            const totalPieceLen = straightLen + straightLen + loopArcLength + straightParts; 
                            const loopStepDist = (loopArcLength + straightParts) / steps;

                            // GEOMETRÍA ESTÁNDAR (Restaurada):
                            // Conecta Carril 1 (-4.5) con Carril 2 (+4.5)
                            const startRailX = startX + (Math.cos(startAngle + Math.PI/2) * -laneOffVal); 
                            const startRailZ = startZ + (Math.sin(startAngle + Math.PI/2) * -laneOffVal);
                            loopRailPoints.push(new THREE.Vector3(startRailX, 0.2, startRailZ));
                            
                            const singleLaneWidth = 4.5;
                            const fullLaneWidth = 9.0;
                            addAsphaltSlice(startX, startZ, startAngle, 9.0, 9.0, accumulatedDist);
                            
                            const straightEndX = startX + straightLen * Math.cos(startAngle);
                            const straightEndZ = startZ + straightLen * Math.sin(startAngle);
                            
                            // Rail intermedio (antes del loop) sigue en carril 1 (-4.5)
                            const straightEndRailX = straightEndX + (Math.cos(startAngle + Math.PI/2) * -laneOffVal);
                            const straightEndRailZ = straightEndZ + (Math.sin(startAngle + Math.PI/2) * -laneOffVal);
                            loopRailPoints.push(new THREE.Vector3(straightEndRailX, 0.2, straightEndRailZ));
                            
                            addAsphaltSlice(straightEndX, straightEndZ, startAngle, 9.0, 9.0, accumulatedDist + straightLen);

                            for (let i = 0; i <= steps; i++) { 
                                const tTotal = i / steps;
                                let localX, localZ, localAngle;
                                if (tTotal < 0.3) {
                                    const t = tTotal / 0.3;
                                    localX = cubicBezier(0, loopCenterX * 0.4, loopCenterX * 0.4, loopCenterX, t);
                                    // Bezier: De Lane 1 (-4.5) hacia radio exterior (-r)
                                    localZ = cubicBezier(-laneOffVal, -laneOffVal, -r, -r, t);
                                    
                                    const dX = (3*(1-t)*(1-t) * (loopCenterX*0.4 - 0)) + (6*(1-t)*t * (loopCenterX*0.4 - loopCenterX*0.4)) + (3*t*t * (loopCenterX - loopCenterX*0.4));
                                    const dZ = (3*(1-t)*(1-t) * (-laneOffVal - -laneOffVal)) + (6*(1-t)*t * (-r - -laneOffVal)) + (3*t*t * (-r - -r));
                                    localAngle = Math.atan2(dZ, dX);
                                } else if (tTotal < 0.7) {
                                    const t = (tTotal - 0.3) / 0.4;
                                    const currentArcAngle = -Math.PI / 2 + (Math.PI * t);
                                    localX = loopCenterX + r * Math.cos(currentArcAngle);
                                    localZ = r * Math.sin(currentArcAngle);
                                    localAngle = currentArcAngle + Math.PI / 2;
                                } else {
                                    const t = (tTotal - 0.7) / 0.3;
                                    localX = cubicBezier(loopCenterX, loopCenterX * 0.4, loopCenterX * 0.4, 0, t);
                                    // Bezier: Vuelve de radio exterior (-r) a Lane 2 (+4.5)
                                    localZ = cubicBezier(r, r, laneOffVal, laneOffVal, t);
                                    
                                    const dX = (3*(1-t)*(1-t) * (loopCenterX*0.4 - loopCenterX)) + (6*(1-t)*t * (loopCenterX*0.4 - loopCenterX*0.4)) + (3*t*t * (0 - loopCenterX*0.4));
                                    const dZ = (3*(1-t)*(1-t) * (r - r)) + (6*(1-t)*t * (laneOffVal - r)) + (3*t*t * (laneOffVal - laneOffVal));
                                    localAngle = Math.atan2(dZ, dX);
                                }
                                
                                const cosA = Math.cos(startAngle);
                                const sinA = Math.sin(startAngle);
                                
                                const worldX = straightEndX + (localX * cosA - localZ * sinA);
                                const worldZ = straightEndZ + (localX * sinA + localZ * cosA);
                                const worldAngle = startAngle + localAngle;
                                
                                if (i > 0) loopRailPoints.push(new THREE.Vector3(worldX, 0.2, worldZ));
                                
                                addAsphaltSlice(worldX, worldZ, worldAngle, singleLaneWidth, singleLaneWidth, accumulatedDist + straightLen + (i * loopStepDist));
                            }

                            const returnStartRailX = straightEndX + (Math.cos(startAngle + Math.PI/2) * laneOffVal);
                            const returnStartRailZ = straightEndZ + (Math.sin(startAngle + Math.PI/2) * laneOffVal);
                            
                            // Final en Lane 2 (+4.5)
                            const endRailX = startX + (Math.cos(startAngle + Math.PI/2) * laneOffVal);
                            const endRailZ = startZ + (Math.sin(startAngle + Math.PI/2) * laneOffVal);
                            
                            loopRailPoints.push(new THREE.Vector3(endRailX, 0.2, endRailZ));
                            
                            addAsphaltSlice(startX, startZ, startAngle + Math.PI, 9.0, 9.0, accumulatedDist + totalPieceLen);

                            rails.changes.push({ points: loopRailPoints, refIdx: rotVertexIndex, count: steps + 2, isRotonda: true });
                            
                            curX = startX; curZ = startZ; curAngle = startAngle + Math.PI;
                            
                            accumulatedDist += totalPieceLen;
                            
                            addRailPoint(curX, curZ, curAngle, -laneOffVal, laneOffVal, null, 0);
                            vertexDistances.push(accumulatedDist); 

                            pieceMapRef.current.push({ index: index, distStart: accumulatedDist - totalPieceLen, distEnd: accumulatedDist, type: p.type, subtype: p.subtype, invert: p.invert });
                            return; 
                        }

                        const startVertexIdx = rails.lane1.length - 1; const startDist = accumulatedDist; const steps = (p.type === 'curve') ? Math.ceil(Math.abs(p.angle) * 2) : 10; const stepLen = p.length / steps; const totalSweep = (p.type==='curve') ? (p.angle * Math.PI / 180) * (p.direction==='left'?-1:1) : 0; const stepAngle = totalSweep / steps; let stepPhysDist = stepLen; if (p.type === 'curve') stepPhysDist = (2 * Math.PI * p.radius) * (Math.abs(p.angle) / 360) / steps;
                        
                        // CAPTURAR ESTADO INICIAL PARA GEOMETRÍA DIGITAL
                        const dStartX = curX;
                        const dStartZ = curZ;
                        const dStartAngle = curAngle;

                        const isCrossing = p.subtype === 'crossing'; const isPitEntry = p.type === 'pit_entry'; const isPitExit = p.type === 'pit_exit'; const isChicaneEntry = p.subtype === 'chicane_entry'; const isChicaneExit = p.subtype === 'chicane_exit'; const pitSide = p.invert ? 'left' : 'right'; const pitDir = pitSide === 'right' ? 1 : -1;
                        let startL1 = lane1Offset, startL2 = lane2Offset; let targetL1 = lane1Offset, targetL2 = lane2Offset; if (isCrossing) { targetL1 = lane2Offset; targetL2 = lane1Offset; lane1Offset = targetL1; lane2Offset = targetL2; } else if (isChicaneEntry) { targetL1 = startL1 * 0.2; targetL2 = startL2 * 0.2; lane1Offset = targetL1; lane2Offset = targetL2; } else if (isChicaneExit) { targetL1 = (startL1 > 0 ? 1 : -1) * (laneSpacing / 2); targetL2 = (startL2 > 0 ? 1 : -1) * (laneSpacing / 2); lane1Offset = targetL1; lane2Offset = targetL2; }
                        
                        const digi1to2 = [], digi2to1 = [];

                        // CORRECCIÓN VISUAL 3D: Añadir punto inicial (t=0) para que el carril de cambio nazca conectado al principal
                        if (['digital_x', 'change_right', 'change_left', 'pit_parallel_double_x'].includes(p.subtype)) {
                            const perpX = Math.cos(dStartAngle + Math.PI/2);
                            const perpZ = Math.sin(dStartAngle + Math.PI/2);
                            if (p.subtype !== 'change_left') 
                                digi1to2.push(new THREE.Vector3(dStartX + perpX * startL1, 0.2, dStartZ + perpZ * startL1));
                            if (p.subtype !== 'change_right') 
                                digi2to1.push(new THREE.Vector3(dStartX + perpX * startL2, 0.2, dStartZ + perpZ * startL2));
                        }

                        for (let i = 1; i <= steps; i++) { const t = i / steps; if (p.type === 'curve') { const r = p.radius; const chordLen = 2 * r * Math.sin(Math.abs(stepAngle)/2); const chordDir = curAngle + stepAngle/2; curX += chordLen * Math.cos(chordDir); curZ += chordLen * Math.sin(chordDir); curAngle += stepAngle; } else { curX += stepLen * Math.cos(curAngle); curZ += stepLen * Math.sin(curAngle); } let mixT = t; if (isCrossing || isChicaneEntry || isChicaneExit) mixT = easeSine(t); 
                            let curL1 = startL1 + (targetL1 - startL1) * mixT; 
                            let curL2 = startL2 + (targetL2 - startL2) * mixT; 
                            if (p.subtype === 'single_lane_1') { curL2 = null; }
                            if (p.subtype === 'single_lane_2') { curL1 = null; }

                            let curPit = null; let curTrackW_L = stdHalf, curTrackW_R = stdHalf; if (isPitEntry) { const startPit = pitDir * (laneSpacing/2); const endPit = pitDir * pitCenterDist; const ease = t * t * (3 - 2 * t); curPit = startPit + (endPit - startPit) * ease; if(pitSide==='right') curTrackW_R = stdHalf + (pitOuterEdge - stdHalf) * ease; else curTrackW_L = stdHalf + (pitOuterEdge - stdHalf) * ease; } else if (isPitExit) { const startPit = pitDir * pitCenterDist; const endPit = pitDir * (laneSpacing/2); const ease = t * t * (3 - 2 * t); curPit = startPit + (endPit - startPit) * ease; if(pitSide==='right') curTrackW_R = pitOuterEdge - (pitOuterEdge - stdHalf) * ease; else curTrackW_L = pitOuterEdge - (pitOuterEdge - stdHalf) * ease; } else if (p.subtype && p.subtype.includes('pit_parallel')) { curPit = pitDir * pitCenterDist; if(pitSide==='right') curTrackW_R = pitOuterEdge; else curTrackW_L = pitOuterEdge; }
                            if (p.subtype === 'single_lane_1') { curTrackW_R = 0; }
                            if (p.subtype === 'single_lane_2') { curTrackW_L = 0; }

                            addRailPoint(curX, curZ, curAngle, curL1, curL2, curPit, stepPhysDist); addAsphaltSlice(curX, curZ, curAngle, curTrackW_L, curTrackW_R, accumulatedDist);
                            if (['digital_x', 'change_right', 'change_left', 'pit_parallel_double_x'].includes(p.subtype)) { const crossT = easeSine(t); const offset1to2 = startL1 + (startL2 - startL1) * crossT; const offset2to1 = startL2 + (startL1 - startL2) * crossT; const perpX = Math.cos(curAngle + Math.PI/2); const perpZ = Math.sin(curAngle + Math.PI/2); if (p.subtype !== 'change_left') digi1to2.push(new THREE.Vector3(curX + perpX * offset1to2, 0.2, curZ + perpZ * offset1to2)); if (p.subtype !== 'change_right') digi2to1.push(new THREE.Vector3(curX + perpX * offset2to1, 0.2, curZ + perpZ * offset2to1)); }
                        }
                        if (digi1to2.length > 0) rails.changes.push({ points: digi1to2, refIdx: startVertexIdx, count: steps }); 
                        if (digi2to1.length > 0) rails.changes.push({ points: digi2to1, refIdx: startVertexIdx, count: steps });
                        pieceMapRef.current.push({ index: index, distStart: startDist, distEnd: accumulatedDist, type: p.type, subtype: p.subtype, invert: p.invert, canChangeLane: ['digital_x','change_right','change_left','pit_entry', 'pit_parallel_double_x'].includes(p.subtype) || p.type === 'pit_entry', isPitSection: isPitEntry || isPitExit || (p.subtype && p.subtype.includes('pit_parallel')) });
                    });

                    // --- CONSTRUCCIÓN DEL "SUPER-CARRIL" (VIRTUAL LANE 3) CON DISTANCIAS REALES ---
                    let finalRallyPath = [];
                    let rallyDists = [0]; 
                    let currentRallyDist = 0;

                    if (hasRotonda) {
                        // ... [ROTONDA PATH BUILDING CODE UNCHANGED] ...
                        const rotondas = rails.changes.filter(c => c.isRotonda).sort((a, b) => a.refIdx - b.refIdx);
                        const startRotondaRef = rotondas.length > 0 ? rotondas[0].refIdx : -1;
                        const endRotondaRef = rotondas.length > 0 ? rotondas[rotondas.length - 1].refIdx : -1;

                        const appendPath = (points) => {
                            if (points.length === 0) return;
                            const newPoints = points.map(p => p.clone());
                            if (finalRallyPath.length > 0) {
                                const lastP = finalRallyPath[finalRallyPath.length - 1];
                                const firstP = newPoints[0];
                                if (lastP.distanceTo(firstP) < 10.0) { firstP.copy(lastP); } 
                                else { finalRallyPath.push(new THREE.Vector3().lerpVectors(lastP, firstP, 0.5)); }
                            }
                            newPoints.forEach(p => finalRallyPath.push(p));
                        };

                        let currentSegment = [];
                        for (let i = 0; i < rails.lane1.length; i++) {
                            if (rails.lane1[i]) { currentSegment.push(rails.lane1[i]); } 
                            else {
                                if (currentSegment.length > 0) { appendPath(currentSegment); currentSegment = []; }
                                const rotChange = rails.changes.find(c => c.isRotonda && Math.abs(c.refIdx - i) < 3);
                                if (rotChange) { if (rotChange.refIdx >= endRotondaRef && i > 5) { appendPath(rotChange.points); } while(i < rails.lane1.length - 1 && rails.lane1[i+1] === null) { i++; } }
                            }
                        }
                        if (currentSegment.length > 0) appendPath(currentSegment);

                        currentSegment = [];
                        for (let i = rails.lane2.length - 1; i >= 0; i--) {
                            if (rails.lane2[i]) { currentSegment.push(rails.lane2[i]); } 
                            else {
                                if (currentSegment.length > 0) { appendPath(currentSegment); currentSegment = []; }
                                const rotChange = rails.changes.find(c => c.isRotonda && Math.abs(c.refIdx - i) < 3);
                                if (rotChange) { if (rotChange.refIdx <= startRotondaRef) { appendPath(rotChange.points); } while(i > 0 && rails.lane2[i-1] === null) { i--; } }
                            }
                        }
                        if (currentSegment.length > 0) appendPath(currentSegment);

                        const cleanPath = (points) => { if (points.length < 2) return points; const cleaned = [points[0]]; for (let i = 1; i < points.length; i++) { if (points[i].distanceTo(cleaned[cleaned.length - 1]) > 0.05) { cleaned.push(points[i]); } } return cleaned; };
                        finalRallyPath = cleanPath(finalRallyPath);

                        if (finalRallyPath.length > 0) { const first = finalRallyPath[0]; const last = finalRallyPath[finalRallyPath.length - 1]; if (first.distanceTo(last) > 0.5) { finalRallyPath.push(new THREE.Vector3().lerpVectors(last, first, 0.33)); finalRallyPath.push(new THREE.Vector3().lerpVectors(last, first, 0.66)); finalRallyPath.push(first.clone()); } }

                        if (finalRallyPath.length > 10) { for (let iter = 0; iter < 10; iter++) { const smoothed = []; const len = finalRallyPath.length; for (let i = 0; i < len; i++) { const prev = finalRallyPath[(i - 1 + len) % len]; const curr = finalRallyPath[i]; const next = finalRallyPath[(i + 1) % len]; const x = (prev.x + curr.x + next.x) / 3; const y = (prev.y + curr.y + next.y) / 3; const z = (prev.z + curr.z + next.z) / 3; smoothed.push(new THREE.Vector3(x, y, z)); } finalRallyPath = smoothed; } }

                        for(let i=1; i<finalRallyPath.length; i++) { const d = finalRallyPath[i].distanceTo(finalRallyPath[i-1]); currentRallyDist += d; rallyDists.push(currentRallyDist); }
                    }
                    rallyPathRef.current = finalRallyPath;
                    rallyDistancesRef.current = rallyDists;

                    // --- PUENTES Y ELEVACIÓN [UNCHANGED] ---
                    // ... (Bridge logic skipped for brevity, assumed identical to previous)
                    const trackPoints = rails.lane1; 
                    const numPoints = trackPoints.length; 
                    const totalDist = vertexDistances[vertexDistances.length - 1] || 1; 
                    const elevationProfile = new Float32Array(numPoints).fill(0);
                    const BRIDGE_CLEARANCE = 9.5; const BRIDGE_THICKNESS = 1.5; const BRIDGE_TOP_H = BRIDGE_CLEARANCE + BRIDGE_THICKNESS; const RAMP_LENGTH = 160.0; const FLAT_TOP_LEN = 40.0; const SEARCH_GAP = 200.0; 
                    const intersections = [];
                    
                    // HELPER MEJORADO PARA OBTENER LA PIEZA EN UN ÍNDICE
                    const getPieceAtIdx = (idx) => { 
                        const d = vertexDistances[idx]; 
                        return pieceMapRef.current.find(p => d >= p.distStart && d < p.distEnd); 
                    };
                    const isRotondaIdx = (idx) => { const piece = getPieceAtIdx(idx); return piece?.type === 'curve' && piece?.subtype === 'rotonda'; };

                    for (let i = 0; i < numPoints - 1; i += 2) {
                        if (isRotondaIdx(i)) continue;
                        
                        // CORRECCIÓN 1: Evitar detectar puentes si la pieza de abajo es especial
                        const pieceI = getPieceAtIdx(i);
                        const isSpecialI = pieceI && ['crossing', 'digital_x', 'change_right', 'change_left', 'pit_parallel_double_x', 'chicane_entry', 'chicane_exit'].includes(pieceI.subtype);
                        if (isSpecialI) continue;

                        for (let j = i + 1; j < numPoints - 1; j += 2) {
                            if (isRotondaIdx(j)) continue;
                            
                            // CORRECCIÓN 1: Evitar detectar puentes si la pieza de arriba es especial
                            const pieceJ = getPieceAtIdx(j);
                            const isSpecialJ = pieceJ && ['crossing', 'digital_x', 'change_right', 'change_left', 'pit_parallel_double_x', 'chicane_entry', 'chicane_exit'].includes(pieceJ.subtype);
                            if (isSpecialJ) continue;

                            const d1 = vertexDistances[i]; const d2 = vertexDistances[j]; let travelDist = Math.abs(d2 - d1); if (travelDist > accumulatedDist / 2) travelDist = accumulatedDist - travelDist;
                            if (travelDist > SEARCH_GAP) {
                                const p1 = trackPoints[i] || rails.lane2[i]; 
                                const p2 = trackPoints[j] || rails.lane2[j]; 
                                if (!p1 || !p2) continue; 
                                
                                const dist2D = Math.sqrt((p1.x - p2.x)**2 + (p1.z - p2.z)**2);
                                
                                // CORRECCIÓN 2: UMBRAL MÁS ESTRICTO (12 en lugar de 22)
                                // Esto evita que pistas paralelas adyacentes (distancia ~18cm) se detecten como puentes.
                                if (dist2D < 12) {
                                    // CORRECCIÓN 3: FILTRO DE PARALELISMO (ÁNGULO)
                                    // Si las pistas van paralelas, NO es un puente.
                                    const p1Next = trackPoints[i+1] || rails.lane2[i+1];
                                    const p2Next = trackPoints[j+1] || rails.lane2[j+1];
                                    
                                    if (p1Next && p2Next) {
                                        // Cálculo simplificado de vectores dirección
                                        const dx1 = p1Next.x - p1.x; const dz1 = p1Next.z - p1.z;
                                        const dx2 = p2Next.x - p2.x; const dz2 = p2Next.z - p2.z;
                                        // Normalizar
                                        const len1 = Math.sqrt(dx1*dx1 + dz1*dz1);
                                        const len2 = Math.sqrt(dx2*dx2 + dz2*dz2);
                                        if (len1 > 0 && len2 > 0) {
                                            const dot = (dx1*dx2 + dz1*dz2) / (len1 * len2);
                                            // Si el producto punto es cercano a 1 (paralelo) o -1 (antiparalelo), ignorar.
                                            // Umbral 0.85 equivale a unos 30 grados. Si se cruzan con menos ángulo, se considera paralelo/roce.
                                            if (Math.abs(dot) > 0.85) continue;
                                        }
                                    }

                                    const midX = (p1.x + p2.x) / 2;
                                    const midZ = (p1.z + p2.z) / 2;
                                    const exists = intersections.some(c => { const distSq = (midX - c.midX)**2 + (midZ - c.midZ)**2; return distSq < (40 * 40); });
                                    if (!exists) {
                                        let goesUpIdx = j; 
                                        if (bridgeStrategy === 'inverse') goesUpIdx = i; 
                                        else if (bridgeStrategy === 'smart') { 
                                            const type1 = pieceI?.type || 'straight'; 
                                            const type2 = pieceJ?.type || 'straight'; 
                                            if (type1 === 'straight' && type2 === 'curve') goesUpIdx = i; 
                                            else if (type1 === 'curve' && type2 === 'straight') goesUpIdx = j; 
                                            else goesUpIdx = j; 
                                        }
                                        intersections.push({ upperIdx: goesUpIdx, lowerIdx: goesUpIdx === j ? i : j, midX, midZ });
                                    }
                                }
                            }
                        }
                    }

                    // APLICAR PERFIL DE ELEVACIÓN (RAMPAS)
                    intersections.forEach(cross => { const centerDist = vertexDistances[cross.upperIdx]; for (let k = 0; k < numPoints; k++) { const currentDist = vertexDistances[k]; let distToCenter = Math.abs(currentDist - centerDist); if (distToCenter > accumulatedDist / 2) distToCenter = accumulatedDist - distToCenter; if (distToCenter < (FLAT_TOP_LEN/2 + RAMP_LENGTH)) { let h = 0; if (distToCenter <= FLAT_TOP_LEN / 2) { h = BRIDGE_TOP_H; } else { const rampPos = (distToCenter - FLAT_TOP_LEN/2) / RAMP_LENGTH; const smoothFactor = (rampPos * rampPos * (3 - 2 * rampPos)); h = BRIDGE_TOP_H * (1 - smoothFactor); } elevationProfile[k] = Math.max(elevationProfile[k], h); } } });
                    
                    // CORRECCIÓN 4 (FINAL Y AGRESIVA): APLANAR FORZOSAMENTE PIEZAS ESPECIALES
                    // Asegura que Cruces y Cambios sean planos, independientemente de las rampas calculadas.
                    for (let k = 0; k < numPoints; k++) {
                        const piece = getPieceAtIdx(k);
                        if (piece) {
                            const mustBeFlat = [
                                'crossing', 'digital_x', 'change_right', 'change_left', 
                                'pit_parallel_double_x', 'pit_entry', 'pit_exit', 
                                'digital_console', 'connection', 'starting_grid', 
                                'chicane_entry', 'chicane_exit'
                            ].includes(piece.subtype);
                            
                            if (mustBeFlat) {
                                elevationProfile[k] = 0;
                            }
                        }
                    }

                    if (intersections.length > 0) { for (let i = 0; i < numPoints; i++) { const h = elevationProfile[i]; if (h > 0.1) { if (rails.lane1[i]) rails.lane1[i].y += h; if (rails.lane2[i]) rails.lane2[i].y += h; if (rails.pit[i]) rails.pit[i].y += h; const vertIdx = i * 6; if (asphaltVerts.length > vertIdx + 5) { asphaltVerts[vertIdx + 1] += h; asphaltVerts[vertIdx + 4] += h; } } } rails.changes.forEach(changeItem => { const { points, refIdx, count } = changeItem; const startI = Math.max(0, refIdx - 5); const endI = Math.min(numPoints, refIdx + count + 5); points.forEach(pt => { let bestH = 0; let minDist = Infinity; for(let i = startI; i < endI; i++) { const r = rails.lane1[i] || rails.lane2[i]; if (!r) continue; const d = (pt.x - r.x)**2 + (pt.z - r.z)**2; if(d < minDist) { minDist = d; bestH = r.y; } } if (minDist < 50 && bestH > 0.1) pt.y = bestH; }); }); }

                    const createRailMesh = (points, color, width=0.6) => { const cleanPoints = points.filter(p => p !== null); if(cleanPoints.length < 2) return; const path = new THREE.CatmullRomCurve3(cleanPoints); const geometry = new THREE.TubeGeometry(path, Math.max(2, cleanPoints.length), width/1.8, 8, false); const material = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x222222, emissiveIntensity: 0.2, metalness: 1.0, roughness: 0.15, flatShading: false }); const mesh = new THREE.Mesh(geometry, material); mesh.castShadow = true; trackGroup.add(mesh); };
                    const createMultiSegmentRailMesh = (points, color, width=0.6) => { let currentSegment = []; for (let p of points) { if (p === null) { if (currentSegment.length > 1) createRailMesh(currentSegment, color, width); currentSegment = []; } else { currentSegment.push(p); } } if (currentSegment.length > 1) createRailMesh(currentSegment, color, width); };

                    const aspGeo = new THREE.BufferGeometry(); aspGeo.setAttribute('position', new THREE.Float32BufferAttribute(asphaltVerts, 3)); aspGeo.setAttribute('uv', new THREE.Float32BufferAttribute(asphaltUVs, 2)); aspGeo.setIndex(asphaltIndices); aspGeo.computeVertexNormals(); 
                    const asphaltMesh = new THREE.Mesh(aspGeo, new THREE.MeshStandardMaterial({ map: asphaltTexture, color: 0xffffff, roughness: 0.8, metalness: 0.05, side: THREE.DoubleSide })); asphaltMesh.receiveShadow = true; trackGroup.add(asphaltMesh);
                    createMultiSegmentRailMesh(rails.lane1, null, 0.7); createMultiSegmentRailMesh(rails.lane2, null, 0.7); createMultiSegmentRailMesh(rails.pit, null, 0.6);
                    rails.changes.forEach(obj => createRailMesh(obj.points, null, 0.5));
                    
                    const box = new THREE.Box3().setFromObject(trackGroup); if (!box.isEmpty()) { const center = box.getCenter(new THREE.Vector3()); trackGroup.position.sub(center); trackGroup.position.y = 0; } scene.add(trackGroup);
                    
                    // CREAR TODOS LOS COCHES POSIBLES (MAX_CARS)
                    physicsState.current.forEach((car) => { const c = createCar(car.id, car.color); trackGroup.add(c); carMeshes.push(c); });

                    const getPositionAtDistance = (pointArray, dist) => { 
                        let idx = 0; let min = 0, max = vertexDistances.length - 1; 
                        while (min <= max) { let mid = Math.floor((min + max) / 2); if (vertexDistances[mid] <= dist) { idx = mid; min = mid + 1; } else { max = mid - 1; } } 
                        if (idx >= vertexDistances.length - 1) idx = vertexDistances.length - 2; 
                        let p1 = pointArray[idx]; let p2 = pointArray[idx+1]; 
                        if (!p1 || !p2) return null; 
                        const dStart = vertexDistances[idx]; const dEnd = vertexDistances[idx+1]; const segmentLen = dEnd - dStart; const ratio = segmentLen > 0.001 ? (dist - dStart) / segmentLen : 0; 
                        return new THREE.Vector3().lerpVectors(p1, p2, ratio); 
                    };
                    
                    const getRallyPositionByDist = (dist) => {
                        const path = rallyPathRef.current;
                        const dists = rallyDistancesRef.current;
                        if (!path || path.length < 2 || dists.length < 2) return new THREE.Vector3();
                        const totalLen = dists[dists.length - 1]; let safeDist = dist; if (safeDist < 0) safeDist += totalLen; safeDist = safeDist % totalLen;
                        let idx = 0; let min = 0, max = dists.length - 1; while (min <= max) { let mid = Math.floor((min + max) / 2); if (dists[mid] <= safeDist) { idx = mid; min = mid + 1; } else { max = mid - 1; } } if (idx >= dists.length - 1) idx = dists.length - 2;
                        const dStart = dists[idx]; const dEnd = dists[idx+1]; const segmentLen = dEnd - dStart; const ratio = segmentLen > 0.00001 ? (safeDist - dStart) / segmentLen : 0;
                        const p1 = path[idx]; const p2 = path[idx+1]; return new THREE.Vector3().lerpVectors(p1, p2, ratio);
                    };

                    const animate = () => { 
                        if (!isMountedRef.current) return;
                        animationId = requestAnimationFrame(animate); 
                        const delta = Math.min(clock.current.getDelta(), 0.1);
                        spherical.radius = Math.max(50, Math.min(1500, spherical.radius)); 
                        let targetPos = new THREE.Vector3(0, 0, 0); cameraTarget.lerp(targetPos, 0.1); 
                        const camOffset = new THREE.Vector3().setFromSpherical(spherical); camera.position.copy(cameraTarget).add(camOffset); camera.lookAt(cameraTarget);
                        const shouldMove = !pausedRef.current && (raceStateRef.current === 'idle' || raceStateRef.current === 'racing'); const nowTime = Date.now();
                        
                        if (carMeshes.length > 0) { 
                            const voltageFactor = trackVoltage / 12.0;
                            // Iterar sobre todos los coches físicos, pero solo procesar/renderizar los activos
                            physicsState.current.forEach((car, idx) => {
                                const physicsGroup = carMeshes[idx]; 
                                if (!physicsGroup) return; 
                                
                                // GESTIÓN DE VISIBILIDAD SEGÚN MODO
                                const isActive = idx < activeCarCountRef.current;
                                physicsGroup.visible = isActive;
                                
                                // Si no está activo, no calculamos física ni actualizamos el Sprite
                                if (!isActive) return;
                                
                                const setup = carSetupsRef.current[car.id];
                                const gearRatio = setup.gearTeeth / setup.pinionTeeth; const maxSpeed = (setup.motorRPM / 150) * (3.0 / gearRatio) * voltageFactor; const acceleration = (setup.motorTorque / setup.weight) * gearRatio * voltageFactor * 80;
                                
                                if (shouldMove) { if (car.speed < maxSpeed) car.speed += acceleration * delta; if (car.speed > maxSpeed) car.speed -= acceleration * delta; car.distance += car.speed * delta; }
                                
                                // ... [PHYSICS LOGIC UNCHANGED FOR RALLY AND STANDARD] ...
                                if (hasRotonda && rallyPathRef.current.length > 0 && rallyDistancesRef.current.length > 0) {
                                    const rallyTotalLen = rallyDistancesRef.current[rallyDistancesRef.current.length - 1]; 
                                    if (car.distance >= rallyTotalLen) { 
                                        car.distance -= rallyTotalLen; 
                                        const registerLap = () => { if (car.lapStartTime > 0) { const lapTime = nowTime - car.lapStartTime; car.lastLapTime = lapTime; if (lapTime < car.bestLapTime) car.bestLapTime = lapTime; car.totalLapTime += lapTime; car.completedLaps++; } car.lapStartTime = nowTime; };
                                        
                                        // GESTIÓN DE VUELTAS (RALLY): Sumar en pruebas, Restar en carrera
                                        if (raceStateRef.current === 'idle') { 
                                            registerLap(); 
                                            car.laps++; 
                                        } else if (raceStateRef.current === 'racing') { 
                                            registerLap(); 
                                            car.laps--; 
                                            if (car.laps <= 0) { 
                                                raceStateRef.current = 'finished'; 
                                                setRaceState('finished'); 
                                                setWinnerId(car.id); 
                                                if (timerIntervalRef.current) clearInterval(timerIntervalRef.current); 
                                                playRaceSound('green'); 
                                            } 
                                        }
                                    }
                                    const finalPos = getRallyPositionByDist(car.distance);
                                    const tangentSample = getRallyPositionByDist(car.distance + 0.5);
                                    const dir = new THREE.Vector3().subVectors(tangentSample, finalPos).normalize();
                                    const targetLook = finalPos.clone().add(dir.multiplyScalar(10.0));
                                    car.worldPos.copy(finalPos);
                                    physicsGroup.position.copy(finalPos).add(new THREE.Vector3(0, 0.2, 0));
                                    const targetMatrix = new THREE.Matrix4(); const up = new THREE.Vector3(0, 1, 0); targetMatrix.lookAt(finalPos, targetLook, up);
                                    const targetRotation = new THREE.Quaternion(); targetRotation.setFromRotationMatrix(targetMatrix);
                                    physicsGroup.quaternion.slerp(targetRotation, 20.0 * delta);
                                } 
                                else {
                                    if (shouldMove && car.distance >= totalDist) { 
                                        car.distance -= totalDist;
                                        const registerLap = () => { if (car.lapStartTime > 0) { const lapTime = nowTime - car.lapStartTime; car.lastLapTime = lapTime; if (lapTime < car.bestLapTime) car.bestLapTime = lapTime; car.totalLapTime += lapTime; car.completedLaps++; } car.lapStartTime = nowTime; };
                                        
                                        // GESTIÓN DE VUELTAS (ESTÁNDAR): Sumar en pruebas, Restar en carrera
                                        if (raceStateRef.current === 'idle') { 
                                            registerLap(); 
                                            car.laps++; 
                                        } else if (raceStateRef.current === 'racing') { 
                                            registerLap(); 
                                            car.laps--; 
                                            if (car.laps <= 0) { 
                                                raceStateRef.current = 'finished'; 
                                                setRaceState('finished'); 
                                                setWinnerId(car.id); 
                                                if (timerIntervalRef.current) clearInterval(timerIntervalRef.current); 
                                                playRaceSound('green'); 
                                            } 
                                        }
                                    }
                                    const currentPiece = pieceMapRef.current.find(p => car.distance >= p.distStart && car.distance < p.distEnd);
                                    if (currentPiece) {
                                        if (car.lastPieceIndex !== currentPiece.index) { 
                                            car.lastPieceIndex = currentPiece.index; 
                                            
                                            // Resetear estado de cambio si ha terminado la pieza
                                            if (car.isChanging) { 
                                                car.isChanging = false; 
                                                car.currentLane = car.targetLane; 
                                                car.changeProgress = 0; 
                                            } 
                                            
                                            // Lógica de Boxes: Si entró a boxes, sigue en boxes hasta la salida
                                            if (car.targetLane === LANE_PIT && currentPiece.isPitSection) { 
                                                car.currentLane = LANE_PIT; 
                                            } else if (car.currentLane !== LANE_PIT) { 
                                                car.currentLane = car.targetLane; 
                                            } 

                                            // DECISIÓN DE CAMBIO DE CARRIL (SOLO SI DIGITAL ESTÁ ACTIVO)
                                            // Restricción BLINDADA: Si el modo es GRID (Preparación) o ANALOG, se fuerza isDigitalMode = false
                                            const isDigitalMode = laneActiveRef.current && activeButtonRef.current !== 'GRID' && activeButtonRef.current !== 'ANALOG';

                                            if (isDigitalMode && currentPiece.canChangeLane && shouldMove) { 
                                                let nextL = car.currentLane; 
                                                let shouldChange = false; 
                                                
                                                if (car.currentLane !== LANE_PIT) { 
                                                    if (currentPiece.subtype === 'digital_x') { 
                                                        if (Math.random() > 0.5) { nextL = (car.currentLane === LANE_1) ? LANE_2 : LANE_1; shouldChange = true; } 
                                                    } else if (currentPiece.subtype === 'change_right' && car.currentLane === LANE_1) { 
                                                        if (Math.random() > 0.5) { nextL = LANE_2; shouldChange = true; } 
                                                    } else if (currentPiece.subtype === 'change_left' && car.currentLane === LANE_2) { 
                                                        if (Math.random() > 0.5) { nextL = LANE_1; shouldChange = true; } 
                                                    } else if (currentPiece.type === 'pit_entry') { 
                                                        const pitOnRight = !currentPiece.invert; 
                                                        const entryLane = pitOnRight ? LANE_2 : LANE_1; 
                                                        if (car.currentLane === entryLane) { 
                                                            if (Math.random() > 0.95) { nextL = LANE_PIT; shouldChange = true; } 
                                                        } 
                                                    } 
                                                } 
                                                
                                                if (currentPiece.type === 'pit_exit' && car.currentLane === LANE_PIT) { 
                                                    const pitOnRight = !currentPiece.invert; 
                                                    nextL = pitOnRight ? LANE_2 : LANE_1; 
                                                    shouldChange = true; 
                                                } 
                                                
                                                if (shouldChange) { 
                                                    car.isChanging = true; 
                                                    car.targetLane = nextL; 
                                                    car.changeProgress = 0; 
                                                } 
                                            } 
                                        }
                                        let posL1 = getPositionAtDistance(rails.lane1, car.distance); let posL2 = getPositionAtDistance(rails.lane2, car.distance); let posPit = getPositionAtDistance(rails.pit, car.distance); 
                                        if (!posL1 && rails.lane2.length > 0) posL1 = posL2; if (!posL2 && rails.lane1.length > 0) posL2 = posL1; if (!posPit && posL2) posPit = posL2;
                                        let mixFactor; if (car.isChanging) { const pieceLen = currentPiece.distEnd - currentPiece.distStart; const localDist = car.distance - currentPiece.distStart; car.changeProgress = localDist / pieceLen; mixFactor = (1 - Math.cos(car.changeProgress * Math.PI)) / 2; } else { mixFactor = 0; }
                                        let vOrigin, vTarget; const getLaneVec = (l) => { if (l === LANE_PIT) return posPit; if (l === LANE_2) return posL2; return posL1; }; if (car.isChanging) { vOrigin = getLaneVec(car.currentLane); vTarget = getLaneVec(car.targetLane); } else { vOrigin = getLaneVec(car.currentLane); vTarget = vOrigin; } 
                                        if (vOrigin && vTarget) {
                                            const finalPos = new THREE.Vector3().lerpVectors(vOrigin, vTarget, mixFactor);
                                            const lookAheadDist = car.distance + 1.0; let nextDist = lookAheadDist >= totalDist ? lookAheadDist - totalDist : lookAheadDist; 
                                            let fPosL1 = getPositionAtDistance(rails.lane1, nextDist); if(!fPosL1 && rails.lane2.length>0) fPosL1 = getPositionAtDistance(rails.lane2, nextDist);
                                            let fPosL2 = getPositionAtDistance(rails.lane2, nextDist); if(!fPosL2 && rails.lane1.length>0) fPosL2 = getPositionAtDistance(rails.lane1, nextDist);
                                            let fPosPit = getPositionAtDistance(rails.pit, nextDist); if(!fPosPit) fPosPit = fPosL2; 
                                            const getLaneVecFwd = (l) => { if (l===LANE_PIT) return fPosPit; if (l===LANE_2) return fPosL2; return fPosL1; }; let fOrigin, fTarget; if (car.isChanging) { fOrigin = getLaneVecFwd(car.currentLane); fTarget = getLaneVecFwd(car.targetLane); } else { fOrigin = getLaneVecFwd(car.currentLane); fTarget = fOrigin; } 
                                            if (fOrigin && fTarget) {
                                                const finalLookAt = new THREE.Vector3().lerpVectors(fOrigin, fTarget, mixFactor); car.worldPos.copy(finalPos);
                                                // AJUSTE FÍSICA: Bajamos -0.19 para compensar la altura del raíl (0.20) y tocar asfalto
                                                physicsGroup.position.copy(finalPos).add(new THREE.Vector3(0, -0.19, 0)); 
                                                const tangent = new THREE.Vector3().subVectors(finalLookAt, finalPos).normalize(); const up = new THREE.Vector3(0, 1, 0); let axisX = new THREE.Vector3().crossVectors(up, tangent).normalize(); if (axisX.lengthSq() < 0.001) axisX = new THREE.Vector3(1, 0, 0); const axisY = new THREE.Vector3().crossVectors(tangent, axisX).normalize(); const m = new THREE.Matrix4(); m.makeBasis(axisX, axisY, tangent); physicsGroup.quaternion.setFromRotationMatrix(m);
                                                if (currentPiece.type === 'curve' && currentPiece.radius < 25) { const drift = (currentPiece.direction === 'left' ? 1 : -1) * 0.15; physicsGroup.rotateY(drift); } if (car.isChanging) { let dir = 0; if (car.targetLane === LANE_PIT) dir = 1; else if (car.currentLane === LANE_PIT) dir = -1; else dir = (car.targetLane === LANE_2) ? 1 : -1; physicsGroup.rotateY(dir * -0.15 * Math.sin(car.changeProgress * Math.PI)); }
                                            }
                                        }
                                    }
                                }
                            });
                            
                            // COLISIONES: Solo entre coches activos
                            if (shouldMove && activeCarCountRef.current > 1 && !hasRotonda) {
                                for(let i=0; i < activeCarCountRef.current - 1; i++) {
                                    for(let j=i+1; j < activeCarCountRef.current; j++) {
                                        const c1 = physicsState.current[i];
                                        const c2 = physicsState.current[j];
                                        if(!c1.isDerailled && !c2.isDerailled) {
                                            const isInvulnerable = nowTime < c1.invulnerableUntil || nowTime < c2.invulnerableUntil;
                                            if (!isInvulnerable) {
                                                const dist = c1.worldPos.distanceTo(c2.worldPos);
                                                if (dist < 7.5) {
                                                    [c1, c2].forEach(c => { c.isDerailled = true; c.recoverTime = nowTime + 2000; c.velocity.set( (Math.random() - 0.5) * 50, 10 + Math.random() * 20, (Math.random() - 0.5) * 50 ); });
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            const now = Date.now(); if (shouldMove && now - lastUIUpdate.current > 100) { 
                                const currentTrackLen = (hasRotonda && rallyDistancesRef.current.length > 0) ? rallyDistancesRef.current[rallyDistancesRef.current.length - 1] : totalDist;
                                const carsWithScore = physicsState.current.slice(0, activeCarCountRef.current).map(c => { 
                                    let lapsCompleted = 0; 
                                    if (raceStateRef.current === 'racing') { 
                                        lapsCompleted = targetLapsRef.current - c.laps; 
                                    } else { 
                                        lapsCompleted = c.laps; 
                                    } 
                                    const progress = c.distance / currentTrackLen; 
                                    return { ...c, score: lapsCompleted + progress }; 
                                }); 
                                carsWithScore.sort((a, b) => b.score - a.score); 
                                const leaderId = carsWithScore[0].id; let best = Infinity; let leaderL = 0; physicsState.current.forEach(c => { if (c.bestLapTime < best) best = c.bestLapTime; if (c.id === leaderId) leaderL = c.laps; }); 
                                
                                // UPDATE TELEMETRY (Sliced to active cars)
                                setTelemetry(physicsState.current.slice(0, activeCarCountRef.current).map(c => { const totalDistCm = (c.completedLaps * currentTrackLen) + c.distance; const activeTimeSec = c.totalLapTime > 0 ? (c.totalLapTime / 1000) : 1; const avgSpeedVal = (totalDistCm / activeTimeSec) * 1.15; return { id: c.id, speed: Math.round(c.speed * 1.15), avgSpeed: Math.round(avgSpeedVal > 0 ? avgSpeedVal : 0), lastLap: c.lastLapTime, bestLap: c.bestLapTime === Infinity ? 0 : c.bestLapTime, averageLap: c.completedLaps > 0 ? (c.totalLapTime / c.completedLaps) : 0, currentLap: (c.lapStartTime > 0 && shouldMove) ? (now - c.lapStartTime) : 0, laps: c.laps, position: carsWithScore.findIndex(x => x.id === c.id) + 1, isCrashed: c.isDerailled }; })); 
                                
                                setRacePositions(carsWithScore.map(c => c.id)); setLeaderLaps(leaderL); setGlobalFastestLap(best); lastUIUpdate.current = now; 
                            }
                        } 
                        if (renderer && scene && camera) renderer.render(scene, camera); 
                    };
                    
                    animate(); 
                    const dom = renderer.domElement; window.addEventListener('resize', onResize); dom.addEventListener('mousedown', onMouseDown); window.addEventListener('mousemove', onMouseMove); window.addEventListener('mouseup', onMouseUp); dom.addEventListener('touchstart', onTouchStart, {passive: false}); dom.addEventListener('touchmove', onTouchMove, {passive: false}); dom.addEventListener('touchend', onTouchEnd); dom.addEventListener('wheel', onWheel, {passive:false});
                };
                
                init3D(); 
                return () => { 
                    isMountedRef.current = false; window.removeEventListener('resize', onResize); window.removeEventListener('mousemove', onMouseMove); window.removeEventListener('mouseup', onMouseUp); 
                    if(renderer){ const dom = renderer.domElement; dom.removeEventListener('mousedown', onMouseDown); dom.removeEventListener('touchstart', onTouchStart); dom.removeEventListener('touchmove', onTouchMove); dom.removeEventListener('touchend', onTouchEnd); dom.removeEventListener('wheel', onWheel); if(animationId) cancelAnimationFrame(animationId); renderer.dispose(); try { if (scene) { scene.traverse(object => { if (object.geometry) object.geometry.dispose(); if (object.material) { if (Array.isArray(object.material)) object.material.forEach(m => m.dispose()); else object.material.dispose(); } }); } } catch(e) { console.warn("Error cleaning 3D scene", e); } } 
                };
            }, [circuitData, bridgeStrategy]); 

            return ( 
                <div className="absolute inset-0 z-50 bg-[#3b5f7d] text-white font-sans overflow-hidden animate-in" onPointerMove={handleTelemetryDragMove} onPointerUp={handleTelemetryDragUp}> 
                    <div ref={containerRef} className="absolute inset-0 w-full h-full" /> 
                    {validationError && (<div className="absolute top-20 left-1/2 transform -translate-x-1/2 bg-red-600/90 text-white px-6 py-4 rounded-xl shadow-[0_0_20px_rgba(220,38,38,0.6)] flex items-center gap-4 z-[100] animate-in backdrop-blur-md border border-red-400"><AlertTriangle size={32} className="animate-bounce"/><div><h3 className="font-bold text-lg leading-tight">IMPOSIBLE INICIAR</h3><p className="text-sm opacity-90">{validationError}</p></div></div>)}
                    
                    {/* MENÚ DE PAUSA (SOLO PAUSA) */}
                    {paused && (
                        <div className="absolute inset-0 z-[90] bg-black/60 backdrop-blur-sm flex flex-col items-center justify-center animate-in">
                            <h2 className="text-6xl font-black text-yellow-500 tracking-[0.2em] mb-12 drop-shadow-[0_0_15px_rgba(234,179,8,0.8)] animate-pulse">PAUSA</h2>
                            
                            <div className="flex gap-6">
                                <button onClick={() => setPaused(false)} className="px-10 py-5 bg-white text-black font-black text-xl rounded-full hover:scale-105 transition shadow-[0_0_40px_rgba(255,255,255,0.5)] flex items-center gap-3 border-4 border-gray-300">
                                    <Play size={24} fill="black"/> CONTINUAR
                                </button>
                                
                                <button onClick={handleStopRace} className="px-10 py-5 bg-red-600 text-white font-black text-xl rounded-full hover:scale-105 transition shadow-[0_0_40px_rgba(220,38,38,0.5)] flex items-center gap-3 border-4 border-red-400">
                                    <Square size={24} fill="white"/> STOP / REINICIO
                                </button>
                            </div>
                        </div>
                    )}

                    {/* MENÚ DE GUARDAR CONFIGURACIÓN (INDEPENDIENTE) */}
                    {showSaveMenu && (
                        <div className="absolute inset-0 z-[95] bg-black/80 backdrop-blur-md flex items-center justify-center animate-in" onClick={() => setShowSaveMenu(false)}>
                            <div className="bg-[#0a0a0a] p-8 rounded-3xl border border-[#39ff14] flex flex-col items-center gap-8 shadow-[0_0_60px_rgba(57,255,20,0.3)] relative" onClick={e => e.stopPropagation()}>
                                <button onClick={() => setShowSaveMenu(false)} className="absolute top-4 right-4 text-gray-500 hover:text-white transition"><X size={24}/></button>
                                
                                <div className="flex flex-col items-center gap-2">
                                    <div className="p-4 rounded-full bg-[#39ff14]/10 border border-[#39ff14]/50 text-[#39ff14] shadow-[0_0_20px_rgba(57,255,20,0.2)]">
                                        <Save size={32}/>
                                    </div>
                                    <h3 className="font-black tracking-widest text-xl text-white uppercase mt-2">Guardar Telemetría</h3>
                                    <p className="text-gray-400 text-xs uppercase tracking-wider">Selecciona el piloto para exportar datos</p>
                                </div>

                                <div className="flex gap-4">
                                    <button onClick={() => { saveCarConfig(1); setShowSaveMenu(false); }} className="group w-40 py-4 bg-blue-900/30 hover:bg-blue-600 text-blue-400 hover:text-white font-bold rounded-2xl transition border border-blue-500/50 hover:border-blue-400 shadow-[0_0_20px_rgba(37,99,235,0.1)] hover:shadow-[0_0_30px_rgba(37,99,235,0.5)] flex flex-col items-center gap-1">
                                        <span className="text-[10px] opacity-70 tracking-widest uppercase">Equipo 1</span>
                                        <span className="text-lg tracking-wider group-hover:scale-110 transition-transform">PILOTO 1</span>
                                        <CloudDownload size={16} className="mt-1 opacity-50 group-hover:opacity-100"/>
                                    </button>
                                    <button 
                                        onClick={() => { if(!hasRotonda) { saveCarConfig(2); setShowSaveMenu(false); } }} 
                                        disabled={hasRotonda}
                                        className={`group w-40 py-4 font-bold rounded-2xl transition border flex flex-col items-center gap-1 ${hasRotonda ? 'bg-gray-900 border-gray-800 text-gray-700 cursor-not-allowed' : 'bg-red-900/30 hover:bg-red-600 text-red-400 hover:text-white border-red-500/50 hover:border-red-400 shadow-[0_0_20px_rgba(220,38,38,0.1)] hover:shadow-[0_0_30px_rgba(220,38,38,0.5)]'}`}
                                    >
                                        <span className="text-[10px] opacity-70 tracking-widest uppercase">Equipo 2</span>
                                        <span className="text-lg tracking-wider group-hover:scale-110 transition-transform">PILOTO 2</span>
                                        <CloudDownload size={16} className="mt-1 opacity-50 group-hover:opacity-100"/>
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    <div className="absolute top-10 left-1/2 transform -translate-x-1/2 z-[70] flex items-center gap-16 pointer-events-none w-full justify-center px-10">
                        <div className="flex flex-col gap-3 pointer-events-auto animate-in items-center">
                            <button onClick={enterGridMode} disabled={raceState === 'racing' || raceState === 'countdown'} className={`px-5 py-2.5 rounded-lg text-[10px] font-black tracking-[0.2em] border-2 uppercase transition-all duration-300 flex items-center justify-center text-center w-40 ${activeButton === 'GRID' ? 'bg-[#22d3ee] border-[#22d3ee] text-black shadow-[0_0_30px_rgba(34,211,238,0.8),0_0_10px_rgba(34,211,238,1)] scale-105 opacity-100 z-10' : 'bg-gray-900/80 border-gray-700 text-gray-400 shadow-none scale-100 opacity-100 hover:text-gray-200 hover:border-gray-500'}`}>PREPARACIÓN</button>
                            <button onClick={startPracticeMode} disabled={raceState === 'racing' || raceState === 'countdown'} className={`px-5 py-2.5 rounded-lg text-[10px] font-black tracking-[0.2em] border-2 uppercase transition-all duration-300 flex items-center justify-center text-center w-40 ${activeButton === 'PRACTICE' ? 'bg-[#a3e635] border-[#a3e635] text-black shadow-[0_0_30px_rgba(163,230,53,0.8),0_0_10px_rgba(163,230,53,1)] scale-105 opacity-100 z-10' : 'bg-gray-900/80 border-gray-700 text-gray-400 shadow-none scale-100 opacity-100 hover:text-gray-200 hover:border-gray-500'}`}>
                                {hasRotonda ? 'CRONO RALLY' : 'PRACTICAR'}
                            </button>
                        </div>
                        <div className="flex flex-col items-center mx-2 shrink-0">
                            <div className="bg-black px-5 py-4 rounded-[1.5rem] border-4 border-gray-800 flex gap-4 shadow-[0_0_60px_black] backdrop-blur-md relative z-10">
                                {[1, 2, 3, 4, 5].map(n => { const isRed = raceState === 'countdown' && activeLights >= n; const isGreen = raceState === 'racing' || raceState === 'idle'; let bg = 'bg-[#0a0a0a]'; let shadow = 'border-gray-800 opacity-60'; if (isGreen) { bg = 'bg-[#39ff14]'; shadow = 'shadow-[0_0_40px_#39ff14] border-[#39ff14] scale-110 opacity-100'; } else if (isRed) { bg = 'bg-[#ff0000]'; shadow = 'shadow-[0_0_40px_#ff0000] border-[#ff0000] scale-110 opacity-100'; } return <div key={n} className={`w-10 h-10 rounded-full border-4 ${bg} ${shadow} transition-all duration-100`}></div> })}
                            </div>
                            <button 
                                onClick={() => setBridgeStrategy(s => s === 'smart' ? 'index' : s === 'index' ? 'inverse' : 'smart')} 
                                className="pointer-events-auto mt-3 px-3 py-1 bg-black/60 border border-white/20 rounded-full text-[8px] font-bold text-gray-400 hover:text-white hover:border-white/50 transition flex items-center gap-2 backdrop-blur-sm"
                                title="Cambiar lógica de elevación de puentes"
                            >
                                <span className="uppercase tracking-widest">PUENTES:</span>
                                <span className={`text-[#39ff14] ${bridgeStrategy === 'smart' ? 'animate-pulse' : ''}`}>
                                    {bridgeStrategy === 'smart' ? 'AUTO (SMART)' : bridgeStrategy === 'index' ? 'CRONO (TIME)' : 'INV (INVERT)'}
                                </span>
                            </button>

                            {activeButton === 'GRID' && (<div className="mt-2 bg-black/80 border-2 border-[#39ff14] px-6 py-2 rounded-xl shadow-[0_0_30px_rgba(57,255,20,0.4)] backdrop-blur-md animate-in flex flex-col items-center transform scale-100"><span className="text-[#39ff14] font-black text-4xl tracking-[0.15em] drop-shadow-[0_0_15px_rgba(57,255,20,0.8)] font-digital">{formatTime(elapsedTime)}</span></div>)}
                            {raceState === 'racing' && elapsedTime < 3000 && <div className="absolute top-24 text-[#39ff14] font-black text-7xl italic tracking-tighter animate-ping drop-shadow-[0_0_40px_rgba(57,255,20,1)] scale-150 z-50">GO!</div>}
                        </div>
                        <div className="flex flex-col gap-3 pointer-events-auto animate-in items-center">
                            {!hasRotonda && (
                                <>
                                    <button onClick={handleAnalogMode} className={`px-5 py-2.5 rounded-lg text-[10px] font-black tracking-[0.2em] border-2 uppercase transition-all duration-300 flex items-center justify-center text-center w-40 ${activeButton === 'ANALOG' ? 'bg-[#fbbf24] border-[#fbbf24] text-black shadow-[0_0_30px_rgba(251,191,36,0.8),0_0_10px_rgba(251,191,36,1)] scale-105 opacity-100 z-10' : 'bg-gray-900/80 border-gray-700 text-gray-400 shadow-none scale-100 opacity-100 hover:text-gray-200 hover:border-gray-500'}`}>ANALÓGICO</button>
                                    <button onClick={handleDigitalMode} className={`px-5 py-2.5 rounded-lg text-[10px] font-black tracking-[0.2em] border-2 uppercase transition-all duration-300 flex items-center justify-center text-center w-40 ${activeButton === 'DIGITAL' ? 'bg-[#d946ef] border-[#d946ef] text-black shadow-[0_0_30px_rgba(217,70,239,0.8),0_0_10px_rgba(217,70,239,1)] scale-105 opacity-100 z-10' : 'bg-gray-900/80 border-gray-700 text-gray-400 shadow-none scale-100 opacity-100 hover:text-gray-200 hover:border-gray-500'}`}>DIGITAL</button>
                                </>
                            )}
                            {hasRotonda && (
                                <div className="px-5 py-2.5 rounded-lg text-[10px] font-black tracking-[0.2em] border-2 border-[#39ff14] bg-[#39ff14]/10 text-[#39ff14] shadow-[0_0_20px_rgba(57,255,20,0.3)] w-40 text-center animate-pulse">
                                    MODO RALLY
                                </div>
                            )}
                        </div>
                    </div>

                    {activeButton === 'GRID' && (
                        <>
                            <div className="absolute top-10 left-10 z-[60] flex flex-col gap-4 pointer-events-auto animate-in origin-top-left scale-90 xl:scale-100 max-h-[85vh] overflow-y-auto hide-scrollbar pb-20">
                                <GearShowcase selectedCarId={selectedCarId} currentConfig={carSetups[selectedCarId]} onUpdate={handleUpdateConfig} />
                                <PinionShowcase selectedCarId={selectedCarId} currentConfig={carSetups[selectedCarId]} onUpdate={handleUpdateConfig} />
                                <WeightShowcase selectedCarId={selectedCarId} currentConfig={carSetups[selectedCarId]} onUpdate={handleUpdateConfig} />
                                <VoltageShowcase voltage={trackVoltage} setVoltage={setTrackVoltage}/>
                            </div>
                            <div className="absolute top-10 right-10 z-[60] flex flex-col gap-4 pointer-events-auto animate-in origin-top-right scale-90 xl:scale-100 items-end">
                                <MotorShowcase selectedCarId={selectedCarId} currentConfig={carSetups[selectedCarId]} onUpdate={handleUpdateConfig} />
                                <TireShowcase selectedCarId={selectedCarId} currentConfig={carSetups[selectedCarId]} onUpdate={handleUpdateConfig} />
                            </div>
                            <TelemetryPanel carId={selectedCarId} data={telemetry.find(t => t.id === selectedCarId)} config={carSetups[selectedCarId]} style={{ left: telemetryPos.x, top: telemetryPos.y, transform: 'scale(0.9)', transformOrigin: 'top left' }} onDragStart={handleTelemetryDragStart} />
                        </>
                    )}

                    <div className="absolute bottom-6 left-6 pointer-events-auto z-[70] flex flex-col md:flex-row items-start md:items-center gap-4 scale-90 md:scale-100 origin-bottom-left">
                        <button onClick={onClose} className="flex items-center gap-2 bg-red-600/90 hover:bg-red-500 text-white border border-red-400 px-6 py-3 rounded-full font-bold text-sm tracking-wider transition shadow-lg backdrop-blur-sm hover:scale-105 h-12"><X size={20}/> VOLVER</button>
                        <div className="flex gap-6 items-center bg-black/80 px-6 py-2 rounded-full border border-white/10 backdrop-blur-xl shadow-[0_0_30px_rgba(0,0,0,0.5)] h-12">
                            
                            {/* CONTROLES PILOTOS Y VUELTAS (SIEMPRE VISIBLES) */}
                            <div className="flex gap-4 items-center border-r border-white/20 pr-4 mr-1">
                                {/* SELECTOR PILOTOS */}
                                <div className="flex items-center gap-2">
                                    <div className="flex flex-col items-end leading-none">
                                        <span className="text-[9px] font-bold text-gray-400 uppercase tracking-wider">PILOTOS</span>
                                        <span className="text-[7px] text-[#39ff14] font-mono font-bold">ACTIVOS</span>
                                    </div>
                                    <div className="flex items-center gap-1 bg-gray-900 p-0.5 rounded border border-gray-700">
                                        <button onClick={() => updateActiveCars(activeCarCount - 1)} disabled={activeCarCount <= 1} className="w-6 h-6 flex items-center justify-center hover:bg-gray-700 text-white rounded disabled:opacity-30"><Minus size={12}/></button>
                                        <div className="w-8 text-center font-digital text-[#39ff14] text-lg font-bold">{activeCarCount}</div>
                                        <button onClick={() => updateActiveCars(activeCarCount + 1)} disabled={activeCarCount >= 8} className="w-6 h-6 flex items-center justify-center hover:bg-gray-700 text-white rounded disabled:opacity-30"><Plus size={12}/></button>
                                    </div>
                                </div>

                                {/* SELECTOR VUELTAS */}
                                <div className="flex items-center gap-2">
                                    <div className="flex flex-col items-end leading-none">
                                        <span className="text-[9px] font-bold text-gray-400 uppercase tracking-wider">VUELTAS</span>
                                        <span className="text-[7px] text-[#fbbf24] font-mono font-bold">TARGET</span>
                                    </div>
                                    <div className="flex items-center gap-1 bg-gray-900 p-0.5 rounded border border-gray-700">
                                        <button onClick={() => setTargetLaps(prev => Math.max(1, prev - 1))} disabled={targetLaps <= 1} className="w-6 h-6 flex items-center justify-center hover:bg-gray-700 text-white rounded disabled:opacity-30"><Minus size={12}/></button>
                                        <div className="w-10 text-center font-digital text-[#fbbf24] text-lg font-bold">{targetLaps}</div>
                                        <button onClick={() => setTargetLaps(prev => Math.min(500, prev + 1))} disabled={targetLaps >= 500} className="w-6 h-6 flex items-center justify-center hover:bg-gray-700 text-white rounded disabled:opacity-30"><Plus size={12}/></button>
                                    </div>
                                </div>
                            </div>

                            <div className="flex gap-2">
                                <button onClick={handleStartClick} disabled={raceState === 'countdown'} className={`group px-5 py-1.5 rounded-full font-black text-[10px] tracking-widest border border-[#39ff14] bg-[#39ff14]/10 text-[#39ff14] hover:bg-[#39ff14] hover:text-black shadow-[0_0_15px_rgba(57,255,20,0.1)] hover:shadow-[0_0_25px_rgba(57,255,20,0.6)] transition-all flex items-center gap-2 active:scale-95 ${raceState === 'countdown' ? 'opacity-50 cursor-not-allowed' : ''}`}>
                                    <Play size={12} fill="currentColor" className="group-hover:scale-110 transition-transform"/> {raceState === 'grid' ? 'EMPEZAR' : 'REANUDAR'}
                                </button>
                                <button onClick={() => setPaused(true)} className="group px-5 py-1.5 rounded-full font-black text-[10px] tracking-widest border border-yellow-500 bg-yellow-500/10 text-yellow-500 hover:bg-yellow-500 hover:text-black shadow-[0_0_15px_rgba(234,179,8,0.1)] hover:shadow-[0_0_25px_rgba(234,179,8,0.6)] transition-all flex items-center gap-2 active:scale-95">
                                    <Pause size={12} fill="currentColor" className="group-hover:scale-110 transition-transform"/> PAUSA
                                </button>
                                <button onClick={() => setShowSaveMenu(true)} className="group px-4 py-1.5 rounded-full font-black text-[10px] tracking-widest border border-blue-400 bg-blue-500/10 text-blue-400 hover:bg-blue-500 hover:text-white shadow-[0_0_15px_rgba(96,165,250,0.1)] hover:shadow-[0_0_25px_rgba(96,165,250,0.6)] transition-all flex items-center gap-2 active:scale-95" title="Guardar Configuración">
                                    <Save size={12} className="group-hover:scale-110 transition-transform"/> GUARDAR
                                </button>
                                <button onClick={() => loadInputRef.current.click()} className="group px-4 py-1.5 rounded-full font-black text-[10px] tracking-widest border border-cyan-400 bg-cyan-500/10 text-cyan-400 hover:bg-cyan-500 hover:text-white shadow-[0_0_15px_rgba(34,211,238,0.1)] hover:shadow-[0_0_25px_rgba(34,211,238,0.6)] transition-all flex items-center gap-2 active:scale-95" title="Cargar Configuración al Coche Actual">
                                    <FolderOpen size={12} className="group-hover:scale-110 transition-transform"/> ABRIR
                                </button>
                                <input type="file" ref={loadInputRef} onChange={handleLoadConfig} accept=".json" className="hidden" />
                            </div>
                        </div>
                    </div>
                </div> 
            );
        };

        // --- NUEVO: VISOR GLB (HOMO VIEWER) MEJORADO ---
        const GLBViewer = ({ onClose, onLoad }) => {
            const mountRef = useRef(null);
            const inputRef = useRef(null); // Referencia imprescindible para el input de archivo
            const [status, setStatus] = useState("ESPERANDO ARCHIVO...");
            const rendererRef = useRef(null);
            const sceneRef = useRef(null);
            const cameraRef = useRef(null);
            const controlsRef = useRef(null);

            useEffect(() => {
                if (!mountRef.current) return;
                
                // Verificación de seguridad de librerías
                if (typeof THREE === 'undefined') {
                    setStatus("ERROR: THREE.JS NO CARGADO");
                    return;
                }
                if (typeof THREE.GLTFLoader === 'undefined') {
                    setStatus("ERROR: GLTFLOADER NO CARGADO");
                    return;
                }

                // 1. Inicializar con dimensiones seguras
                const width = mountRef.current.clientWidth || 300;
                const height = mountRef.current.clientHeight || 300;

                // 2. Escena y Fondo Transparente
                const scene = new THREE.Scene();
                // scene.background = new THREE.Color(0x222222); // Opcional: Color de fondo solido
                sceneRef.current = scene;

                // 3. Cámara
                const camera = new THREE.PerspectiveCamera(50, width / height, 0.01, 1000);
                camera.position.set(0, 2, 4);
                cameraRef.current = camera;

                // 4. Renderizador Robusto
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.outputEncoding = THREE.sRGBEncoding;
                mountRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                // 5. Iluminación de Estudio (Para evitar modelos negros)
                const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
                scene.add(hemiLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 2);
                dirLight.position.set(2, 5, 3);
                dirLight.castShadow = true;
                scene.add(dirLight);

                // 6. Ayudas Visuales
                const grid = new THREE.GridHelper(10, 10, 0x39ff14, 0x333333);
                scene.add(grid);
                const axes = new THREE.AxesHelper(1);
                scene.add(axes);

                // 7. Controles
                if (typeof THREE.OrbitControls !== 'undefined') {
                    const controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    controls.autoRotate = true; // Rotar para ver que funciona
                    controls.target.set(0, 0.5, 0);
                    controlsRef.current = controls;
                }

                // 8. Observer para redimensionado automático con corrección de bucle
                const resizeObserver = new ResizeObserver(entries => {
                    window.requestAnimationFrame(() => {
                        for (let entry of entries) {
                            const { width, height } = entry.contentRect;
                            if (width && height && renderer && camera) {
                                camera.aspect = width / height;
                                camera.updateProjectionMatrix();
                                renderer.setSize(width, height);
                            }
                        }
                    });
                });
                resizeObserver.observe(mountRef.current);

                // 9. Bucle de Animación
                let frameId;
                const animate = () => {
                    frameId = requestAnimationFrame(animate);
                    if (controlsRef.current) controlsRef.current.update();
                    renderer.render(scene, camera);
                };
                animate();

                return () => {
                    cancelAnimationFrame(frameId);
                    resizeObserver.disconnect();
                    if (renderer) {
                        renderer.dispose();
                        mountRef.current?.removeChild(renderer.domElement);
                    }
                };
            }, []);

            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                setStatus("CARGANDO...");
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const loader = new THREE.GLTFLoader();
                        loader.parse(event.target.result, '', (gltf) => {
                            const scene = sceneRef.current;
                            if (!scene) return;

                            // Limpiar solo modelos anteriores (mantener luces y helpers)
                            scene.children = scene.children.filter(obj => obj.isLight || obj.isGridHelper || obj.isAxesHelper);
                            
                            const model = gltf.scene;
                            
                            // Normalizar materiales para asegurar visibilidad
                            model.traverse(child => {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                    if (child.material) {
                                        child.material.side = THREE.DoubleSide; // Ver por dentro y fuera
                                        child.material.needsUpdate = true;
                                    }
                                }
                            });

                            // Centrar y Escalar Automáticamente
                            const box = new THREE.Box3().setFromObject(model);
                            const size = box.getSize(new THREE.Vector3());
                            const center = box.getCenter(new THREE.Vector3());

                            // Centrar en (0,0,0) interno
                            model.position.x += (model.position.x - center.x);
                            model.position.y += (model.position.y - center.y);
                            model.position.z += (model.position.z - center.z);

                            // Escalar para que quepa en un cubo de 2x2x2
                            const maxDim = Math.max(size.x, size.y, size.z);
                            const scale = maxDim > 0 ? 2.5 / maxDim : 1;
                            model.scale.set(scale, scale, scale);
                            
                            // Elevar sobre la rejilla
                            model.position.y += (size.y * scale) / 2;

                            scene.add(model);
                            setStatus(`VISUALIZANDO: ${file.name.toUpperCase()}`);
                            
                            // Callback para asignar al Piloto 1 automáticamente
                            if (onLoad) onLoad(file);

                        }, (err) => {
                            console.error(err);
                            setStatus("ERROR AL PARSEAR GLB");
                        });
                    } catch (err) {
                        console.error(err);
                        setStatus("ERROR DE LECTURA");
                    }
                };
                reader.readAsArrayBuffer(file);
                
                // CRÍTICO: Limpiar el valor del input
                e.target.value = '';
            };

            const triggerFileSelect = () => {
                if (inputRef.current) inputRef.current.click();
            };

            return (
                // CORRECCIÓN: Eliminado 'absolute bottom-28 left-0' para que respete al contenedor padre
                <div className="w-80 h-80 bg-[#0f172a] border-2 border-[#39ff14] rounded-xl shadow-[0_0_40px_rgba(57,255,20,0.2)] flex flex-col overflow-hidden animate-in z-50 pointer-events-auto relative">
                    <div className="bg-[#39ff14]/10 p-2 flex justify-between items-center border-b border-[#39ff14]/30">
                        <div className="flex items-center gap-2">
                            <span className="w-2 h-2 bg-[#39ff14] rounded-full animate-pulse"></span>
                            <h3 className="text-[10px] font-black text-white tracking-[0.2em]">VISOR HOMO</h3>
                        </div>
                        <div className="flex items-center gap-2">
                            <button 
                                onClick={triggerFileSelect}
                                className="flex items-center gap-1 bg-[#39ff14]/20 hover:bg-[#39ff14] text-[#39ff14] hover:text-black px-3 py-1 rounded text-[9px] font-bold transition border border-[#39ff14]/50 shadow-[0_0_10px_rgba(57,255,20,0.1)]"
                                title="Abrir archivo GLB/GLTF"
                            >
                                <FolderOpen size={10} /> ABRIR
                            </button>
                            <button onClick={onClose} className="text-[#39ff14] hover:text-white transition"><X size={14} /></button>
                        </div>
                    </div>
                    
                    <div className="flex-1 relative bg-black/50" ref={mountRef}>
                        <div className="absolute top-2 left-2 right-2 text-[8px] font-mono text-[#39ff14] bg-black/80 px-2 py-1 rounded pointer-events-none select-none border border-[#39ff14]/20 text-center">
                            {status}
                        </div>
                    </div>

                    <input 
                        ref={inputRef}
                        type="file" 
                        accept=".glb,.gltf" 
                        onChange={handleFileChange} 
                        className="hidden" 
                    />
                </div>
            );
        };

        function SlotDesigner() {
          const canvasRef = useRef(null); 
          const [activeBrand, setActiveBrand] = useState('NINCO'); 
          const [activeCategory, setActiveCategory] = useState('Rectas'); 
          const [history, setHistory] = useState([[]]); 
          const [historyStep, setHistoryStep] = useState(0); 
          const pieces = history[historyStep]; 
          
          const [showTelemetry, setShowTelemetry] = useState(false); 
          const [showHomoViewer, setShowHomoViewer] = useState(false); // NUEVO ESTADO PARA EL VISOR HOMO
          const [isFullScreen, setIsFullScreen] = useState(false); 
          
          const [view, setView] = useState({ x: window.innerWidth/2, y: window.innerHeight/2, scale: 5.0 }); 
          const [circuitOrigin, setCircuitOrigin] = useState({x: 0, y: 0}); 
          const [selectedPieceId, setSelectedPieceId] = useState(null); 
          const [isCircuitMoveMode, setIsCircuitMoveMode] = useState(false); 
          const [isDragging, setIsDragging] = useState(false); 
          const [dragStart, setDragStart] = useState({ x: 0, y: 0 }); 
          const dragMode = useRef('view'); 
          const lastPointerPos = useRef({ x: 0, y: 0 }); 
          const [bgImage, setBgImage] = useState(null); 
          const [bgSettings, setBgSettings] = useState({ x: 0, y: 0, scale: 5.0, opacity: 0.5 }); 
          const bgImgRef = useRef(null);
          const [showBoardTools, setShowBoardTools] = useState(false); 
          const [boardPoints, setBoardPoints] = useState([]); 
          const [boardClosed, setBoardClosed] = useState(false); 
          const [boardDim, setBoardDim] = useState({ width: 244, height: 122 }); 
          const [boardStep, setBoardStep] = useState(100);
          
          const DEFAULT_COLORS = ['#ef4444', '#3b82f6', '#22c55e', '#eab308', '#a855f7', '#ec4899', '#f97316', '#64748b'];
          // ACTUALIZADO: Inicialización de 8 Coches
          const [carSettings, setCarSettings] = useState(Array(8).fill(null).map((_, i) => ({ id: i + 1, name: `EQUIPO ${i + 1}`, color: DEFAULT_COLORS[i % DEFAULT_COLORS.length] })));
          const [customCarAssets, setCustomCarAssets] = useState(Object.fromEntries(Array.from({length: 8}, (_, i) => [i + 1, { obj: null, mtl: null, texture: null, objName: null, mtlName: null, texName: null, rotation: [0, 180, 0], yOffset: 0 }])));

          const activePointers = useRef(new Map()); 
          const prevPinchDist = useRef(null); 
          const piecePositions = useRef([]); 
          const imageCache = useRef(new Map()); 
          
          // FUNCIÓN PARA ASIGNAR GLB AL PILOTO 1
          const handleModelAssign = (file) => {
              if (file) {
                  const url = URL.createObjectURL(file);
                  setCustomCarAssets(prev => ({
                      ...prev,
                      1: { ...prev[1], glb: url, glbName: file.name }
                  }));
                  // Opcional: Feedback visual o log
                  console.log("Modelo GLB asignado al Piloto 1:", file.name);
              }
          };

          useEffect(() => { const loadingScreen = document.getElementById('loading-screen'); if (loadingScreen) { loadingScreen.style.opacity = '0'; setTimeout(() => loadingScreen.style.display = 'none', 1000); } }, []);
          const currentBrand = TRACK_DEFINITIONS[activeBrand]; const neonClass = currentBrand.uiClass;

          useEffect(() => {
            const canvas = canvasRef.current; if (!canvas) return; const ctx = canvas.getContext('2d'); canvas.width = window.innerWidth; canvas.height = window.innerHeight; 
            ctx.fillStyle = '#32527b'; ctx.fillRect(0,0, canvas.width, canvas.height);
            if (bgImage && bgImgRef.current) { ctx.save(); ctx.translate(view.x + bgSettings.x, view.y + bgSettings.y); ctx.scale(view.scale, view.scale); ctx.globalAlpha = bgSettings.opacity; const w = bgImgRef.current.width * (bgSettings.scale / 100), h = bgImgRef.current.height * (bgSettings.scale / 100); ctx.drawImage(bgImgRef.current, -w/2, -h/2, w, h); ctx.restore(); }
            ctx.strokeStyle = currentBrand.neonColor; ctx.globalAlpha = 0.1; ctx.lineWidth = 1; const gridSize = 10 * view.scale; const offsetX = view.x % gridSize; const offsetY = view.y % gridSize; ctx.beginPath(); for(let x = offsetX; x < ctx.canvas.width; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, ctx.canvas.height); } for(let y = offsetY; y < ctx.canvas.height; y += gridSize) { ctx.moveTo(0, y); ctx.lineTo(ctx.canvas.width, y); } ctx.stroke(); ctx.globalAlpha = 1.0;
            try { piecePositions.current = DrawEngine2D.renderTrack( ctx, pieces, view, circuitOrigin, activeBrand, selectedPieceId, imageCache, isCircuitMoveMode, boardPoints, boardClosed ); } catch (error) { console.error("Error drawing track:", error); }
          }, [pieces, view, bgImage, bgSettings, activeBrand, selectedPieceId, circuitOrigin, isCircuitMoveMode, boardPoints, boardClosed]);

          const pushHistory = (newPieces) => { const newHistory = history.slice(0, historyStep + 1); newHistory.push(newPieces); setHistory(newHistory); setHistoryStep(newHistory.length - 1); };
          const handleUndo = () => { if (historyStep > 0) { setHistoryStep(historyStep - 1); setSelectedPieceId(null); } }; const handleRedo = () => { if (historyStep < history.length - 1) { setHistoryStep(historyStep + 1); setSelectedPieceId(null); } };
          const addPiece = (p, d='left') => pushHistory([...pieces, { ...p, direction: d, uid: Date.now() }]); const removePiece = () => { if (selectedPieceId) { pushHistory(pieces.filter(p => p.uid !== selectedPieceId)); setSelectedPieceId(null); } else if (pieces.length > 0) { pushHistory(pieces.slice(0, -1)); } }; const toggleInvertPiece = () => { if(selectedPieceId) pushHistory(pieces.map(p => p.uid === selectedPieceId ? { ...p, invert: !p.invert } : p)); };
          const saveCircuit = () => { const blob = new Blob([JSON.stringify({ version: "1.0", date: new Date().toISOString(), brand: activeBrand, pieces, circuitOrigin, boardPoints, boardClosed }, null, 2)], { type: "application/json" }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = `circuito_${activeBrand.toLowerCase()}.json`; document.body.appendChild(link); link.click(); document.body.removeChild(link); };
          const loadCircuit = (e) => { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (event) => { try { const data = JSON.parse(event.target.result); if (data.brand && data.pieces) { setActiveBrand(data.brand); setHistory([data.pieces]); setHistoryStep(0); if (data.circuitOrigin) setCircuitOrigin(data.circuitOrigin); if (data.boardPoints) setBoardPoints(data.boardPoints); if(data.boardClosed !== undefined) setBoardClosed(data.boardClosed); } } catch (err) { alert("Error al leer JSON"); } }; reader.readAsText(file); };
          const createRectBoard = () => { const w = parseFloat(boardDim.width); const h = parseFloat(boardDim.height); if (isNaN(w) || isNaN(h)) return; setBoardPoints([ { x: -w/2, y: -h/2 }, { x: w/2, y: -h/2 }, { x: w/2, y: h/2 }, { x: -w/2, y: h/2 } ]); setBoardClosed(true); };
          const addBoardPoint = (dx, dy) => { if (boardClosed) { setBoardClosed(false); } let start = { x: 0, y: 0 }; if (boardPoints.length > 0) { start = boardPoints[boardPoints.length - 1]; } else { setBoardPoints([{x:0, y:0}, {x: dx, y: dy}]); return; } setBoardPoints([...boardPoints, { x: start.x + dx, y: start.y + dy }]); };
          const closeBoardPolygon = () => { if (boardPoints.length > 2) setBoardClosed(true); }; const clearBoard = () => { setBoardPoints([]); setBoardClosed(false); };
          const fitToScreen = () => { if (piecePositions.current.length === 0) { setView({ x: window.innerWidth/2, y: window.innerHeight/2, scale: 5.0 }); return; } let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity; piecePositions.current.forEach(p => { if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x; if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y; }); if (minX === Infinity) { setView({ x: window.innerWidth/2, y: window.innerHeight/2, scale: 5.0 }); return; } const centerX = (minX + maxX) / 2; const centerY = (minY + maxY) / 2; const offsetX = (window.innerWidth / 2) - centerX; const offsetY = (window.innerHeight / 2) - centerY; setView(prev => ({ ...prev, x: prev.x + offsetX, y: prev.y + offsetY })); };
          
          const toggleFullScreen = () => {
              if (!document.fullscreenElement) {
                  document.documentElement.requestFullscreen().then(() => setIsFullScreen(true)).catch(err => console.error(err));
              } else {
                  if (document.exitFullscreen) {
                      document.exitFullscreen().then(() => setIsFullScreen(false));
                  }
              }
          };

          const handleWheel = (e) => setView({ ...view, scale: Math.max(0.5, Math.min(20.0, view.scale - e.deltaY * 0.001 * view.scale)) });
          const handleDown = (e) => { 
              e.target.setPointerCapture(e.pointerId); 
              activePointers.current.set(e.pointerId, { x: e.clientX, y: e.clientY }); 
              
              if (activePointers.current.size === 1) { 
                  lastPointerPos.current = { x: e.clientX, y: e.clientY }; 
                  if (isCircuitMoveMode) { 
                      dragMode.current = 'origin'; 
                      setIsDragging(true); 
                      return; 
                  } 
                  
                  let foundId = null, minD = 1000; 
                  piecePositions.current.forEach((p, idx) => { 
                      const d = Math.sqrt(Math.pow(e.clientX - p.x, 2) + Math.pow(e.clientY - p.y, 2)); 
                      if (d < 40 * (view.scale / 5) && d < minD) { minD = d; foundId = pieces[idx].uid; } 
                  }); 
                  
                  if (foundId) { setSelectedPieceId(foundId); dragMode.current = 'view'; } 
                  else { setSelectedPieceId(null); dragMode.current = 'view'; } 
                  
                  setIsDragging(true); 
                  setDragStart({ x: e.clientX - view.x, y: e.clientY - view.y }); 
              } 
          };

          const handleMoveHandler = (e) => { 
              if (!activePointers.current.has(e.pointerId)) return; 
              activePointers.current.set(e.pointerId, { x: e.clientX, y: e.clientY }); 
              
              if (activePointers.current.size === 2 && prevPinchDist.current !== null) { 
                  const points = Array.from(activePointers.current.values()); 
                  const dist = Math.hypot(points[0].x - points[1].x, points[0].y - points[1].y); 
                  const delta = dist - prevPinchDist.current; 
                  const zoomFactor = delta * 0.015; 
                  setView(v => ({...v, scale: Math.max(0.5, Math.min(20, v.scale + zoomFactor * v.scale))})); 
                  prevPinchDist.current = dist; 
                  return; 
              } 
              
              if (activePointers.current.size === 1 && isDragging) { 
                  const dx = e.clientX - lastPointerPos.current.x;
                  const dy = e.clientY - lastPointerPos.current.y;

                  if (dragMode.current === 'origin') { 
                      // Mover Pista: Actualizamos el origen del circuito
                      // Dividimos por la escala para que el movimiento sea 1:1 con el ratón en pantalla
                      if (view.scale > 0) {
                          setCircuitOrigin(prev => ({ 
                              x: prev.x + dx / view.scale, 
                              y: prev.y + dy / view.scale 
                          })); 
                      }
                  } else { 
                      // Mover Vista (Pan): Actualizamos la vista global
                      setView(v => ({ ...v, x: v.x + dx, y: v.y + dy })); 
                  } 
                  lastPointerPos.current = { x: e.clientX, y: e.clientY }; 
              } 
          };

          const handleUp = (e) => { e.target.releasePointerCapture(e.pointerId); activePointers.current.delete(e.pointerId); if (activePointers.current.size < 2) prevPinchDist.current = null; if (activePointers.current.size === 0) setIsDragging(false); };
          const handleZoomIn = () => setView(v => ({ ...v, scale: Math.min(20, v.scale * 1.2) })); const handleZoomOut = () => setView(v => ({ ...v, scale: Math.max(0.5, v.scale / 1.2) }));
          const generateReport = () => { alert("Generando Informe..."); };
          const currentItems = TRACK_DEFINITIONS[activeBrand].pieces.filter(p=>p.cat === activeCategory || (activeCategory === 'RALLY' && p.cat === 'RALLY')); const categories = ['Rectas', 'Curvas', 'Digital', 'Boxes']; if (TRACK_DEFINITIONS[activeBrand].pieces.some(p => p.cat === 'RALLY')) categories.push('RALLY');

          return (
            <div className={`flex flex-col h-[100dvh] w-full bg-[#0a0a0a] overflow-hidden font-sans select-none text-gray-200 ${isCircuitMoveMode ? 'cursor-move' : 'cursor-grab'}`}>
              
              {showTelemetry && (
                  <ErrorBoundary fallback={
                      <div className="absolute inset-0 z-50 bg-black/95 flex flex-col items-center justify-center animate-in">
                          <AlertTriangle className="text-red-500 w-16 h-16 mb-4 animate-bounce"/>
                          <h2 className="text-2xl font-black text-red-500 tracking-widest mb-2">ERROR CRÍTICO 3D</h2>
                          <p className="text-gray-400 mb-6 text-sm">El motor de simulación ha encontrado un problema inesperado.</p>
                          <button onClick={() => setShowTelemetry(false)} className="px-6 py-3 bg-red-600 hover:bg-red-500 text-white font-bold rounded-full transition shadow-[0_0_20px_rgba(220,38,38,0.5)]">CERRAR VISOR Y VOLVER A 2D</button>
                      </div>
                  }>
                      <Telemetry3DViewer 
                          circuitData={{ brand: activeBrand, pieces: pieces }} 
                          carSettings={carSettings} 
                          customCarAssets={customCarAssets} 
                          onClose={() => setShowTelemetry(false)}
                      />
                  </ErrorBoundary>
              )}

              <div className="bg-[#0f172a] border-b border-[#1e293b] shadow-lg z-20 flex flex-col shrink-0 relative">
                  <div className="flex items-center gap-4 px-4 py-3 overflow-x-auto hide-scrollbar bg-black/50"> 
                      <div className="flex items-center gap-2 mr-4">
                          <h1 className="text-xl font-black tracking-tighter shrink-0" style={{ color: '#39ff14', textShadow: '0 0 15px rgba(57, 255, 20, 0.9), 0 0 30px rgba(57, 255, 20, 0.5)' }}> TRACKS & TELEMETRY </h1> 
                          <span className="text-[9px] bg-[#39ff14]/20 text-[#39ff14] border border-[#39ff14] px-1.5 py-0.5 rounded font-bold tracking-widest uppercase flex items-center gap-1"><Zap size={8} fill="currentColor"/> BLINDADO</span>
                      </div>
                      <div className="flex gap-4">{Object.keys(TRACK_DEFINITIONS).map(k => (<button key={k} onClick={()=>{setActiveBrand(k); setHistory([[]]); setHistoryStep(0); }} className={`text-sm font-bold px-4 py-2 rounded-full uppercase tracking-widest transition-all shrink-0 border ${activeBrand === k ? TRACK_DEFINITIONS[k].activeClass : 'bg-transparent border-[#334155] text-gray-500 hover:text-gray-300 hover:border-gray-400'}`}>{TRACK_DEFINITIONS[k].name}</button>))}</div> </div>
                  <div className="flex items-center overflow-x-auto hide-scrollbar px-4 py-2 gap-2 bg-[#1e293b] shadow-[inset_0_10px_20px_rgba(0,0,0,0.5)]"> 
                      {categories.map(cat => ( <button key={cat} onClick={() => setActiveCategory(cat)} className="px-6 py-2 text-xs font-bold rounded-lg uppercase shrink-0 transition-all duration-300 border backdrop-blur-sm" style={{ borderColor: activeCategory === cat ? currentBrand.neonColor : '#334155', color: activeCategory === cat ? '#ffffff' : '#64748b', backgroundColor: activeCategory === cat ? `${currentBrand.neonColor}20` : 'transparent', boxShadow: activeCategory === cat ? `0 0 15px ${currentBrand.neonColor}60, inset 0 0 10px ${currentBrand.neonColor}20` : 'none', textShadow: activeCategory === cat ? `0 0 10px ${currentBrand.neonColor}` : 'none' }}> {cat} </button> ))} 
                  </div>
                  <div className="h-20 flex items-center overflow-x-auto px-4 gap-3 bg-[#0f172a] border-t border-[#334155]"> {currentItems.map(p => ( <div key={p.id} className="shrink-0"> {p.type === 'curve' ? ( <div className={`flex flex-col border rounded-lg overflow-hidden w-32 ${neonClass}`}> <div className="bg-black/40 px-2 py-1 text-[10px] font-bold text-center border-b border-inherit">{p.label}</div> <div className="flex divide-x divide-inherit"><button onClick={()=>addPiece(p,'left')} className="flex-1 py-3 text-[10px] font-bold hover:bg-white/10 transition-colors">IZQ</button><button onClick={()=>addPiece(p,'right')} className="flex-1 py-3 text-[10px] font-bold hover:bg-white/10 transition-colors">DER</button></div> </div> ) : ( <button onClick={()=>addPiece(p)} className={`flex items-center gap-3 px-4 py-3 border rounded-lg active:scale-95 transition-all duration-200 ${neonClass} hover:bg-white/5`}><div className="flex flex-col items-start"><span className="text-xs font-bold">{p.label}</span><span className="text-[9px] opacity-60">{p.length}cm</span></div>{p.cat==='Digital' && <Zap size={16}/>}</button> )} </div> ))} </div>
                  <div className="flex items-center overflow-x-auto hide-scrollbar px-4 py-3 gap-3 bg-[#1e293b] border-t border-[#334155]">
                         <button onClick={() => setShowTelemetry(true)} className="group relative flex items-center justify-center gap-4 px-8 py-3 bg-black border-2 border-[#39ff14] rounded-xl overflow-hidden transition-all duration-300 hover:scale-105 hover:shadow-[0_0_50px_rgba(57,255,20,0.7),inset_0_0_20px_rgba(57,255,20,0.3)] shadow-[0_0_20px_rgba(57,255,20,0.3),inset_0_0_10px_rgba(57,255,20,0.1)] shrink-0 active:scale-95 btn-spectacular-shimmer"> <div className="absolute inset-0 opacity-30" style={{backgroundImage: 'linear-gradient(rgba(57,255,20,0.3) 1px, transparent 1px), linear-gradient(90deg, rgba(57,255,20,0.3) 1px, transparent 1px)', backgroundSize: '12px 12px'}}></div> <Activity size={28} className="text-[#39ff14] animate-pulse relative z-10 drop-shadow-[0_0_10px_rgba(57,255,20,1)]"/> <div className="flex flex-col items-center relative z-10"> <span className="font-black text-lg text-white tracking-widest leading-none drop-shadow-[0_2px_2px_rgba(0,0,0,1)]" style={{textShadow: '0 0 15px rgba(57,255,20,0.6)'}}>VISTA 3D</span> <span className="text-[9px] font-bold text-[#39ff14] tracking-[0.3em] uppercase leading-none mt-1 opacity-80 group-hover:opacity-100 transition-opacity">Simulación</span> </div> </button>
                         <div className="h-10 w-px bg-gradient-to-b from-transparent via-[#39ff14]/30 to-transparent mx-2 shrink-0"></div>
                         <button onClick={() => setIsCircuitMoveMode(!isCircuitMoveMode)} title="Mover la pista sobre el tablero" className={`flex items-center justify-center gap-2 px-5 py-2.5 rounded-lg border transition-all font-bold text-xs shrink-0 ${isCircuitMoveMode ? 'bg-orange-500/20 text-orange-300 border-orange-500 shadow-[0_0_20px_rgba(249,115,22,0.6)]' : 'bg-transparent text-orange-400 border-orange-500/50 shadow-[0_0_10px_rgba(249,115,22,0.2)] hover:bg-orange-500/10 hover:border-orange-400 hover:shadow-[0_0_15px_rgba(249,115,22,0.4)] hover:text-orange-200'}`}><Move size={16}/> MOVER PISTA</button>
                         <button onClick={saveCircuit} title="Guardar Circuito" className="flex items-center justify-center gap-2 px-5 py-2.5 bg-transparent text-blue-400 border border-blue-500/50 rounded-lg hover:bg-blue-500/10 hover:border-blue-400 hover:text-blue-200 hover:shadow-[0_0_15px_rgba(59,130,246,0.4)] shadow-[0_0_10px_rgba(59,130,246,0.2)] transition-all font-bold text-xs shrink-0"><Save size={16}/> GUARDAR</button>
                         <label title="Cargar Circuito" className="flex items-center justify-center gap-2 px-5 py-2.5 bg-transparent text-yellow-400 border border-yellow-500/50 rounded-lg hover:bg-yellow-500/10 hover:border-yellow-400 hover:text-yellow-200 hover:shadow-[0_0_15px_rgba(234,179,8,0.4)] shadow-[0_0_10px_rgba(234,179,8,0.2)] transition-all font-bold text-xs cursor-pointer shrink-0"><FolderOpen size={16}/> ABRIR<input type="file" accept=".json" className="hidden" onChange={loadCircuit}/></label>
                         <button onClick={generateReport} title="Generar Informe" className="flex items-center justify-center gap-2 px-5 py-2.5 bg-transparent text-teal-400 border border-teal-500/50 rounded-lg hover:bg-teal-500/10 hover:border-teal-400 hover:text-teal-200 hover:shadow-[0_0_15px_rgba(20,184,166,0.4)] shadow-[0_0_10px_rgba(20,184,166,0.2)] transition-all font-bold text-xs shrink-0"><FileText size={16}/> INFORME</button>
                         <button onClick={() => setShowBoardTools(!showBoardTools)} title="Configurar Tablero" className="flex items-center justify-center gap-2 px-5 py-2.5 bg-transparent text-green-400 border border-green-500/50 rounded-lg hover:bg-green-500/10 hover:border-green-400 hover:text-green-200 hover:shadow-[0_0_15px_rgba(34,197,94,0.4)] shadow-[0_0_10px_rgba(34,197,94,0.2)] transition-all font-bold text-xs shrink-0"><Square size={16}/> TABLERO</button>
                         <button onClick={toggleFullScreen} title={isFullScreen ? "Salir Pantalla Completa" : "Pantalla Completa"} className="flex items-center justify-center gap-2 px-5 py-2.5 bg-transparent text-purple-400 border border-purple-500/50 rounded-lg hover:bg-purple-500/10 hover:border-purple-400 hover:text-purple-200 hover:shadow-[0_0_15px_rgba(168,85,247,0.4)] shadow-[0_0_10px_rgba(168,85,247,0.2)] transition-all font-bold text-xs shrink-0"> {isFullScreen ? <Minimize size={16}/> : <Maximize size={16}/>} FULLSCREEN </button>
                  </div>
              </div>

              <div className={`flex-1 relative overflow-hidden ${isCircuitMoveMode ? 'cursor-move' : (isDragging ? 'cursor-grabbing' : 'cursor-grab')}`}>
                  <canvas ref={canvasRef} className="absolute top-0 left-0 w-full h-full touch-none block" onContextMenu={(e) => e.preventDefault()} onPointerDown={handleDown} onPointerMove={handleMoveHandler} onPointerUp={handleUp} onPointerCancel={handleUp} onPointerLeave={handleUp} onWheel={handleWheel}/>
                  {showBoardTools && ( 
                      <div onPointerDown={(e)=>e.stopPropagation()} className="absolute top-24 right-4 bg-[#0f172a]/95 border border-green-500 shadow-[0_0_30px_rgba(34,197,94,0.3)] p-3 rounded-xl w-60 backdrop-blur-xl z-50 animate-in origin-top-right"> 
                          <div className="flex justify-between items-center mb-3 pb-2 border-b border-green-500/30"> 
                              <h3 className="text-xs font-black text-green-400 flex gap-2 drop-shadow-[0_0_5px_rgba(34,197,94,0.8)] items-center tracking-widest">
                                  <Square size={14}/> 
                                  TABLERO
                              </h3> 
                              <button onClick={()=>setShowBoardTools(false)} className="text-green-500 hover:text-white transition hover:scale-110 bg-green-500/10 p-0.5 rounded"><X size={14}/></button> 
                          </div> 
                          
                          <div className="mb-3"> 
                              <div className="text-[8px] text-green-300/70 font-black mb-2 uppercase tracking-[0.1em]">Medidas (Rectángulo)</div> 
                              <div className="flex gap-1 mb-2 items-center"> 
                                  <div className="flex-1 relative">
                                      <input type="number" value={boardDim.width} onChange={(e)=>setBoardDim({...boardDim, width:e.target.value})} className="w-full bg-black/60 border border-green-500/30 rounded px-2 py-1 text-xs text-center text-white focus:border-green-400 outline-none font-mono"/> 
                                      <span className="absolute right-1 top-1 text-[8px] text-gray-500">cm</span>
                                  </div>
                                  <span className="text-green-500 font-bold text-[10px]">x</span> 
                                  <div className="flex-1 relative">
                                      <input type="number" value={boardDim.height} onChange={(e)=>setBoardDim({...boardDim, height:e.target.value})} className="w-full bg-black/60 border border-green-500/30 rounded px-2 py-1 text-xs text-center text-white focus:border-green-400 outline-none font-mono"/> 
                                      <span className="absolute right-1 top-1 text-[8px] text-gray-500">cm</span>
                                  </div>
                              </div> 
                              <button onClick={createRectBoard} className="w-full py-1.5 bg-green-600 hover:bg-green-500 text-black font-black rounded text-[10px] shadow-[0_0_10px_rgba(34,197,94,0.3)] transition-all uppercase tracking-wider transform active:scale-95">Crear Rectángulo</button> 
                          </div> 
                          
                          <div className="border-t border-green-500/30 pt-3"> 
                              <div className="text-[8px] text-green-300/70 font-black mb-2 uppercase tracking-[0.1em]">Manual (Punto a Punto)</div> 
                              
                              <div className="flex items-center justify-between mb-3 bg-green-900/20 p-1.5 rounded border border-green-500/20"> 
                                  <span className="text-[10px] text-green-400 font-bold uppercase ml-1">Longitud:</span> 
                                  <div className="flex items-center gap-1">
                                      <input type="number" value={boardStep} onChange={(e)=>setBoardStep(e.target.value)} className="w-12 bg-black/50 border border-green-500/50 rounded px-1 py-0.5 text-xs text-center text-white focus:border-green-400 outline-none font-mono font-bold"/> 
                                      <span className="text-[9px] text-gray-400">cm</span>
                                  </div>
                              </div> 
                              
                              <div className="grid grid-cols-3 gap-1 mb-3"> 
                                  {/* ARRIBA */}
                                  <div className="col-start-2"> 
                                      <button onClick={()=>addBoardPoint(0, -parseFloat(boardStep || 0))} className="w-full h-10 bg-black/40 hover:bg-green-500/20 text-green-400 rounded flex flex-col items-center justify-center border border-green-500/30 hover:border-green-400 hover:shadow-[0_0_10px_rgba(34,197,94,0.2)] transition-all group active:scale-95"> 
                                          <span className="text-[9px] font-black tracking-widest">ARRIBA</span>
                                      </button> 
                                  </div> 
                                  {/* IZQUIERDA */}
                                  <div className="col-start-1 row-start-2"> 
                                      <button onClick={()=>addBoardPoint(-parseFloat(boardStep || 0), 0)} className="w-full h-10 bg-black/40 hover:bg-green-500/20 text-green-400 rounded flex flex-col items-center justify-center border border-green-500/30 hover:border-green-400 hover:shadow-[0_0_10px_rgba(34,197,94,0.2)] transition-all group active:scale-95"> 
                                          <span className="text-[9px] font-black tracking-widest">IZQ</span>
                                      </button> 
                                  </div> 
                                  {/* CENTRO (VISUAL) */}
                                  <div className="col-start-2 row-start-2 flex items-center justify-center opacity-30"> 
                                      <div className="w-1.5 h-1.5 bg-green-500 rounded-full animate-ping"></div>
                                  </div> 
                                  {/* DERECHA */}
                                  <div className="col-start-3 row-start-2"> 
                                      <button onClick={()=>addBoardPoint(parseFloat(boardStep || 0), 0)} className="w-full h-10 bg-black/40 hover:bg-green-500/20 text-green-400 rounded flex flex-col items-center justify-center border border-green-500/30 hover:border-green-400 hover:shadow-[0_0_10px_rgba(34,197,94,0.2)] transition-all group active:scale-95"> 
                                          <span className="text-[9px] font-black tracking-widest">DER</span>
                                      </button> 
                                  </div> 
                                  {/* ABAJO */}
                                  <div className="col-start-2 row-start-3"> 
                                      <button onClick={()=>addBoardPoint(0, parseFloat(boardStep || 0))} className="w-full h-10 bg-black/40 hover:bg-green-500/20 text-green-400 rounded flex flex-col items-center justify-center border border-green-500/30 hover:border-green-400 hover:shadow-[0_0_10px_rgba(34,197,94,0.2)] transition-all group active:scale-95"> 
                                          <span className="text-[9px] font-black tracking-widest">ABAJO</span>
                                      </button> 
                                  </div> 
                              </div> 
                              
                              <div className="flex gap-2 mt-3 pt-3 border-t border-green-500/20"> 
                                  <button onClick={closeBoardPolygon} className="flex-[2] py-2 bg-green-500/20 hover:bg-green-500/40 text-green-300 border border-green-500/50 hover:border-green-400 font-bold rounded text-[9px] flex items-center justify-center gap-1 transition-all hover:shadow-[0_0_15px_rgba(34,197,94,0.3)] active:scale-95 uppercase tracking-widest">
                                      <Square size={10} className="fill-current"/> CIERRE
                                  </button> 
                                  <button onClick={clearBoard} className="flex-1 py-2 bg-red-500/10 hover:bg-red-500/30 text-red-400 border border-red-500/30 hover:border-red-400 font-bold rounded text-[9px] flex items-center justify-center gap-1 transition-all active:scale-95">
                                      <Trash2 size={10}/> BORRAR
                                  </button> 
                              </div> 

                              <div className="mt-2">
                                  <button onClick={()=>setShowBoardTools(false)} className="w-full py-1.5 bg-gray-800/50 hover:bg-gray-700 text-gray-400 font-bold rounded text-[9px] border border-gray-700 transition-all uppercase tracking-widest hover:text-white">
                                      SALIR DEL TABLERO
                                  </button>
                              </div>
                          </div> 
                      </div> 
                  )}
                  <div className="absolute bottom-6 left-0 w-full flex justify-center md:justify-start md:left-6 md:w-auto pointer-events-none z-30"> 
                      <div className="flex gap-3 pointer-events-auto bg-black/40 p-3 rounded-xl backdrop-blur-sm border border-cyan-500/30 shadow-[0_0_20px_rgba(6,182,212,0.2)] relative"> 
                          {/* VISOR HOMO INTEGRADO AQUÍ */}
                          {showHomoViewer && (
                              <div className="absolute bottom-full left-0 mb-4 pointer-events-auto">
                                  <GLBViewer 
                                      onClose={() => setShowHomoViewer(false)} 
                                      onLoad={handleModelAssign} 
                                  />
                              </div>
                          )}

                          <button onClick={handleUndo} className={`flex flex-col items-center justify-center w-20 h-20 bg-gray-900/90 border border-cyan-500 shadow-[0_0_15px_rgba(6,182,212,0.4)] rounded-lg text-cyan-400 hover:bg-cyan-950/50 active:scale-95 active:shadow-none transition-all group ${historyStep === 0 ? 'opacity-50 cursor-not-allowed' : 'hover:shadow-[0_0_25px_rgba(6,182,212,0.6)]'}`} title="Deshacer última acción" disabled={historyStep === 0}> <Undo2 size={24} className="mb-1 group-hover:scale-110 transition-transform"/> <span className="text-[9px] font-black tracking-widest">DESHACER</span> </button> 
                          <button onClick={handleRedo} className={`flex flex-col items-center justify-center w-20 h-20 bg-gray-900/90 border border-cyan-500 shadow-[0_0_15px_rgba(6,182,212,0.4)] rounded-lg text-cyan-400 hover:bg-cyan-950/50 active:scale-95 active:shadow-none transition-all group ${historyStep < history.length - 1 ? 'hover:shadow-[0_0_25px_rgba(6,182,212,0.6)]' : 'opacity-50 cursor-not-allowed'}`} title="Rehacer acción deshecha" disabled={historyStep === history.length - 1}> <Redo2 size={24} className="mb-1 group-hover:scale-110 transition-transform"/> <span className="text-[9px] font-black tracking-widest">REHACER</span> </button> 
                          <button onClick={handleZoomOut} className="flex flex-col items-center justify-center w-20 h-20 bg-gray-900/90 border border-cyan-500 shadow-[0_0_15px_rgba(6,182,212,0.4)] rounded-lg text-cyan-400 hover:bg-cyan-950/50 active:scale-95 active:shadow-none transition-all group hover:shadow-[0_0_25px_rgba(6,182,212,0.6)]"> <ZoomOut size={24} className="mb-1 group-hover:scale-110 transition-transform"/> <span className="text-[9px] font-black tracking-widest">ALEJAR</span> </button> 
                          <button onClick={fitToScreen} className="flex flex-col items-center justify-center w-20 h-20 bg-gray-900/90 border border-cyan-500 shadow-[0_0_15px_rgba(6,182,212,0.4)] rounded-lg text-cyan-400 hover:bg-cyan-950/50 active:scale-95 active:shadow-none transition-all group hover:shadow-[0_0_25px_rgba(6,182,212,0.6)]"> <Crosshair size={24} className="mb-1 group-hover:rotate-45 transition-transform"/> <span className="text-[9px] font-black tracking-widest">CENTRAR</span> </button> 
                          <button onClick={handleZoomIn} className="flex flex-col items-center justify-center w-20 h-20 bg-gray-900/90 border border-cyan-500 shadow-[0_0_15px_rgba(6,182,212,0.4)] rounded-lg text-cyan-400 hover:bg-cyan-950/50 active:scale-95 active:shadow-none transition-all group hover:shadow-[0_0_25px_rgba(6,182,212,0.6)]"> <ZoomIn size={24} className="mb-1 group-hover:scale-110 transition-transform"/> <span className="text-[9px] font-black tracking-widest">ACERCAR</span> </button> 
                          <button onClick={() => setShowHomoViewer(!showHomoViewer)} className={`flex flex-col items-center justify-center w-20 h-20 bg-gray-900/90 border border-cyan-500 shadow-[0_0_15px_rgba(6,182,212,0.4)] rounded-lg text-cyan-400 hover:bg-cyan-950/50 active:scale-95 active:shadow-none transition-all group ${showHomoViewer ? 'bg-cyan-900/50 border-cyan-400 text-white' : 'hover:shadow-[0_0_25px_rgba(6,182,212,0.6)]'}`}> <User size={24} className="mb-1 group-hover:scale-110 transition-transform"/> <span className="text-[9px] font-black tracking-widest">HOMO</span> </button> 
                      </div> 
                  </div>
                  {selectedPieceId && pieces.find(p=>p.uid===selectedPieceId) && ( <div className={`absolute top-6 right-6 bg-[#0f172a]/90 p-5 rounded-2xl shadow-2xl border w-72 backdrop-blur-md ${neonClass}`}> <div className="flex justify-between items-start mb-4 border-b border-white/10 pb-3"><div><h3 className="text-lg font-black text-white">{pieces.find(p=>p.uid===selectedPieceId).label}</h3></div><button onClick={()=>setSelectedPieceId(null)} className="hover:text-white text-gray-500 transition"><X size={20}/></button></div> <div className="space-y-4"> <button onClick={toggleInvertPiece} className="w-full flex items-center justify-center gap-3 px-4 py-4 rounded-xl text-xs font-bold bg-[#1e293b] text-gray-400 border border-[#334155] hover:bg-[#334155] transition shadow-[0_0_10px_rgba(255,255,255,0.1)] hover:shadow-[0_0_15px_rgba(255,255,255,0.2)]"><Repeat size={18}/> INVERTIR 180°</button> <div className="pt-3 border-t border-white/10"><button onClick={removePiece} className="w-full flex items-center justify-center gap-2 px-4 py-4 bg-red-900/20 text-red-500 border border-red-900/50 rounded-xl text-xs font-bold hover:bg-red-900/40 transition shadow-[0_0_10px_rgba(239,68,68,0.2)] hover:shadow-[0_0_20px_rgba(239,68,68,0.4)]"><Trash2 size={18}/> ELIMINAR</button></div> </div> </div> )}
              </div>
            </div>
          );
        }

        const rootElement = document.getElementById('root');
        if (rootElement) {
            try {
                const root = ReactDOM.createRoot(rootElement);
                root.render(<SlotDesigner />);
            } catch (error) {
                console.error("Error al renderizar:", error);
                document.getElementById('loading-screen').innerHTML = `<h2 class="text-xl text-red-500 font-bold">Error fatal</h2><p class="text-white">${error.message}</p>`;
            }
        } else { console.error("No se encontró el elemento root"); }
    </script>
</body>
</html>
