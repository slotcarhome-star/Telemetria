<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Diseñador de Circuitos Slot 2D</title>
    
    <!-- METADATOS PARA PANTALLA COMPLETA EN MÓVILES -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0a0a0a">
    
    <!-- LIBRERÍAS EXTERNAS (CDN BLINDADO - CLOUDFLARE) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React Core (Fijado v18.2.0) -->
    <script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <!-- React DOM (Fijado v18.2.0) -->
    <script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <!-- Babel Standalone (Fijado v7.23.5 - Estable) -->
    <script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@0.263.1/dist/umd/lucide.min.js"></script>
    <!-- PDF Generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
    
    <!-- FUENTE DIGITAL -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    
    <style>
        /* ESTILOS GLOBALES */
        script { display: none !important; }
        body { background-color: #0a0a0a; color: white; margin: 0; overflow: hidden; font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; user-select: none; touch-action: none; }
        .hide-scrollbar::-webkit-scrollbar { display: none; }
        .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .animate-in { animation: fadeIn 0.5s ease-out forwards; }
        
        /* PANTALLA DE CARGA */
        #loading-screen { position: fixed; inset: 0; background: radial-gradient(circle at center, #1e293b 0%, #020617 100%); color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 9999; text-align: center; padding: 20px; transition: opacity 0.8s ease-out; }
        .loader-title { font-size: 3rem; font-weight: 900; color: #39ff14; text-transform: uppercase; letter-spacing: -2px; margin-bottom: 2rem; text-shadow: 0 0 15px rgba(57, 255, 20, 0.8); animation: pulse-neon 2s infinite alternate; }
        .loader-bar-bg { width: 300px; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; position: relative; margin-bottom: 1rem; }
        .loader-bar-fill { position: absolute; top: 0; left: 0; bottom: 0; width: 40%; background: #39ff14; box-shadow: 0 0 10px #39ff14; animation: load-scan 1s linear infinite; }
        .loader-subtitle { font-size: 0.8rem; color: #94a3b8; letter-spacing: 2px; font-weight: bold; }
        @keyframes pulse-neon { 0% { text-shadow: 0 0 15px rgba(57, 255, 20, 0.8); opacity: 0.9; transform: scale(1); } 100% { text-shadow: 0 0 30px rgba(57, 255, 20, 1); opacity: 1; transform: scale(1.02); } }
        @keyframes load-scan { 0% { left: -40%; } 100% { left: 100%; } }
        
        /* Animación botón */
        @keyframes shimmer-slide { 0% { transform: translateX(-150%) skewX(-20deg); } 100% { transform: translateX(250%) skewX(-20deg); } }
        .btn-spectacular-shimmer::after {
            content: ''; position: absolute; top: 0; left: 0; width: 50%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(57, 255, 20, 0.6), transparent);
            transform: translateX(-150%) skewX(-20deg);
            animation: shimmer-slide 3s infinite cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* UI HELPERS */
        #error-msg { color: #ef4444; margin-top: 20px; max-width: 600px; display: none; border: 1px solid #ef4444; padding: 10px; border-radius: 8px; background: rgba(0,0,0,0.8); }
        .cursor-grab { cursor: grab; } .cursor-grabbing { cursor: grabbing; } .cursor-crosshair { cursor: crosshair; }
        
        .font-digital { 
            font-family: 'Share Tech Mono', monospace; 
            font-variant-numeric: tabular-nums; 
            letter-spacing: 1px;
        }

        /* --- NUEVO: BLOQUEO DE ORIENTACIÓN (SOLO LANDSCAPE) --- */
        #orientation-lock { display: none; }
        
        @media (orientation: portrait) {
            #orientation-lock { 
                position: fixed; inset: 0; z-index: 100000; 
                background: #020617; color: white;
                display: flex; flex-direction: column; align-items: center; justify-content: center;
                text-align: center; padding: 2rem;
            }
            /* Bloquear interacción con el fondo */
            #root { filter: blur(20px) brightness(0.2); pointer-events: none; }
            body { overflow: hidden; }
        }

        .rotate-anim { animation: rotate-device 3s infinite ease-in-out; }
        @keyframes rotate-device { 
            0% { transform: rotate(0deg); opacity: 0.5; } 
            25% { transform: rotate(-90deg); opacity: 1; } 
            50% { transform: rotate(-90deg); opacity: 1; }
            75% { transform: rotate(0deg); opacity: 0.5; }
            100% { transform: rotate(0deg); opacity: 0.5; } 
        }
    </style>
</head>
<body>
    <!-- PANTALLA DE BLOQUEO: SOLO HORIZONTAL -->
    <div id="orientation-lock">
        <div class="mb-8 text-[#39ff14]">
            <svg width="80" height="80" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="rotate-anim drop-shadow-[0_0_15px_rgba(57,255,20,0.6)]">
                <rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect>
                <path d="M12 18h.01"></path>
            </svg>
        </div>
        <h2 class="text-3xl font-black text-white uppercase tracking-[0.2em] mb-4" style="text-shadow: 0 0 20px rgba(57,255,20,0.5)">
            MODO HORIZONTAL REQUERIDO
        </h2>
        <div class="h-px w-20 bg-[#39ff14] mb-6 shadow-[0_0_10px_#39ff14]"></div>
        <p class="text-gray-400 text-sm max-w-md uppercase tracking-wider font-mono leading-relaxed">
            Esta aplicación de diseño técnico está optimizada exclusivamente para<br>
            <span class="text-white font-bold">PC · MAC · PORTÁTILES · TABLETS (Horizontal)</span>
        </p>
        <p class="mt-8 text-[10px] text-[#39ff14]/60 font-mono animate-pulse">
            POR FAVOR GIRA TU DISPOSITIVO
        </p>
    </div>

    <div id="loading-screen">
        <h1 class="loader-title">TRACK DESIGNER 2D</h1>
        <div class="loader-bar-bg"><div class="loader-bar-fill"></div></div>
        <div class="loader-subtitle">INICIALIZANDO MOTOR GRÁFICO...</div>
        <div id="error-msg"></div>
    </div>
    <div id="root"></div>
    
    <script>
        window.onerror = function(msg, url, line, col, error) {
            const ls = document.getElementById('loading-screen'); 
            const ed = document.getElementById('error-msg');
            if(ls && ed) { 
                ls.style.zIndex="10000"; ls.style.display="flex"; ls.style.opacity="1"; 
                ed.style.display="block"; 
                ed.innerHTML=`<strong>Error Detectado:</strong><br>${msg}<br><small>Línea: ${line}</small>`; 
            }
            return false;
        };
    </script>

    <script type="text/babel" data-presets="react,env">
        const { useState, useEffect, useRef } = React;

        class ErrorBoundary extends React.Component {
            constructor(props) { super(props); this.state = { hasError: false }; }
            static getDerivedStateFromError(error) { return { hasError: true }; }
            componentDidCatch(error, errorInfo) { console.error("System Crash:", error, errorInfo); }
            render() { if (this.state.hasError) return this.props.fallback || null; return this.props.children; }
        }

        const TRACK_DEFINITIONS = {
          NINCO: { name: 'NINCO', themeColor: 'red', neonColor: '#ef4444', uiClass: 'border-red-500/50 text-red-400 shadow-[0_0_15px_rgba(239,68,68,0.3)] hover:bg-red-950/30', activeClass: 'bg-red-600 text-white shadow-[0_0_20px_rgba(239,68,68,0.6)] border-red-500', trackColor: '#111111', railColor: '#dcdcdc', slotColor: '#000000', width: 18.0, laneSpacing: 9.0, connectionBoxColor: '#ef4444',
            pieces: [ { id: 'n_40', label: 'Recta 40cm', type: 'straight', length: 40.0, cat: 'Rectas' }, { id: 'n_20', label: 'Media 20cm', type: 'straight', length: 20.0, cat: 'Rectas' }, 
              { id: 'n_sl_1', label: 'Recta 1C (40)', type: 'straight', length: 40.0, subtype: 'single_lane_1', cat: 'RALLY' }, { id: 'n_sl_2', label: 'Recta 2C (40)', type: 'straight', length: 40.0, subtype: 'single_lane_2', cat: 'RALLY' },
              { id: 'n_grid', label: 'Media Parrilla', type: 'straight', length: 20.0, subtype: 'starting_grid', cat: 'Rectas' }, { id: 'n_10', label: 'Cuarto 10cm', type: 'straight', length: 10.0, cat: 'Rectas' }, { id: 'n_05', label: 'Cierre 5cm', type: 'straight', length: 5.0, cat: 'Rectas' }, { id: 'n_connect', label: 'Conexiones', type: 'straight', length: 40.0, subtype: 'analog_connect', cat: 'Rectas' }, { id: 'n_cross', label: 'Cruce 40cm', type: 'straight', length: 40.0, subtype: 'crossing', cat: 'Rectas' }, { id: 'n_r1', label: 'R1 (Int)', type: 'curve', radius: 20.0, angle: 45, cat: 'Curvas' }, { id: 'n_r1_22', label: 'R1 (22.5°)', type: 'curve', radius: 20.0, angle: 22.5, cat: 'Curvas' }, { id: 'n_r2', label: 'R2 (Std)', type: 'curve', radius: 38.0, angle: 45, cat: 'Curvas' }, { id: 'n_r2_22', label: 'R2 (22.5°)', type: 'curve', radius: 38.0, angle: 22.5, cat: 'Curvas' }, { id: 'n_r3', label: 'R3 (Ext)', type: 'curve', radius: 56.0, angle: 22.5, cat: 'Curvas' }, { id: 'n_r4', label: 'R4 (Super)', type: 'curve', radius: 74.0, angle: 22.5, cat: 'Curvas' }, { id: 'n_r5', label: 'R5 (Ultra)', type: 'curve', radius: 92.0, angle: 22.5, cat: 'Curvas' }, { id: 'n_rotonda', label: 'Rotonda + Recta 10', type: 'curve', radius: 14.5, angle: 180, subtype: 'rotonda', cat: 'RALLY' }, { id: 'n_console', label: 'Centralita', type: 'straight', length: 20.0, subtype: 'digital_console', cat: 'Digital' }, { id: 'n_x', label: 'Cambio X', type: 'straight', length: 40.0, subtype: 'digital_x', cat: 'Digital' }, { id: 'n_ch_r', label: 'Cambio Der', type: 'straight', length: 40.0, subtype: 'change_right', cat: 'Digital' }, { id: 'n_ch_l', label: 'Cambio Izq', type: 'straight', length: 40.0, subtype: 'change_left', cat: 'Digital' }, { id: 'n_pit_in', label: 'Entrada Pit', type: 'pit_entry', length: 40.0, cat: 'Boxes' }, { id: 'n_pit_fuel', label: 'Zona Fuel', type: 'straight', length: 40.0, subtype: 'pit_parallel', cat: 'Boxes' }, { id: 'n_pit_box_x', label: 'Boxes + Cambio X', type: 'straight', length: 40.0, subtype: 'pit_parallel_double_x', cat: 'Boxes' }, { id: 'n_pit_straight', label: 'Recta Pit', type: 'straight', length: 40.0, subtype: 'pit_parallel_black', cat: 'Boxes' }, { id: 'n_pit_out', label: 'Salida Pit', type: 'pit_exit', length: 40.0, cat: 'Boxes' } ] },
          SCX_ANALOG: { name: 'SCALEXTRIC', themeColor: 'yellow', neonColor: '#facc15', uiClass: 'border-yellow-500/50 text-yellow-400 shadow-[0_0_15px_rgba(250,204,21,0.3)] hover:bg-yellow-950/30', activeClass: 'bg-yellow-500 text-black shadow-[0_0_20px_rgba(250,204,21,0.6)] border-yellow-400 font-bold', trackColor: '#5a5a5a', railColor: '#d0d0d0', slotColor: '#1a1a1a', width: 15.6, laneSpacing: 7.7, connectionBoxColor: '#ef4444', 
            pieces: [ { id: 's_360', label: 'Recta 360', type: 'straight', length: 36.0, cat: 'Rectas' }, { id: 's_180', label: 'Media 180', type: 'straight', length: 18.0, cat: 'Rectas' },
              { id: 's_sl_1', label: 'Recta 1C (360)', type: 'straight', length: 36.0, subtype: 'single_lane_1', cat: 'RALLY' }, { id: 's_sl_2', label: 'Recta 2C (360)', type: 'straight', length: 36.0, subtype: 'single_lane_2', cat: 'RALLY' },
              { id: 's_grid', label: 'Media Parrilla', type: 'straight', length: 18.0, subtype: 'starting_grid', cat: 'Rectas' }, { id: 's_90', label: 'Cierre 90', type: 'straight', length: 9.0, cat: 'Rectas' }, { id: 's_connect', label: 'Conexión', type: 'straight', length: 36.0, subtype: 'analog_connect', cat: 'Rectas' }, { id: 's_cross', label: 'Recta Cruce', type: 'straight', length: 36.0, subtype: 'crossing', cat: 'Rectas' }, { id: 's_chicane_in', label: 'Entrada Chicane', type: 'straight', length: 36.0, subtype: 'chicane_entry', cat: 'Rectas' }, { id: 's_chicane_mid', label: 'Recta Chicane', type: 'straight', length: 36.0, subtype: 'chicane_middle', cat: 'Rectas' }, { id: 's_chicane_out', label: 'Salida Chicane', type: 'straight', length: 36.0, subtype: 'chicane_exit', cat: 'Rectas' }, { id: 's_r1', label: 'R1 (Int)', type: 'curve', radius: 15.0, angle: 45, cat: 'Curvas' }, { id: 's_r2', label: 'R2 (Std)', type: 'curve', radius: 30.6, angle: 45, cat: 'Curvas' }, { id: 's_r2_ice', label: 'R2 (Hielo)', type: 'curve', radius: 30.6, angle: 45, subtype: 'ice', cat: 'Curvas' }, { id: 's_r3', label: 'R3 (Ext)', type: 'curve', radius: 46.2, angle: 22.5, cat: 'Curvas' }, { id: 's_r4', label: 'R4 (Super)', type: 'curve', radius: 61.8, angle: 22.5, cat: 'Curvas' }, { id: 's_rotonda_10', label: 'Rotonda + Recta 10', type: 'curve', radius: 15.0, angle: 180, subtype: 'rotonda', cat: 'RALLY' } ] },
          SCX_ADVANCE: { name: 'SCX ADVANCE', themeColor: 'blue', neonColor: '#3b82f6', uiClass: 'border-blue-500/50 text-blue-400 shadow-[0_0_15px_rgba(59,130,246,0.3)] hover:bg-blue-950/30', activeClass: 'bg-blue-600 text-white shadow-[0_0_20px_rgba(59,130,246,0.6)] border-blue-400 font-bold', trackColor: '#5a5a5a', railColor: '#d0d0d0', slotColor: '#1a1a1a', width: 15.6, laneSpacing: 7.7, connectionBoxColor: '#ef4444',
            pieces: [ { id: 'adv_360', label: 'Recta 360', type: 'straight', length: 36.0, cat: 'Rectas' }, { id: 'adv_180', label: 'Media 180', type: 'straight', length: 18.0, cat: 'Rectas' }, 
              { id: 'adv_sl_1', label: 'Recta 1C (360)', type: 'straight', length: 36.0, subtype: 'single_lane_1', cat: 'RALLY' }, { id: 'adv_sl_2', label: 'Recta 2C (360)', type: 'straight', length: 36.0, subtype: 'single_lane_2', cat: 'RALLY' },
              { id: 'adv_grid', label: 'Media Parrilla', type: 'straight', length: 18.0, subtype: 'starting_grid', cat: 'Rectas' }, { id: 'adv_90', label: 'Cierre 90', type: 'straight', length: 9.0, cat: 'Rectas' }, { id: 'adv_connect', label: 'Bluetooth', type: 'straight', length: 36.0, subtype: 'connection', cat: 'Digital' }, { id: 'adv_x', label: 'Cambio Recta', type: 'straight', length: 36.0, subtype: 'digital_x', cat: 'Digital' }, { id: 'adv_cr', label: 'Cambio Curva', type: 'curve', radius: 30.6, angle: 45, subtype: 'change_curve_r', cat: 'Digital' }, { id: 'adv_pit_in', label: 'Entrada Pit', type: 'pit_entry', length: 36.0, cat: 'Boxes' }, { id: 'adv_pit_fuel', label: 'Recta Fuel', type: 'straight', length: 36.0, subtype: 'pit_parallel', cat: 'Boxes' }, { id: 'adv_pit_box_x', label: 'Boxes + Cambio X', type: 'straight', length: 36.0, subtype: 'pit_parallel_double_x', cat: 'Boxes' }, { id: 'adv_pit_straight', label: 'Recta Pit', type: 'straight', length: 36.0, subtype: 'pit_parallel_black', cat: 'Boxes' }, { id: 'adv_pit_out', label: 'Salida Pit', type: 'pit_exit', length: 36.0, cat: 'Boxes' }, { id: 'adv_r1', label: 'R1 (Int)', type: 'curve', radius: 15.0, angle: 45, cat: 'Curvas' }, { id: 'adv_r2', label: 'R2 (Std)', type: 'curve', radius: 30.6, angle: 45, cat: 'Curvas' }, { id: 'adv_r3', label: 'R3 (Ext)', type: 'curve', radius: 46.2, angle: 22.5, cat: 'Curvas' }, { id: 'adv_r4', label: 'R4 (Super)', type: 'curve', radius: 61.8, angle: 22.5, cat: 'Curvas' } ] },
          POLICAR: { name: 'POLICAR', themeColor: 'orange', neonColor: '#f97316', uiClass: 'border-orange-500/50 text-orange-400 shadow-[0_0_15px_rgba(249,115,22,0.3)] hover:bg-orange-950/30', activeClass: 'bg-orange-600 text-white shadow-[0_0_20px_rgba(249,115,22,0.6)] border-orange-500 font-bold', trackColor: '#1a1a1a', railColor: '#dcdcdc', slotColor: '#000000', width: 17.9, laneSpacing: 9.0, connectionBoxColor: '#333',
            pieces: [ { id: 'pol_358', label: 'Recta 358', type: 'straight', length: 35.8, cat: 'Rectas' }, { id: 'pol_179', label: 'Media 179', type: 'straight', length: 17.9, cat: 'Rectas' }, { id: 'pol_grid', label: 'Media Parrilla', type: 'straight', length: 17.9, subtype: 'starting_grid', cat: 'Rectas' }, { id: 'pol_89', label: 'Cuarto 89', type: 'straight', length: 8.9, cat: 'Rectas' }, { id: 'pol_connect', label: 'Conexiones', type: 'straight', length: 35.8, subtype: 'analog_connect', cat: 'Rectas' }, { id: 'pol_cross', label: 'Cruce 358', type: 'straight', length: 35.8, subtype: 'crossing', cat: 'Rectas' }, { id: 'pol_r1', label: 'R1 (45°)', type: 'curve', radius: 17.9, angle: 45, cat: 'Curvas' }, { id: 'pol_r1_22', label: 'R1 (22.5°)', type: 'curve', radius: 17.9, angle: 22.5, cat: 'Curvas' }, { id: 'pol_r2', label: 'R2 (45°)', type: 'curve', radius: 35.8, angle: 45, cat: 'Curvas' }, { id: 'pol_r2_22', label: 'R2 (22.5°)', type: 'curve', radius: 35.8, angle: 22.5, cat: 'Curvas' }, { id: 'pol_r3', label: 'R3 (22.5°)', type: 'curve', radius: 53.7, angle: 22.5, cat: 'Curvas' }, { id: 'pol_r4', label: 'R4 (22.5°)', type: 'curve', radius: 71.6, angle: 22.5, cat: 'Curvas' } ] },
          SCALEAUTO: { name: 'SCALEAUTO', themeColor: 'lime', neonColor: '#84cc16', uiClass: 'border-lime-500/50 text-lime-400 shadow-[0_0_15px_rgba(132,204,22,0.3)] hover:bg-lime-950/30', activeClass: 'bg-lime-500 text-black shadow-[0_0_20px_rgba(132,204,22,0.6)] border-lime-400 font-bold', trackColor: '#4d4d4d', railColor: '#e0e0e0', slotColor: '#111111', width: 20.0, laneSpacing: 10.0, connectionBoxColor: '#9ca3af',
            pieces: [ { id: 'sca_40', label: 'Recta Pro 40', type: 'straight', length: 40.0, cat: 'Rectas' }, { id: 'sca_20', label: 'Media 20', type: 'straight', length: 20.0, cat: 'Rectas' }, { id: 'sca_grid', label: 'Media Parrilla', type: 'straight', length: 20.0, subtype: 'starting_grid', cat: 'Rectas' }, { id: 'sca_10', label: 'Cuarto 10', type: 'straight', length: 10.0, cat: 'Rectas' }, { id: 'sca_connect', label: 'Conexiones', type: 'straight', length: 40.0, subtype: 'analog_connect', cat: 'Rectas' }, { id: 'sca_r1', label: 'R1 (45°)', type: 'curve', radius: 20.0, angle: 45, cat: 'Curvas' }, { id: 'sca_r1_22', label: 'R1 (22.5°)', type: 'curve', radius: 20.0, angle: 22.5, cat: 'Curvas' }, { id: 'sca_r2', label: 'R2 (45°)', type: 'curve', radius: 40.0, angle: 45, cat: 'Curvas' }, { id: 'sca_r2_22', label: 'R2 (22.5°)', type: 'curve', radius: 40.0, angle: 22.5, cat: 'Curvas' }, { id: 'sca_r3', label: 'R3 (22.5°)', type: 'curve', radius: 60.0, angle: 22.5, cat: 'Curvas' }, { id: 'sca_r4', label: 'R4 (22.5°)', type: 'curve', radius: 80.0, angle: 22.5, cat: 'Curvas' } ] }
        };

        const IconWrapper = ({ name, size = 24, className, ...props }) => {
            if (typeof lucide === 'undefined' || !lucide.icons) return null;
            const iconData = lucide.icons[name];
            if (!iconData) return null;
            const [tag, attrs, children = []] = iconData;
            return <svg {...attrs} width={size} height={size} className={className} {...props}>{Array.isArray(children) && children.map(([childTag, childAttrs], index) => React.createElement(childTag, { ...childAttrs, key: index }))}</svg>;
        };
        const icons = ['Trash2','Image','Fuel','Move','Zap','Bluetooth','RotateCw','X','Repeat','PenTool','ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Square','FolderOpen','Save','FileText','Activity','Play','Pause','Flag','GitCommit','ZoomIn','ZoomOut','Crosshair','Undo2','Redo2','Layers','Clock','Hash','Plus','Minus','AlertTriangle', 'Cloud', 'CloudUpload', 'CloudDownload', 'Settings', 'Battery', 'Scale', 'Maximize', 'Minimize', 'User', 'ChevronDown', 'Upload', 'FileJson', 'Eye', 'CheckCircle2'].reduce((acc, name) => { acc[name] = (p) => <IconWrapper name={name} {...p} />; return acc; }, {});
        const { Trash2, Image: ImageIcon, Fuel, Move, Zap, Bluetooth, RotateCw, X, Repeat, PenTool, ArrowUp, ArrowDown, ArrowLeft, ArrowRight, Square, FolderOpen, Save, FileText, Activity, Play, Pause, Flag, GitCommit, ZoomIn, ZoomOut, Crosshair, Undo2, Redo2, Layers, Clock, Hash, Plus, Minus, AlertTriangle, Cloud, CloudUpload, CloudDownload, Settings, Battery, Scale, Maximize, Minimize, User, ChevronDown, Upload, FileJson, Eye, CheckCircle2 } = icons;

        const DrawEngine2D = {
            drawRails: (ctx, l, off, brand) => {
                ctx.strokeStyle = brand.railColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, -off); ctx.lineTo(l, -off); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, off); ctx.lineTo(l, off); ctx.stroke();
                ctx.strokeStyle = brand.slotColor; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, -off); ctx.lineTo(l, -off); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, off); ctx.lineTo(l, off); ctx.stroke();
            },
            drawDigitalWedge: (ctx, l, startLaneY, directionY, s) => {
               ctx.fillStyle = '#d1d5db'; ctx.strokeStyle = '#6b7280'; ctx.lineWidth = 1; ctx.beginPath(); const xStart = l * 0.15, xEnd = l * 0.40, indent = 3 * (s/5), yStraight = startLaneY + (directionY * 1.5), wedgeW = 12 * (s/5); 
               ctx.moveTo(xStart, yStraight); ctx.lineTo(xEnd, yStraight); ctx.lineTo(xEnd - indent, (yStraight + yStraight + directionY*wedgeW)/2); ctx.lineTo(xEnd, yStraight + directionY*wedgeW); ctx.quadraticCurveTo(xStart + (xEnd-xStart)*0.5, yStraight + (directionY * wedgeW * 0.3), xStart, yStraight); ctx.fill(); ctx.stroke();
            },
            drawHazardZone: (ctx, pathFn, s, color = '#facc15') => { ctx.save(); ctx.beginPath(); pathFn(ctx); ctx.clip(); ctx.strokeStyle = color; ctx.lineWidth = 2; const diagSpace = 8 * (s/5); for(let dx = -1000; dx < 1000; dx += diagSpace) { ctx.beginPath(); ctx.moveTo(dx, -500); ctx.lineTo(dx - 500, 500); ctx.stroke(); } ctx.restore(); },
            renderTrack: (ctx, pieces, view, circuitOrigin, activeBrand, selectedPieceId, imageCache, isCircuitMoveMode, boardPoints, boardClosed) => {
                const brand = TRACK_DEFINITIONS[activeBrand]; let cx = view.x + circuitOrigin.x * view.scale, cy = view.y + circuitOrigin.y * view.scale, angle = 0; const newPiecePositions = []; 
                if (boardPoints && boardPoints.length > 0) {
                    ctx.save(); ctx.translate(view.x, view.y); ctx.scale(view.scale, view.scale);
                    if (boardPoints.length > 1) {
                        ctx.beginPath(); ctx.moveTo(boardPoints[0].x, boardPoints[0].y); for(let i=1; i<boardPoints.length; i++) { ctx.lineTo(boardPoints[i].x, boardPoints[i].y); }
                        if (boardClosed) { 
                            ctx.closePath(); 
                            ctx.fillStyle = 'rgba(34, 197, 94, 0.5)'; // Color Verde más intenso
                            ctx.fill(); 
                        } 
                        ctx.lineWidth = 3 / view.scale; ctx.strokeStyle = '#4ade80'; ctx.stroke();
                        if (boardClosed) { ctx.shadowColor = '#4ade80'; ctx.shadowBlur = 15; ctx.stroke(); ctx.shadowBlur = 0; }
                    }
                    boardPoints.forEach((p, i) => { 
                        ctx.beginPath(); 
                        if (i === boardPoints.length - 1 && !boardClosed) { 
                            ctx.fillStyle = '#ef4444'; 
                            const r = (6 + ((Date.now() % 500)/500) * 3) / view.scale; // Parpadeo más rápido para indicar punto activo
                            ctx.arc(p.x, p.y, r, 0, Math.PI*2); 
                            ctx.fill();
                            // Indicador de "Último Punto"
                            ctx.fillStyle = "#fff";
                            ctx.font = `bold ${12/view.scale}px Arial`;
                            ctx.fillText("FIN", p.x + 10/view.scale, p.y);
                        } else { 
                            ctx.fillStyle = '#ffffff'; 
                            ctx.arc(p.x, p.y, 4 / view.scale, 0, Math.PI*2); 
                            ctx.fill();
                        } 
                    }); 
                    ctx.restore();
                }
                
                // INDICADOR DE ORIGEN (MOVIMIENTO DE PISTA)
                if (isCircuitMoveMode) { 
                    ctx.save(); 
                    ctx.translate(cx, cy); 
                    // Cruz más visible y grande
                    ctx.strokeStyle = '#22d3ee'; // Cian brillante
                    ctx.lineWidth = 3; 
                    ctx.shadowColor = '#22d3ee';
                    ctx.shadowBlur = 10;
                    const axisLen = 30; // Más larga
                    ctx.beginPath(); 
                    ctx.moveTo(-axisLen, 0); ctx.lineTo(axisLen, 0); 
                    ctx.moveTo(0, -axisLen); ctx.lineTo(0, axisLen); 
                    ctx.stroke(); 
                    
                    // Círculo central
                    ctx.fillStyle = '#22d3ee';
                    ctx.beginPath(); ctx.arc(0,0, 4, 0, Math.PI*2); ctx.fill();

                    ctx.fillStyle = '#fff'; 
                    ctx.font = 'bold 14px monospace'; 
                    ctx.fillText("ORIGEN PISTA", 8, -8); 
                    ctx.restore(); 
                }

                pieces.forEach((p, index) => {
                    newPiecePositions.push({ uid: p.uid, x: cx, y: cy }); ctx.save(); ctx.translate(cx, cy); ctx.rotate(angle); if (p.invert) ctx.rotate(Math.PI);
                    if (p.uid === selectedPieceId) { ctx.shadowColor = brand.neonColor; ctx.shadowBlur = 30; }
                    const s = view.scale, w = brand.width * s, hw = w / 2, l = p.length * s, laneOff = (brand.laneSpacing / 2) * s, laneSpacing = brand.laneSpacing * s;
                    if (p.customImage && imageCache.current.get(p.uid)) { const img = imageCache.current.get(p.uid); if (p.type === 'straight' || p.type.includes('pit')) ctx.drawImage(img, 0, -hw, l, w); else { const r = p.radius * s; ctx.translate(0, p.direction==='left'?-r:-r); ctx.drawImage(img, 0, p.direction==='left'?0:-r, r, r); } } 
                    else {
                       ctx.lineCap = 'butt'; ctx.lineJoin = 'round';
                       if (p.type === 'straight') {
                            if (['digital_x', 'change_right', 'change_left'].includes(p.subtype)) {
                                ctx.fillStyle = brand.trackColor; ctx.fillRect(0, -hw, l, w); ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.strokeRect(0, -hw, l, w); DrawEngine2D.drawRails(ctx, l, laneOff, brand); ctx.strokeStyle = brand.railColor; ctx.lineWidth = 2.5; ctx.beginPath();
                                if (p.subtype !== 'change_left') { ctx.moveTo(0, -laneOff); ctx.bezierCurveTo(l*0.4, -laneOff, l*0.6, laneOff, l, laneOff); } if (p.subtype !== 'change_right') { ctx.moveTo(0, laneOff); ctx.bezierCurveTo(l*0.4, laneOff, l*0.6, -laneOff, l, -laneOff); } ctx.stroke();
                                if (p.subtype !== 'change_left') DrawEngine2D.drawDigitalWedge(ctx, l, -laneOff, 1, s); if (p.subtype !== 'change_right') DrawEngine2D.drawDigitalWedge(ctx, l, laneOff, -1, s);
                            } else if (p.subtype && p.subtype.includes('single_lane')) {
                                const isLane1 = p.subtype === 'single_lane_1';
                                const yStart = isLane1 ? -hw : 0;
                                const yEnd = isLane1 ? 0 : hw;
                                const railY = isLane1 ? -laneOff : laneOff;
                                ctx.fillStyle = brand.trackColor; 
                                ctx.fillRect(0, yStart, l, hw); 
                                ctx.strokeStyle = '#222'; 
                                ctx.strokeRect(0, yStart, l, hw);
                                ctx.strokeStyle = brand.railColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, railY); ctx.lineTo(l, railY); ctx.stroke();
                                ctx.strokeStyle = brand.slotColor; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, railY); ctx.lineTo(l, railY); ctx.stroke();
                            } else if (p.subtype && p.subtype.includes('pit_parallel')) {
                                const pitW = w/2 + 2*s; const pitY = laneOff + laneSpacing; ctx.fillStyle = brand.trackColor; ctx.fillRect(0, -hw, l, w); ctx.fillRect(0, pitY - pitW/2, l, pitW); ctx.strokeStyle = '#222'; ctx.strokeRect(0, -hw, l, w); ctx.strokeRect(0, pitY - pitW/2, l, pitW);
                                if (p.subtype === 'pit_parallel' || p.subtype === 'pit_parallel_double_x') { const boxMargin = 4 * (s/5); DrawEngine2D.drawHazardZone(ctx, (c) => { c.rect(boxMargin, pitY - pitW/2 + boxMargin, l - boxMargin*2, pitW - boxMargin*2); }, s); ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(boxMargin, pitY - pitW/2 + boxMargin, l - boxMargin*2, pitW - boxMargin*2); ctx.strokeStyle = '#facc15'; ctx.strokeRect(boxMargin, pitY - pitW/2 + boxMargin, l - boxMargin*2, pitW - boxMargin*2); ctx.fillStyle = '#fff'; ctx.font = `bold ${10 * (s/5)}px Arial`; ctx.textAlign = "center"; ctx.fillText("BOXES", l/2, pitY); }
                                if (p.subtype === 'pit_parallel_double_x') { ctx.strokeStyle = brand.railColor; ctx.lineWidth = 2.5; ctx.beginPath(); ctx.moveTo(0, -laneOff); ctx.bezierCurveTo(l*0.4, -laneOff, l*0.6, laneOff, l, laneOff); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, laneOff); ctx.bezierCurveTo(l*0.4, laneOff, l*0.6, -laneOff, l, -laneOff); ctx.stroke(); DrawEngine2D.drawDigitalWedge(ctx, l, -laneOff, 1, s); DrawEngine2D.drawDigitalWedge(ctx, l, laneOff, -1, s); }
                                DrawEngine2D.drawRails(ctx, l, laneOff, brand); ctx.strokeStyle = brand.railColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, pitY); ctx.lineTo(l, pitY); ctx.stroke(); ctx.strokeStyle = brand.slotColor; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, pitY); ctx.lineTo(l, pitY); ctx.stroke();
                            } else if (p.subtype === 'starting_grid') {
                                ctx.fillStyle = brand.trackColor; ctx.fillRect(0, -hw, l, w); ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.strokeRect(0, -hw, l, w); DrawEngine2D.drawRails(ctx, l, laneOff, brand); ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 2.5; const boxLen = 14 * (s/5); const boxWid = laneOff * 1.2; 
                                const p1X = l * 0.7; const p1Y = -laneOff; ctx.beginPath(); ctx.moveTo(p1X - boxLen, p1Y - boxWid/2); ctx.lineTo(p1X, p1Y - boxWid/2); ctx.lineTo(p1X, p1Y + boxWid/2); ctx.lineTo(p1X - boxLen, p1Y + boxWid/2); ctx.stroke();
                                const p2X = l * 0.3; const p2Y = laneOff; ctx.beginPath(); ctx.moveTo(p2X - boxLen, p2Y - boxWid/2); ctx.lineTo(p2X, p2Y - boxWid/2); ctx.lineTo(p2X, p2Y + boxWid/2); ctx.lineTo(p2X - boxLen, p2Y + boxWid/2); ctx.stroke();
                            } else if (p.subtype === 'digital_console') {
                                ctx.fillStyle = brand.trackColor; ctx.fillRect(0, -hw, l, w); ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.strokeRect(0, -hw, l, w); DrawEngine2D.drawRails(ctx, l, laneOff, brand); const consoleH = w * 0.65; const consoleY = hw; ctx.fillStyle = '#b91c1c'; ctx.beginPath(); if (ctx.roundRect) { ctx.roundRect(l*0.1, consoleY, l*0.8, consoleH, 15 * (s/5)); } else { ctx.rect(l*0.1, consoleY, l*0.8, consoleH); } ctx.fill(); ctx.strokeStyle = '#7f1d1d'; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = '#000'; ctx.beginPath(); if (ctx.roundRect) { ctx.roundRect(l*0.2, consoleY + 8*(s/5), l*0.6, consoleH*0.55, 4*(s/5)); } else { ctx.rect(l*0.2, consoleY + 8*(s/5), l*0.6, consoleH*0.55); } ctx.fill(); ctx.fillStyle = '#4ade80'; ctx.font = `bold ${9*(s/5)}px monospace`; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText("00:00", l/2, consoleY + consoleH*0.35); ctx.fillStyle = '#ffcccc'; ctx.font = `bold ${6*(s/5)}px Arial`; ctx.fillText("NINCO", l/2, consoleY + consoleH*0.8);
                            } else if (p.subtype === 'crossing') {
                                ctx.fillStyle = brand.trackColor; ctx.fillRect(0, -hw, l, w); ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.strokeRect(0, -hw, l, w); ctx.strokeStyle = brand.railColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, -laneOff); ctx.bezierCurveTo(l*0.4, -laneOff, l*0.6, laneOff, l, laneOff); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, laneOff); ctx.bezierCurveTo(l*0.4, laneOff, l*0.6, -laneOff, l, -laneOff); ctx.stroke(); ctx.strokeStyle = brand.slotColor; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, -laneOff); ctx.bezierCurveTo(l*0.4, -laneOff, l*0.6, laneOff, l, laneOff); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, laneOff); ctx.bezierCurveTo(l*0.4, laneOff, l*0.6, -laneOff, l, -laneOff); ctx.stroke();
                            } else if (p.subtype === 'chicane_entry') {
                                ctx.fillStyle = brand.trackColor; ctx.fillRect(0, -hw, l, w); ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.strokeRect(0, -hw, l, w); const narrowLane = laneOff * 0.2; ctx.strokeStyle = brand.railColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, -laneOff); ctx.bezierCurveTo(l*0.5, -laneOff, l*0.5, -narrowLane, l, -narrowLane); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, laneOff); ctx.bezierCurveTo(l*0.5, laneOff, l*0.5, narrowLane, l, narrowLane); ctx.stroke(); ctx.strokeStyle = brand.slotColor; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, -laneOff); ctx.bezierCurveTo(l*0.5, -laneOff, l*0.5, -narrowLane, l, -narrowLane); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, laneOff); ctx.bezierCurveTo(l*0.5, laneOff, l*0.5, narrowLane, l, narrowLane); ctx.stroke();
                            } else if (p.subtype === 'chicane_middle') {
                                ctx.fillStyle = brand.trackColor; ctx.fillRect(0, -hw, l, w); ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.strokeRect(0, -hw, l, w); const narrowLane = laneOff * 0.2; DrawEngine2D.drawRails(ctx, l, narrowLane, brand);
                            } else if (p.subtype === 'chicane_exit') {
                                ctx.fillStyle = brand.trackColor; ctx.fillRect(0, -hw, l, w); ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.strokeRect(0, -hw, l, w); const narrowLane = laneOff * 0.2; ctx.strokeStyle = brand.railColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, -narrowLane); ctx.bezierCurveTo(l*0.5, -narrowLane, l*0.5, -laneOff, l, -laneOff); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, narrowLane); ctx.bezierCurveTo(l*0.5, narrowLane, l*0.5, laneOff, l, laneOff); ctx.stroke(); ctx.strokeStyle = brand.slotColor; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, -narrowLane); ctx.bezierCurveTo(l*0.5, -narrowLane, l*0.5, -laneOff, l, -laneOff); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, narrowLane); ctx.bezierCurveTo(l*0.5, narrowLane, l*0.5, laneOff, l, laneOff); ctx.stroke();
                            } else {
                                ctx.fillStyle = brand.trackColor; ctx.fillRect(0, -hw, l, w); ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.strokeRect(0, -hw, l, w); if (p.subtype === 'analog_connect') { DrawEngine2D.drawRails(ctx, l, laneOff, brand); const boxW = l * 0.3; const boxH = w * 0.3; const boxX = (l - boxW) / 2; const boxY = hw; ctx.fillStyle = brand.connectionBoxColor || '#ef4444'; ctx.fillRect(boxX, boxY, boxW, boxH); ctx.strokeStyle = '#222'; ctx.strokeRect(boxX, boxY, boxW, boxH); ctx.fillStyle = '#ffffff'; ctx.font = `bold ${8 * (s/5)}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(brand.name, l/2, boxY + boxH/2); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.setLineDash([10, 10]); ctx.beginPath(); ctx.moveTo(l/2, -hw); ctx.lineTo(l/2, hw); ctx.stroke(); ctx.setLineDash([]); } else if (p.subtype === 'connection') { DrawEngine2D.drawRails(ctx, l, laneOff, brand); const boxW = l * 0.25; const boxH = w * 0.4; const boxX = (l - boxW) / 2; const boxY = hw; ctx.fillStyle = '#111'; ctx.fillRect(boxX, boxY, boxW, boxH); ctx.strokeStyle = '#333'; ctx.strokeRect(boxX, boxY, boxW, boxH); ctx.fillStyle = '#3b82f6'; ctx.beginPath(); ctx.arc(l/2, boxY + boxH/2, boxH*0.3, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.5; const cx = l/2, cy = boxY + boxH/2, r = boxH*0.15; ctx.beginPath(); ctx.moveTo(cx-r/2, cy-r); ctx.lineTo(cx+r/2, cy); ctx.lineTo(cx-r/2, cy+r); ctx.moveTo(cx+r/2, cy-r); ctx.lineTo(cx-r/2, cy+r); ctx.moveTo(cx, cy-r*1.2); ctx.lineTo(cx, cy+r*1.2); ctx.stroke(); ctx.fillStyle = '#fff'; ctx.font = `bold ${6 * (s/5)}px Arial`; ctx.textAlign = 'center'; ctx.fillText("CONEXIÓN", l/2, boxY + boxH * 0.85); } else { DrawEngine2D.drawRails(ctx, l, laneOff, brand); }
                            }
                       } else if (p.type === 'pit_entry') {
                            const pitY = laneOff + laneSpacing; ctx.fillStyle = brand.trackColor; ctx.beginPath(); ctx.moveTo(0, -hw); ctx.lineTo(l, -hw); ctx.lineTo(l, hw); ctx.lineTo(l, pitY + (w/2 * 0.6)); ctx.bezierCurveTo(l*0.5, pitY, l*0.3, hw, 0, hw); ctx.fill(); ctx.strokeStyle = '#222'; ctx.stroke(); DrawEngine2D.drawHazardZone(ctx, (c) => { c.beginPath(); c.moveTo(l, hw); c.lineTo(l, pitY + (w/2 * 0.6)); c.bezierCurveTo(l*0.5, pitY, l*0.3, hw, 0, hw); c.closePath(); }, s); DrawEngine2D.drawRails(ctx, l, laneOff, brand); ctx.strokeStyle = brand.railColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, laneOff); ctx.bezierCurveTo(l*0.3, laneOff, l*0.6, pitY, l, pitY); ctx.stroke(); ctx.strokeStyle = brand.slotColor; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, laneOff); ctx.bezierCurveTo(l*0.3, laneOff, l*0.6, pitY, l, pitY); ctx.stroke(); ctx.fillStyle = '#333'; ctx.beginPath(); ctx.moveTo(l*0.2, laneOff); ctx.lineTo(l*0.25, laneOff+5); ctx.lineTo(l*0.25, laneOff-5); ctx.fill();
                       } else if (p.type === 'pit_exit') {
                            const pitY = laneOff + laneSpacing; const pitBottom = pitY + (w/2 * 0.6); ctx.fillStyle = brand.trackColor; ctx.beginPath(); ctx.moveTo(0, -hw); ctx.lineTo(l, -hw); ctx.lineTo(l, hw); ctx.bezierCurveTo(l*0.7, hw, l*0.5, pitY, 0, pitBottom); ctx.lineTo(0, -hw); ctx.fill(); ctx.strokeStyle = '#222'; ctx.stroke(); DrawEngine2D.drawHazardZone(ctx, (c) => { c.beginPath(); c.moveTo(0, hw); c.lineTo(l, hw); c.bezierCurveTo(l*0.7, hw, l*0.5, pitY, 0, pitBottom); c.closePath(); }, s); DrawEngine2D.drawRails(ctx, l, laneOff, brand); ctx.strokeStyle = brand.railColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0, pitY); ctx.bezierCurveTo(l*0.4, pitY, l*0.7, laneOff, l, laneOff); ctx.stroke(); ctx.strokeStyle = brand.slotColor; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(0, pitY); ctx.bezierCurveTo(l*0.4, pitY, l*0.7, laneOff, l, laneOff); ctx.stroke();
                       } else if (p.type === 'curve') {
                           const r = p.radius * s, isLeft = p.direction === 'left', startA = isLeft ? Math.PI/2 : -Math.PI/2, sweep = (p.angle * Math.PI / 180) * (isLeft ? -1 : 1); 
                           
                           // RENDERIZADO ESPECIAL PARA ROTONDA 3DP (HobbyClassic)
                           if (p.subtype === 'rotonda') {
                               const straightLen = 10.0 * s; // Longitud de la recta añadida
                               const loopRadius = r; 
                               const loopCenterX = r * 1.3; 
                               const singleTrackWidth = (brand.width / 2) * s; 

                               // DIBUJAR RECTA DE ENTRADA/SALIDA (Base del módulo)
                               // Al ser una rotonda que retorna, dibujamos un bloque rectangular previo al loop
                               ctx.fillStyle = brand.trackColor;
                               ctx.fillRect(0, -hw, straightLen, w);
                               ctx.strokeStyle = '#222';
                               ctx.lineWidth = 1;
                               ctx.strokeRect(0, -hw, straightLen, w);
                               
                               // Raíles de la recta
                               DrawEngine2D.drawRails(ctx, straightLen, laneOff, brand);

                               // DESPLAZAR EL LOOP AL FINAL DE LA RECTA
                               ctx.save();
                               ctx.translate(straightLen, 0);

                               // 0. RELLENO INTERIOR (ISLA GRIS)
                               ctx.save();
                               const innerRadius = loopRadius - (singleTrackWidth / 2) - (1 * s); 
                               
                               ctx.beginPath();
                               ctx.moveTo(0, 0); 
                               
                               // Trazamos el contorno interior (Isla)
                               const innerCtrl = loopCenterX * 0.35;
                               ctx.bezierCurveTo(innerCtrl, 0, innerCtrl, -innerRadius, loopCenterX, -innerRadius);
                               ctx.arc(loopCenterX, 0, innerRadius, -Math.PI/2, Math.PI/2, false);
                               ctx.bezierCurveTo(innerCtrl, innerRadius, innerCtrl, 0, 0, 0);
                               ctx.closePath();
                               ctx.clip();

                               // 1. Fondo Gris (Estilo Cemento/Hormigón)
                               ctx.fillStyle = '#64748b'; 
                               ctx.fill();

                               // Borde sutil para la isla
                               ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                               ctx.lineWidth = 1;
                               ctx.stroke();
                               ctx.restore();

                               const defineLoopPath = (ctx) => {
                                   ctx.beginPath();
                                   ctx.moveTo(0, -laneOff);
                                   const controlX = loopCenterX * 0.4;
                                   ctx.bezierCurveTo(controlX, -laneOff, controlX, -loopRadius, loopCenterX, -loopRadius);
                                   ctx.arc(loopCenterX, 0, loopRadius, -Math.PI/2, Math.PI/2, false);
                                   ctx.bezierCurveTo(controlX, loopRadius, controlX, laneOff, 0, laneOff);
                               };

                               // 1. ASFALTO (Estilo NINCO estándar)
                               ctx.lineCap = 'butt';
                               ctx.lineJoin = 'round';
                               
                               // Borde exterior
                               ctx.strokeStyle = '#222'; 
                               ctx.lineWidth = singleTrackWidth + (2 * s); 
                               defineLoopPath(ctx);
                               ctx.stroke();

                               // Superficie de rodadura (Color de la marca, ej: Ninco)
                               ctx.strokeStyle = brand.trackColor; 
                               ctx.lineWidth = singleTrackWidth;
                               defineLoopPath(ctx);
                               ctx.stroke();

                               // Texto discreto
                               ctx.save();
                               ctx.fillStyle = 'rgba(255,255,255,0.2)';
                               ctx.font = `bold ${5 * (s/5)}px Arial`;
                               ctx.textAlign = 'center';
                               ctx.textBaseline = 'middle';
                               ctx.fillText("HC +10", loopCenterX, 0);
                               ctx.restore();

                               // 2. RIELES (Estilo estándar limpio)
                               // Rail metálico sólido (sin discontinuas)
                               ctx.strokeStyle = brand.railColor; 
                               ctx.lineWidth = 3;
                               ctx.setLineDash([]); 
                               defineLoopPath(ctx);
                               ctx.stroke();

                               // Slot negro central
                               ctx.strokeStyle = brand.slotColor; 
                               ctx.lineWidth = 1;
                               defineLoopPath(ctx);
                               ctx.stroke();
                               
                               ctx.restore(); // Restaurar translación del loop

                           } else {
                               // RENDERIZADO CURVA ESTÁNDAR
                               ctx.strokeStyle = brand.trackColor; ctx.lineWidth = w; ctx.beginPath(); ctx.arc(0, isLeft ? -r : r, r, startA, startA + sweep, isLeft); ctx.stroke(); 
                               if (p.subtype === 'ice') { ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = w; ctx.stroke(); } 
                               ctx.strokeStyle = '#222'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0, isLeft ? -r : r, r - hw, startA, startA + sweep, isLeft); ctx.stroke(); ctx.beginPath(); ctx.arc(0, isLeft ? -r : r, r + hw, startA, startA + sweep, isLeft); ctx.stroke(); 
                               ctx.strokeStyle = brand.railColor; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, isLeft ? -r : r, r-laneOff, startA, startA + sweep, isLeft); ctx.stroke(); ctx.beginPath(); ctx.arc(0, isLeft ? -r : r, r+laneOff, startA, startA + sweep, isLeft); ctx.stroke(); ctx.strokeStyle = brand.slotColor; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(0, isLeft ? -r : r, r-laneOff, startA, startA + sweep, isLeft); ctx.stroke(); ctx.beginPath(); ctx.arc(0, isLeft ? -r : r, r+laneOff, startA, startA + sweep, isLeft); ctx.stroke();
                           }
                       }
                    }
                    if (index === 0) { ctx.fillStyle = brand.neonColor; ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI*2); ctx.fill(); } ctx.shadowBlur = 0; 
                    
                    let dx = 0, dy = 0, dAngle = 0; 
                    
                    if (p.subtype === 'rotonda') {
                        dx = 0;
                        dy = 0;
                        dAngle = Math.PI; 
                    } else if (p.type === 'straight' || p.type.includes('pit')) { 
                        dx = p.length * view.scale; 
                    } else if (p.type === 'curve') { 
                        const r = p.radius * view.scale, aRad = (p.angle * Math.PI) / 180; 
                        if (p.direction === 'left') { dx = r * Math.sin(aRad); dy = -r * (1 - Math.cos(aRad)); dAngle = -aRad; } 
                        else { dx = r * Math.sin(aRad); dy = r * (1 - Math.cos(aRad)); dAngle = aRad; } 
                    } 
                    if (p.invert && p.subtype !== 'rotonda') { dx = -dx; dy = -dy; } 
                    ctx.restore(); 
                    const cos = Math.cos(angle), sin = Math.sin(angle); cx += dx * cos - dy * sin; cy += dx * sin + dy * cos; angle += dAngle;
                });
                return newPiecePositions;
            }
        };

        function SlotDesigner() {
          const canvasRef = useRef(null); 
          const [activeBrand, setActiveBrand] = useState('NINCO'); 
          const [activeCategory, setActiveCategory] = useState('Rectas'); 
          const [history, setHistory] = useState([[]]); 
          const [historyStep, setHistoryStep] = useState(0); 
          const pieces = history[historyStep]; 
          
          const [isFullScreen, setIsFullScreen] = useState(false); 
          const [showLoadModal, setShowLoadModal] = useState(false);
          const [previewData, setPreviewData] = useState(null);
          const [previewLoading, setPreviewLoading] = useState(false);
          const previewCanvasRef = useRef(null);
          
          const [view, setView] = useState({ x: window.innerWidth/2, y: window.innerHeight/2, scale: 5.0 }); 
          const [circuitOrigin, setCircuitOrigin] = useState({x: 0, y: 0}); 
          const [selectedPieceId, setSelectedPieceId] = useState(null); 
          const [isCircuitMoveMode, setIsCircuitMoveMode] = useState(false); 
          const [isDragging, setIsDragging] = useState(false); 
          const [dragStart, setDragStart] = useState({ x: 0, y: 0 }); 
          const dragMode = useRef('view'); 
          const lastPointerPos = useRef({ x: 0, y: 0 }); 
          const [bgImage, setBgImage] = useState(null); 
          const [bgSettings, setBgSettings] = useState({ x: 0, y: 0, scale: 5.0, opacity: 0.5 }); 
          const bgImgRef = useRef(null);
          const [showBoardTools, setShowBoardTools] = useState(false); 
          const [boardPoints, setBoardPoints] = useState([]); 
          const [boardClosed, setBoardClosed] = useState(false); 
          const [boardDim, setBoardDim] = useState({ width: 244, height: 122 }); 
          const [boardStep, setBoardStep] = useState(100);
          
          const activePointers = useRef(new Map()); 
          const prevPinchDist = useRef(null); 
          const piecePositions = useRef([]); 
          const imageCache = useRef(new Map()); 

          // EFECTO PARA RENDERIZAR LA PREVISUALIZACIÓN
          useEffect(() => {
              if (!showLoadModal || !previewData || !previewCanvasRef.current) return;
              
              const ctx = previewCanvasRef.current.getContext('2d');
              const width = previewCanvasRef.current.width;
              const height = previewCanvasRef.current.height;
              
              // Limpiar fondo
              ctx.fillStyle = '#0f172a'; // Slate-900
              ctx.fillRect(0, 0, width, height);
              
              // Rejilla sutil de fondo
              ctx.strokeStyle = '#1e293b';
              ctx.lineWidth = 1;
              const gridSize = 20;
              ctx.beginPath();
              for (let x = 0; x <= width; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, height); }
              for (let y = 0; y <= height; y += gridSize) { ctx.moveTo(0, y); ctx.lineTo(width, y); }
              ctx.stroke();

              // 1. PRIMERA PASADA: CALCULAR LÍMITES (BOUNDING BOX)
              // Simulamos el renderizado con escala 1.0 y origen 0,0 para ver dónde caen las piezas
              const tempView = { x: 0, y: 0, scale: 1.0 };
              // Usamos un contexto dummy o simplemente ejecutamos y guardamos las posiciones que retorna renderTrack
              // renderTrack devuelve un array de {uid, x, y} que son los centros de inicio de las piezas
              // IMPORTANTE: renderTrack dibuja. Para evitar parpadeo o dibujo basura, usamos save/restore y clip o alpha 0?
              // Mejor opción: save/restore y no dibujar paths (pero la funcion dibuja).
              // Simplemente guardamos estado, ponemos globalAlpha 0, renderizamos, calculamos bounds, restauramos y pintamos bien.
              
              ctx.save();
              ctx.globalAlpha = 0; 
              // Usamos la marca del archivo, o NINCO por defecto si no hay
              const brandName = previewData.brand || 'NINCO';
              // Renderizar ciegamente
              const positions = DrawEngine2D.renderTrack(ctx, previewData.pieces || [], tempView, {x:0,y:0}, brandName, null, {current: new Map()}, false, previewData.boardPoints, previewData.boardClosed);
              ctx.restore();

              if (positions.length === 0) return;

              // Calcular Min/Max
              let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
              positions.forEach(p => {
                  if (p.x < minX) minX = p.x;
                  if (p.x > maxX) maxX = p.x;
                  if (p.y < minY) minY = p.y;
                  if (p.y > maxY) maxY = p.y;
              });

              // Si hay tablero, también considerarlo
              if (previewData.boardPoints && previewData.boardPoints.length > 0) {
                  previewData.boardPoints.forEach(p => {
                      if (p.x < minX) minX = p.x;
                      if (p.x > maxX) maxX = p.x;
                      if (p.y < minY) minY = p.y;
                      if (p.y > maxY) maxY = p.y;
                  });
              }

              // Calcular escala para encajar
              const contentW = maxX - minX;
              const contentH = maxY - minY;
              const padding = 40; // Margen interno
              
              const scaleX = (width - padding * 2) / Math.max(contentW, 100); // Evitar div/0
              const scaleY = (height - padding * 2) / Math.max(contentH, 100);
              const fitScale = Math.min(scaleX, scaleY); // Usar la escala más restrictiva para que quepa todo

              // Calcular centro del contenido
              const contentCX = (minX + maxX) / 2;
              const contentCY = (minY + maxY) / 2;

              // Calcular offset para centrar en el canvas
              // El view.x/y en renderTrack actúa como offset global de pantalla.
              // Queremos que (contentCX * scale) + offsetX = canvasWidth / 2
              const finalOffsetX = (width / 2) - (contentCX * fitScale);
              const finalOffsetY = (height / 2) - (contentCY * fitScale);

              // 2. SEGUNDA PASADA: RENDERIZADO REAL
              const finalView = { x: finalOffsetX, y: finalOffsetY, scale: fitScale };
              
              // Dibujar sombra para efecto 3D sutil
              ctx.shadowColor = 'rgba(0,0,0,0.5)';
              ctx.shadowBlur = 10;
              ctx.shadowOffsetY = 5;
              
              DrawEngine2D.renderTrack(
                  ctx, 
                  previewData.pieces || [], 
                  finalView, 
                  previewData.circuitOrigin || {x:0, y:0}, // Usar origen del archivo si existe (aunque recalculamos centro visual)
                  brandName, 
                  null, 
                  {current: new Map()}, 
                  false, 
                  previewData.boardPoints, 
                  previewData.boardClosed
              );
              
              ctx.shadowBlur = 0; // Reset

          }, [previewData, showLoadModal]);

          useEffect(() => { const loadingScreen = document.getElementById('loading-screen'); if (loadingScreen) { loadingScreen.style.opacity = '0'; setTimeout(() => loadingScreen.style.display = 'none', 1000); } }, []);
          const currentBrand = TRACK_DEFINITIONS[activeBrand]; const neonClass = currentBrand.uiClass;

          useEffect(() => {
            const canvas = canvasRef.current; if (!canvas) return; const ctx = canvas.getContext('2d'); canvas.width = window.innerWidth; canvas.height = window.innerHeight; 
            ctx.fillStyle = '#32527b'; ctx.fillRect(0,0, canvas.width, canvas.height);
            if (bgImage && bgImgRef.current) { ctx.save(); ctx.translate(view.x + bgSettings.x, view.y + bgSettings.y); ctx.scale(view.scale, view.scale); ctx.globalAlpha = bgSettings.opacity; const w = bgImgRef.current.width * (bgSettings.scale / 100), h = bgImgRef.current.height * (bgSettings.scale / 100); ctx.drawImage(bgImgRef.current, -w/2, -h/2, w, h); ctx.restore(); }
            ctx.strokeStyle = currentBrand.neonColor; ctx.globalAlpha = 0.1; ctx.lineWidth = 1; const gridSize = 10 * view.scale; const offsetX = view.x % gridSize; const offsetY = view.y % gridSize; ctx.beginPath(); for(let x = offsetX; x < ctx.canvas.width; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, ctx.canvas.height); } for(let y = offsetY; y < ctx.canvas.height; y += gridSize) { ctx.moveTo(0, y); ctx.lineTo(ctx.canvas.width, y); } ctx.stroke(); ctx.globalAlpha = 1.0;
            try { piecePositions.current = DrawEngine2D.renderTrack( ctx, pieces, view, circuitOrigin, activeBrand, selectedPieceId, imageCache, isCircuitMoveMode, boardPoints, boardClosed ); } catch (error) { console.error("Error drawing track:", error); }
          }, [pieces, view, bgImage, bgSettings, activeBrand, selectedPieceId, circuitOrigin, isCircuitMoveMode, boardPoints, boardClosed]);

          const pushHistory = (newPieces) => { const newHistory = history.slice(0, historyStep + 1); newHistory.push(newPieces); setHistory(newHistory); setHistoryStep(newHistory.length - 1); };
          const handleUndo = () => { if (historyStep > 0) { setHistoryStep(historyStep - 1); setSelectedPieceId(null); } }; const handleRedo = () => { if (historyStep < history.length - 1) { setHistoryStep(historyStep + 1); setSelectedPieceId(null); } };
          const addPiece = (p, d='left') => pushHistory([...pieces, { ...p, direction: d, uid: Date.now() }]); const removePiece = () => { if (selectedPieceId) { pushHistory(pieces.filter(p => p.uid !== selectedPieceId)); setSelectedPieceId(null); } else if (pieces.length > 0) { pushHistory(pieces.slice(0, -1)); } }; const toggleInvertPiece = () => { if(selectedPieceId) pushHistory(pieces.map(p => p.uid === selectedPieceId ? { ...p, invert: !p.invert } : p)); };
          const saveCircuit = () => { const blob = new Blob([JSON.stringify({ version: "1.0", date: new Date().toISOString(), brand: activeBrand, pieces, circuitOrigin, boardPoints, boardClosed }, null, 2)], { type: "application/json" }); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = `circuito_${activeBrand.toLowerCase()}.json`; document.body.appendChild(link); link.click(); document.body.removeChild(link); };
          
          // NUEVA GESTIÓN DE CARGA CON PREVISUALIZACIÓN
          const handleFileSelectForPreview = (e) => {
              const file = e.target.files[0];
              if (!file) return;
              
              setPreviewLoading(true);
              const reader = new FileReader();
              reader.onload = (event) => {
                  try {
                      const data = JSON.parse(event.target.result);
                      if (data.pieces) {
                          setPreviewData({ ...data, fileName: file.name });
                      } else {
                          alert("El archivo no parece ser un circuito válido.");
                          setPreviewData(null);
                      }
                  } catch (err) {
                      console.error(err);
                      alert("Error al leer el archivo JSON.");
                      setPreviewData(null);
                  } finally {
                      setPreviewLoading(false);
                  }
              };
              reader.readAsText(file);
              e.target.value = ''; // Reset para permitir recargar el mismo archivo
          };

          const confirmLoadCircuit = () => {
              if (previewData) {
                  if (previewData.brand) setActiveBrand(previewData.brand);
                  if (previewData.pieces) {
                      setHistory([previewData.pieces]);
                      setHistoryStep(0);
                  }
                  if (previewData.circuitOrigin) setCircuitOrigin(previewData.circuitOrigin);
                  if (previewData.boardPoints) setBoardPoints(previewData.boardPoints);
                  if (previewData.boardClosed !== undefined) setBoardClosed(previewData.boardClosed);
                  
                  // Cerrar modal y limpiar
                  setShowLoadModal(false);
                  setPreviewData(null);
                  
                  // Centrar vista en el nuevo circuito (pequeño delay para que React renderice)
                  setTimeout(() => {
                      // Recalcular centro podría hacerse aquí si fitToScreen fuera accesible o replicando lógica
                      // fitToScreen(); // Idealmente llamar a esto
                  }, 100);
              }
          };

          const createRectBoard = () => { const w = parseFloat(boardDim.width); const h = parseFloat(boardDim.height); if (isNaN(w) || isNaN(h)) return; setBoardPoints([ { x: -w/2, y: -h/2 }, { x: w/2, y: -h/2 }, { x: w/2, y: h/2 }, { x: -w/2, y: h/2 } ]); setBoardClosed(true); };
          const addBoardPoint = (dx, dy) => { if (boardClosed) { setBoardClosed(false); } let start = { x: 0, y: 0 }; if (boardPoints.length > 0) { start = boardPoints[boardPoints.length - 1]; } else { setBoardPoints([{x:0, y:0}, {x: dx, y: dy}]); return; } setBoardPoints([...boardPoints, { x: start.x + dx, y: start.y + dy }]); };
          const closeBoardPolygon = () => { if (boardPoints.length > 2) setBoardClosed(true); }; const clearBoard = () => { setBoardPoints([]); setBoardClosed(false); };
          const fitToScreen = () => { if (piecePositions.current.length === 0) { setView({ x: window.innerWidth/2, y: window.innerHeight/2, scale: 5.0 }); return; } let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity; piecePositions.current.forEach(p => { if (p.x < minX) minX = p.x; if (p.x > maxX) maxX = p.x; if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y; }); if (minX === Infinity) { setView({ x: window.innerWidth/2, y: window.innerHeight/2, scale: 5.0 }); return; } const centerX = (minX + maxX) / 2; const centerY = (minY + maxY) / 2; const offsetX = (window.innerWidth / 2) - centerX; const offsetY = (window.innerHeight / 2) - centerY; setView(prev => ({ ...prev, x: prev.x + offsetX, y: prev.y + offsetY })); };
          
          const toggleFullScreen = () => {
              if (!document.fullscreenElement) {
                  document.documentElement.requestFullscreen().then(() => setIsFullScreen(true)).catch(err => console.error(err));
              } else {
                  if (document.exitFullscreen) {
                      document.exitFullscreen().then(() => setIsFullScreen(false));
                  }
              }
          };

          const handleWheel = (e) => setView({ ...view, scale: Math.max(0.5, Math.min(20.0, view.scale - e.deltaY * 0.001 * view.scale)) });
          
          // GESTIÓN DE PUNTEROS MEJORADA (Multitouch / Pellizcar)
          const handleDown = (e) => { 
              e.target.setPointerCapture(e.pointerId); 
              activePointers.current.set(e.pointerId, { x: e.clientX, y: e.clientY }); 
              
              // DETECTAR INICIO DE PELLIZCO (2 dedos)
              if (activePointers.current.size === 2) {
                  const points = Array.from(activePointers.current.values());
                  prevPinchDist.current = Math.hypot(points[0].x - points[1].x, points[0].y - points[1].y);
                  return; // Salir para no procesar arrastre mientras se hace zoom
              }

              if (activePointers.current.size === 1) { 
                  lastPointerPos.current = { x: e.clientX, y: e.clientY }; 
                  if (isCircuitMoveMode) { 
                      dragMode.current = 'origin'; 
                      setIsDragging(true); 
                      return; 
                  } 
                  
                  let foundId = null, minD = 1000; 
                  piecePositions.current.forEach((p, idx) => { 
                      const d = Math.sqrt(Math.pow(e.clientX - p.x, 2) + Math.pow(e.clientY - p.y, 2)); 
                      if (d < 40 * (view.scale / 5) && d < minD) { minD = d; foundId = pieces[idx].uid; } 
                  }); 
                  
                  if (foundId) { setSelectedPieceId(foundId); dragMode.current = 'view'; } 
                  else { setSelectedPieceId(null); dragMode.current = 'view'; } 
                  
                  setIsDragging(true); 
                  setDragStart({ x: e.clientX - view.x, y: e.clientY - view.y }); 
              } 
          };

          const handleMoveHandler = (e) => { 
              if (!activePointers.current.has(e.pointerId)) return; 
              activePointers.current.set(e.pointerId, { x: e.clientX, y: e.clientY }); 
              
              // LÓGICA DE ZOOM (PELLIZCAR)
              if (activePointers.current.size === 2) { 
                  const points = Array.from(activePointers.current.values()); 
                  const dist = Math.hypot(points[0].x - points[1].x, points[0].y - points[1].y); 
                  
                  if (prevPinchDist.current !== null) { 
                      const delta = dist - prevPinchDist.current; 
                      const zoomSensitivity = 0.01; // Ajuste de sensibilidad
                      const zoomFactor = delta * zoomSensitivity; 
                      setView(v => ({
                          ...v, 
                          scale: Math.max(0.5, Math.min(20, v.scale + zoomFactor * v.scale))
                      })); 
                  } 
                  prevPinchDist.current = dist; 
                  return; 
              } 
              
              // LÓGICA DE ARRASTRE (1 dedo)
              if (activePointers.current.size === 1 && isDragging) { 
                  const dx = e.clientX - lastPointerPos.current.x;
                  const dy = e.clientY - lastPointerPos.current.y;

                  if (dragMode.current === 'origin') { 
                      if (view.scale > 0) {
                          setCircuitOrigin(prev => ({ 
                              x: prev.x + dx / view.scale, 
                              y: prev.y + dy / view.scale 
                          })); 
                      }
                  } else { 
                      setView(v => ({ ...v, x: v.x + dx, y: v.y + dy })); 
                  } 
                  lastPointerPos.current = { x: e.clientX, y: e.clientY }; 
              } 
          };

          const handleUp = (e) => { 
              e.target.releasePointerCapture(e.pointerId); 
              activePointers.current.delete(e.pointerId); 
              
              if (activePointers.current.size < 2) {
                  prevPinchDist.current = null; // Resetear distancia de pellizco
              }
              
              if (activePointers.current.size === 1) {
                  // Si queda un dedo, re-sincronizar posición para evitar saltos en el arrastre
                  const point = activePointers.current.values().next().value;
                  lastPointerPos.current = { x: point.x, y: point.y };
              } else if (activePointers.current.size === 0) {
                  setIsDragging(false);
              }
          };

          const handleZoomIn = () => setView(v => ({ ...v, scale: Math.min(20, v.scale * 1.2) })); const handleZoomOut = () => setView(v => ({ ...v, scale: Math.max(0.5, v.scale / 1.2) }));
          
          const goToSimulation = () => {
              // 1. Guardar el estado actual en LocalStorage para transferirlo
              const circuitData = {
                  version: "1.0",
                  date: new Date().toISOString(),
                  brand: activeBrand,
                  pieces: pieces,
                  circuitOrigin: circuitOrigin,
                  boardPoints: boardPoints,
                  boardClosed: boardClosed
              };
              
              try {
                  localStorage.setItem('slot_circuit_transfer', JSON.stringify(circuitData));
                  // 2. Navegar al archivo 3D
                  window.location.href = '3d.html';
              } catch (e) {
                  console.error("Error al transferir datos:", e);
                  alert("No se pudo iniciar la simulación. Asegúrate de que las cookies/storage están permitidos.");
              }
          };

          const generateReport = () => { 
              if (pieces.length === 0) { alert("¡Añade pistas antes de generar el informe!"); return; }
              if (!window.jspdf) { alert("Error: Librería PDF no cargada."); return; }

              try {
                  const brand = TRACK_DEFINITIONS[activeBrand];
                  const doc = new window.jspdf.jsPDF();
                  const primaryColor = brand.neonColor; 
                  
                  const hexToRgb = (hex) => {
                      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                      return result ? [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)] : [0,0,0];
                  };
                  const brandRgb = hexToRgb(primaryColor);

                  const canvas = canvasRef.current;
                  const tempCanvas = document.createElement('canvas');
                  tempCanvas.width = canvas.width;
                  tempCanvas.height = canvas.height;
                  const tCtx = tempCanvas.getContext('2d');
                  tCtx.fillStyle = '#ffffff'; 
                  tCtx.fillRect(0,0, tempCanvas.width, tempCanvas.height);
                  tCtx.drawImage(canvas, 0, 0);
                  const imgData = tempCanvas.toDataURL("image/jpeg", 0.9);

                  let len1 = 0; let len2 = 0;
                  let path1_lane = 0; let path2_lane = 1;
                  
                  pieces.forEach(p => {
                      let segmentLen1 = 0; let segmentLen2 = 0;
                      if (p.subtype === 'rotonda') {
                          const rotondaLen = 20 + (Math.PI * p.radius); 
                          segmentLen1 = rotondaLen; segmentLen2 = rotondaLen;
                      } else if (p.type === 'straight' || p.type.includes('pit')) {
                          segmentLen1 = p.length; segmentLen2 = p.length;
                      } else if (p.type === 'curve') {
                          const r = p.radius; const s = brand.laneSpacing; const angle = Math.abs(p.angle);
                          let r0, r1;
                          if (p.direction === 'left') { r0 = r - s/2; r1 = r + s/2; } 
                          else { r0 = r + s/2; r1 = r - s/2; }
                          segmentLen1 = (angle / 360) * 2 * Math.PI * r0;
                          segmentLen2 = (angle / 360) * 2 * Math.PI * r1;
                      }
                      len1 += (path1_lane === 0 ? segmentLen1 : segmentLen2);
                      len2 += (path2_lane === 0 ? segmentLen1 : segmentLen2);
                      if (p.subtype === 'crossing') { path1_lane = 1 - path1_lane; path2_lane = 1 - path2_lane; }
                  });

                  const inventory = {};
                  pieces.forEach(p => {
                      if (!inventory[p.label]) inventory[p.label] = { count: 0, cat: p.cat || 'General' };
                      inventory[p.label].count++;
                  });
                  const inventoryData = Object.entries(inventory)
                      .sort((a, b) => a[1].cat.localeCompare(b[1].cat) || a[0].localeCompare(b[0]))
                      .map(([name, data]) => [name, data.cat.toUpperCase(), data.count]);

                  doc.setFillColor(...brandRgb);
                  doc.rect(0, 0, 210, 35, 'F'); 
                  
                  doc.setTextColor(255, 255, 255);
                  doc.setFont("helvetica", "bold");
                  doc.setFontSize(32);
                  doc.text(brand.name, 15, 22);
                  
                  doc.setFontSize(10);
                  doc.setFont("helvetica", "normal");
                  doc.text("TECHNICAL TRACK REPORT", 15, 28);
                  
                  doc.setFontSize(10);
                  doc.text(`FECHA: ${new Date().toLocaleDateString()}`, 195, 15, { align: "right" });
                  doc.text(`ID: ${Date.now().toString().slice(-6)}`, 195, 20, { align: "right" });
                  doc.text("GENERADO POR SLOT DESIGNER 2D", 195, 28, { align: "right" });

                  doc.setDrawColor(200, 200, 200);
                  doc.setFillColor(255, 255, 255);
                  doc.roundedRect(10, 45, 190, 100, 2, 2, 'FD');
                  
                  const imgRatio = tempCanvas.width / tempCanvas.height;
                  const maxW = 186; 
                  const maxH = 96;
                  let finalW = maxW;
                  let finalH = maxH;

                  if (imgRatio > (maxW / maxH)) {
                      finalH = maxW / imgRatio;
                  } else {
                      finalW = maxH * imgRatio;
                  }
                  
                  const finalX = 12 + (maxW - finalW) / 2;
                  const finalY = 47 + (maxH - finalH) / 2;

                  doc.addImage(imgData, 'JPEG', finalX, finalY, finalW, finalH);
                  
                  const statsY = 155;
                  doc.setFontSize(12);
                  doc.setTextColor(0, 0, 0);
                  doc.setFont("helvetica", "bold");
                  doc.text("METRÍCAS DEL CIRCUITO", 10, statsY);
                  doc.setDrawColor(...brandRgb);
                  doc.line(10, statsY + 2, 70, statsY + 2);

                  const drawCard = (x, title, value, sub, isHighlight = false) => {
                      doc.setFillColor(isHighlight ? brandRgb[0] : 245, isHighlight ? brandRgb[1] : 245, isHighlight ? brandRgb[2] : 245);
                      doc.roundedRect(x, statsY + 8, 45, 25, 2, 2, 'F');
                      
                      doc.setFontSize(7);
                      doc.setTextColor(isHighlight ? 255 : 100);
                      doc.setFont("helvetica", "bold");
                      doc.text(title, x + 4, statsY + 15);
                      
                      doc.setFontSize(14);
                      doc.setTextColor(isHighlight ? 255 : 0);
                      doc.text(value, x + 4, statsY + 24);
                      
                      // CORRECCIÓN: Calcular ancho ANTES de cambiar el tamaño de fuente para el sufijo
                      const valueWidth = doc.getTextWidth(value);
                      
                      doc.setFontSize(8);
                      doc.text(sub, x + 4 + valueWidth + 2, statsY + 24);
                  };

                  const maxLen = Math.max(len1, len2);
                  drawCard(10, "LONGITUD CARRIL 1", (len1/100).toFixed(2), "m");
                  drawCard(60, "LONGITUD CARRIL 2", (len2/100).toFixed(2), "m");
                  drawCard(110, "PIEZAS TOTALES", pieces.length.toString(), "uds", true);
                  
                  const barX = 165;
                  doc.setFontSize(7);
                  doc.setTextColor(100);
                  doc.text("BALANCE", barX, statsY + 15);
                  
                  doc.setFillColor(220, 220, 220);
                  doc.rect(barX, statsY + 18, 35, 3, 'F');
                  doc.setFillColor(...brandRgb);
                  doc.rect(barX, statsY + 18, 35 * (len1/maxLen), 3, 'F');
                  doc.setFontSize(6);
                  doc.text("L1", barX - 3, statsY + 20.5);
                  
                  doc.setFillColor(220, 220, 220);
                  doc.rect(barX, statsY + 24, 35, 3, 'F');
                  doc.setFillColor(...brandRgb);
                  doc.rect(barX, statsY + 24, 35 * (len2/maxLen), 3, 'F');
                  doc.text("L2", barX - 3, statsY + 26.5);

                  const diff = Math.abs(len1 - len2);
                  doc.setFontSize(8);
                  if (diff < 10) {
                      doc.setTextColor(0, 150, 0);
                      doc.text("COMPENSADO", barX, statsY + 32);
                  } else {
                      doc.setTextColor(200, 0, 0);
                      doc.text(`DIF: ${(diff/100).toFixed(2)}m`, barX, statsY + 32);
                  }

                  doc.autoTable({
                      startY: statsY + 40,
                      head: [['PIEZA / REFERENCIA', 'CATEGORÍA', 'CANTIDAD']],
                      body: inventoryData,
                      theme: 'grid',
                      headStyles: { 
                          fillColor: brandRgb, 
                          textColor: 255, 
                          font: "helvetica", 
                          fontStyle: 'bold',
                          halign: 'left',
                          cellPadding: 3
                      },
                      bodyStyles: {
                          font: "helvetica",
                          fontSize: 9,
                          textColor: 50,
                          cellPadding: 3
                      },
                      columnStyles: {
                          0: { cellWidth: 'auto', fontStyle: 'bold' },
                          1: { cellWidth: 40, halign: 'center', textColor: 100 },
                          2: { cellWidth: 30, halign: 'center', fontStyle: 'bold', fontSize: 10 }
                      },
                      alternateRowStyles: { fillColor: [248, 248, 248] },
                      margin: { bottom: 20 },
                      foot: [['TOTAL', '', pieces.length]],
                      footStyles: { fillColor: [240, 240, 240], textColor: 0, fontStyle: 'bold', halign: 'center' }
                  });

                  const pageCount = doc.internal.getNumberOfPages();
                  for (let i = 1; i <= pageCount; i++) {
                      doc.setPage(i);
                      doc.setFontSize(8);
                      doc.setTextColor(150);
                      doc.line(10, 285, 200, 285);
                      doc.text(`Informe generado por Slot Designer 2D - Página ${i} de ${pageCount}`, 105, 290, { align: "center" });
                  }

                  doc.save(`Informe_${brand.name}_${new Date().toISOString().slice(0,10)}.pdf`);

              } catch (err) {
                  console.error("Error PDF:", err);
                  alert("Hubo un error al generar el PDF. Revisa la consola.");
              }
          };

          const currentItems = TRACK_DEFINITIONS[activeBrand].pieces.filter(p=>p.cat === activeCategory || (activeCategory === 'RALLY' && p.cat === 'RALLY')); const categories = ['Rectas', 'Curvas', 'Digital', 'Boxes']; if (TRACK_DEFINITIONS[activeBrand].pieces.some(p => p.cat === 'RALLY')) categories.push('RALLY');

          return (
            <div className={`flex flex-col h-[100dvh] w-full bg-[#0a0a0a] overflow-hidden font-sans select-none text-gray-200 ${isCircuitMoveMode ? 'cursor-move' : 'cursor-grab'}`}>
              
              {/* MODAL DE CARGA CON PREVISUALIZACIÓN */}
              {showLoadModal && (
                  <div className="absolute inset-0 z-[100] bg-black/80 backdrop-blur-md flex items-center justify-center animate-in" onClick={() => setShowLoadModal(false)}>
                      <div className="bg-[#0f172a] w-[900px] h-[550px] rounded-2xl border border-[#39ff14]/30 shadow-[0_0_60px_rgba(57,255,20,0.2)] flex overflow-hidden" onClick={e => e.stopPropagation()}>
                          
                          {/* PANEL IZQUIERDO: SELECCIÓN */}
                          <div className="w-1/3 bg-black/40 border-r border-white/10 p-6 flex flex-col gap-6">
                              <div className="flex flex-col gap-2">
                                  <h2 className="text-xl font-black text-white tracking-widest flex items-center gap-2"><FolderOpen className="text-[#39ff14]"/> ABRIR</h2>
                                  <p className="text-xs text-gray-400">Selecciona un archivo .JSON de tu ordenador para previsualizarlo antes de cargarlo.</p>
                              </div>

                              <label className="flex-1 border-2 border-dashed border-gray-700 hover:border-[#39ff14] rounded-xl flex flex-col items-center justify-center gap-4 cursor-pointer transition-colors group bg-gray-900/50 hover:bg-gray-800/50">
                                  <div className="w-16 h-16 rounded-full bg-gray-800 group-hover:bg-[#39ff14]/20 flex items-center justify-center transition-colors">
                                      <Upload className="text-gray-500 group-hover:text-[#39ff14] w-8 h-8 transition-colors"/>
                                  </div>
                                  <span className="text-sm font-bold text-gray-400 group-hover:text-white uppercase tracking-wide">Seleccionar Archivo</span>
                                  <input type="file" accept=".json" className="hidden" onChange={handleFileSelectForPreview}/>
                              </label>

                              <div className="text-center text-[10px] text-gray-600 font-mono">
                                  FORMATO SOPORTADO: JSON (TrackSchema v1.0)
                              </div>
                          </div>

                          {/* PANEL DERECHO: VISOR */}
                          <div className="flex-1 flex flex-col relative bg-[#0a0a0a]">
                              {/* HEADER DEL VISOR */}
                              <div className="h-14 border-b border-white/10 flex items-center justify-between px-6 bg-[#0f172a]">
                                  <div className="flex items-center gap-3">
                                      <div className="p-1.5 bg-[#39ff14]/10 rounded border border-[#39ff14]/30">
                                          <FileJson size={16} className="text-[#39ff14]"/>
                                      </div>
                                      <div>
                                          <h3 className="text-sm font-bold text-white leading-none mb-0.5">
                                              {previewData ? previewData.fileName : 'Ningún archivo seleccionado'}
                                          </h3>
                                          <span className="text-[10px] text-gray-500 font-mono">
                                              {previewData ? `${(new Blob([JSON.stringify(previewData)]).size / 1024).toFixed(1)} KB` : '---'}
                                          </span>
                                      </div>
                                  </div>
                                  {previewData && (
                                      <div className={`px-2 py-1 rounded text-[9px] font-bold border ${TRACK_DEFINITIONS[previewData.brand]?.uiClass || 'border-gray-600 text-gray-400'}`}>
                                          {previewData.brand || 'DESCONOCIDO'}
                                      </div>
                                  )}
                              </div>

                              {/* CANVAS PREVIEW */}
                              <div className="flex-1 relative overflow-hidden flex items-center justify-center bg-black/50">
                                  {previewLoading && (
                                      <div className="absolute inset-0 flex flex-col items-center justify-center z-10 bg-black/80">
                                          <div className="w-8 h-8 border-2 border-[#39ff14] border-t-transparent rounded-full animate-spin mb-2"></div>
                                          <span className="text-xs text-[#39ff14] font-bold tracking-widest">ANALIZANDO...</span>
                                      </div>
                                  )}
                                  
                                  {!previewData && !previewLoading && (
                                      <div className="flex flex-col items-center opacity-30">
                                          <Eye size={48} className="mb-2"/>
                                          <span className="text-xs font-bold tracking-widest">VISTA PREVIA NO DISPONIBLE</span>
                                      </div>
                                  )}

                                  <canvas 
                                      ref={previewCanvasRef} 
                                      width={600} 
                                      height={350} 
                                      className={`w-full h-full object-contain ${!previewData ? 'hidden' : 'block'}`}
                                  />
                                  
                                  {/* Overlay Info Flotante */}
                                  {previewData && (
                                      <div className="absolute bottom-4 left-4 flex gap-2">
                                          <div className="bg-black/80 backdrop-blur border border-white/10 px-3 py-1.5 rounded text-xs font-mono text-gray-300">
                                              <span className="text-[#39ff14] font-bold">{previewData.pieces?.length || 0}</span> PIEZAS
                                          </div>
                                          <div className="bg-black/80 backdrop-blur border border-white/10 px-3 py-1.5 rounded text-xs font-mono text-gray-300">
                                              {previewData.boardClosed ? <span className="text-green-400 flex items-center gap-1"><CheckCircle2 size={10}/> TABLERO</span> : <span className="text-gray-500">SIN TABLERO</span>}
                                          </div>
                                      </div>
                                  )}
                              </div>

                              {/* FOOTER ACCIONES */}
                              <div className="h-16 border-t border-white/10 flex items-center justify-end gap-3 px-6 bg-[#0f172a]">
                                  <button onClick={() => { setShowLoadModal(false); setPreviewData(null); }} className="px-5 py-2 text-xs font-bold text-gray-400 hover:text-white transition uppercase tracking-wider">
                                      Cancelar
                                  </button>
                                  <button 
                                      onClick={confirmLoadCircuit} 
                                      disabled={!previewData}
                                      className={`px-8 py-2.5 rounded-lg text-xs font-black uppercase tracking-widest transition-all flex items-center gap-2 ${!previewData ? 'bg-gray-800 text-gray-500 cursor-not-allowed' : 'bg-[#39ff14] text-black shadow-[0_0_20px_rgba(57,255,20,0.4)] hover:shadow-[0_0_30px_rgba(57,255,20,0.6)] hover:scale-105 active:scale-95'}`}
                                  >
                                      <FolderOpen size={14} className="fill-current"/> CARGAR CIRCUITO
                                  </button>
                              </div>
                          </div>
                      </div>
                  </div>
              )}

              <div className="bg-[#0f172a] border-b border-[#1e293b] shadow-lg z-20 flex flex-col shrink-0 relative">
                  <div className="flex items-center gap-4 px-4 py-3 overflow-x-auto hide-scrollbar bg-black/50"> 
                      <div className="flex items-center gap-2 mr-4">
                          <h1 className="text-xl font-black tracking-tighter shrink-0" style={{ color: '#39ff14', textShadow: '0 0 15px rgba(57, 255, 20, 0.9), 0 0 30px rgba(57, 255, 20, 0.5)' }}> TRACK DESIGNER 2D </h1> 
                      </div>
                      <div className="flex gap-4">{Object.keys(TRACK_DEFINITIONS).map(k => (<button key={k} onClick={()=>{setActiveBrand(k); setHistory([[]]); setHistoryStep(0); }} className={`text-sm font-bold px-4 py-2 rounded-full uppercase tracking-widest transition-all shrink-0 border ${activeBrand === k ? TRACK_DEFINITIONS[k].activeClass : 'bg-transparent border-[#334155] text-gray-500 hover:text-gray-300 hover:border-gray-400'}`}>{TRACK_DEFINITIONS[k].name}</button>))}</div> </div>
                  <div className="flex items-center overflow-x-auto hide-scrollbar px-4 py-2 gap-2 bg-[#1e293b] shadow-[inset_0_10px_20px_rgba(0,0,0,0.5)]"> 
                      {categories.map(cat => ( <button key={cat} onClick={() => setActiveCategory(cat)} className="px-6 py-2 text-xs font-bold rounded-lg uppercase shrink-0 transition-all duration-300 border backdrop-blur-sm" style={{ borderColor: activeCategory === cat ? currentBrand.neonColor : '#334155', color: activeCategory === cat ? '#ffffff' : '#64748b', backgroundColor: activeCategory === cat ? `${currentBrand.neonColor}20` : 'transparent', boxShadow: activeCategory === cat ? `0 0 15px ${currentBrand.neonColor}60, inset 0 0 10px ${currentBrand.neonColor}20` : 'none', textShadow: activeCategory === cat ? `0 0 10px ${currentBrand.neonColor}` : 'none' }}> {cat} </button> ))} 
                  </div>
                  <div className="h-20 flex items-center overflow-x-auto px-4 gap-3 bg-[#0f172a] border-t border-[#334155]"> {currentItems.map(p => ( <div key={p.id} className="shrink-0"> {p.type === 'curve' ? ( <div className={`flex flex-col border rounded-lg overflow-hidden w-32 ${neonClass}`}> <div className="bg-black/40 px-2 py-1 text-[10px] font-bold text-center border-b border-inherit">{p.label}</div> <div className="flex divide-x divide-inherit"><button onClick={()=>addPiece(p,'left')} className="flex-1 py-3 text-[10px] font-bold hover:bg-white/10 transition-colors">IZQ</button><button onClick={()=>addPiece(p,'right')} className="flex-1 py-3 text-[10px] font-bold hover:bg-white/10 transition-colors">DER</button></div> </div> ) : ( <button onClick={()=>addPiece(p)} className={`flex items-center gap-3 px-4 py-3 border rounded-lg active:scale-95 transition-all duration-200 ${neonClass} hover:bg-white/5`}><div className="flex flex-col items-start"><span className="text-xs font-bold">{p.label}</span><span className="text-[9px] opacity-60">{p.length}cm</span></div>{p.cat==='Digital' && <Zap size={16}/>}</button> )} </div> ))} </div>
                  <div className="flex items-center overflow-x-auto hide-scrollbar px-4 py-3 gap-3 bg-[#1e293b] border-t border-[#334155]">
                          <button onClick={() => setIsCircuitMoveMode(!isCircuitMoveMode)} title="Mover la pista sobre el tablero" className={`flex items-center justify-center gap-2 px-5 py-2.5 rounded-lg border transition-all font-bold text-xs shrink-0 ${isCircuitMoveMode ? 'bg-orange-500/20 text-orange-300 border-orange-500 shadow-[0_0_20px_rgba(249,115,22,0.6)]' : 'bg-transparent text-orange-400 border-orange-500/50 shadow-[0_0_10px_rgba(249,115,22,0.2)] hover:bg-orange-500/10 hover:border-orange-400 hover:shadow-[0_0_15px_rgba(249,115,22,0.4)] hover:text-orange-200'}`}><Move size={16}/> MOVER PISTA</button>
                          <button onClick={saveCircuit} title="Guardar Circuito" className="flex items-center justify-center gap-2 px-5 py-2.5 bg-transparent text-blue-400 border border-blue-500/50 rounded-lg hover:bg-blue-500/10 hover:border-blue-400 hover:text-blue-200 hover:shadow-[0_0_15px_rgba(59,130,246,0.4)] shadow-[0_0_10px_rgba(59,130,246,0.2)] transition-all font-bold text-xs shrink-0"><Save size={16}/> GUARDAR</button>
                          <button onClick={() => setShowLoadModal(true)} title="Cargar Circuito con Vista Previa" className="flex items-center justify-center gap-2 px-5 py-2.5 bg-transparent text-yellow-400 border border-yellow-500/50 rounded-lg hover:bg-yellow-500/10 hover:border-yellow-400 hover:text-yellow-200 hover:shadow-[0_0_15px_rgba(234,179,8,0.4)] shadow-[0_0_10px_rgba(234,179,8,0.2)] transition-all font-bold text-xs cursor-pointer shrink-0"><FolderOpen size={16}/> ABRIR</button>
                          <button onClick={generateReport} title="Generar Informe" className="flex items-center justify-center gap-2 px-5 py-2.5 bg-transparent text-teal-400 border border-teal-500/50 rounded-lg hover:bg-teal-500/10 hover:border-teal-400 hover:text-teal-200 hover:shadow-[0_0_15px_rgba(20,184,166,0.4)] shadow-[0_0_10px_rgba(20,184,166,0.2)] transition-all font-bold text-xs shrink-0"><FileText size={16}/> INFORME</button>
                          <button onClick={() => setShowBoardTools(!showBoardTools)} title="Configurar Tablero" className="flex items-center justify-center gap-2 px-5 py-2.5 bg-transparent text-green-400 border border-green-500/50 rounded-lg hover:bg-green-500/10 hover:border-green-400 hover:text-green-200 hover:shadow-[0_0_15px_rgba(34,197,94,0.4)] shadow-[0_0_10px_rgba(34,197,94,0.2)] transition-all font-bold text-xs shrink-0"><Square size={16}/> TABLERO</button>
                          <button onClick={toggleFullScreen} title={isFullScreen ? "Salir Pantalla Completa" : "Pantalla Completa"} className="flex items-center justify-center gap-2 px-5 py-2.5 bg-transparent text-purple-400 border border-purple-500/50 rounded-lg hover:bg-purple-500/10 hover:border-purple-400 hover:text-purple-200 hover:shadow-[0_0_15px_rgba(168,85,247,0.4)] shadow-[0_0_10px_rgba(168,85,247,0.2)] transition-all font-bold text-xs shrink-0"> {isFullScreen ? <Minimize size={16}/> : <Maximize size={16}/>} FULLSCREEN </button>
                  </div>
              </div>

              <div className={`flex-1 relative overflow-hidden ${isCircuitMoveMode ? 'cursor-move' : (isDragging ? 'cursor-grabbing' : 'cursor-grab')}`}>
                  <canvas ref={canvasRef} className="absolute top-0 left-0 w-full h-full touch-none block" onContextMenu={(e) => e.preventDefault()} onPointerDown={handleDown} onPointerMove={handleMoveHandler} onPointerUp={handleUp} onPointerCancel={handleUp} onPointerLeave={handleUp} onWheel={handleWheel}/>
                  {showBoardTools && ( 
                      <div onPointerDown={(e)=>e.stopPropagation()} className="absolute top-24 right-4 bg-[#0f172a]/95 border border-green-500 shadow-[0_0_30px_rgba(34,197,94,0.3)] p-3 rounded-xl w-60 backdrop-blur-xl z-50 animate-in origin-top-right"> 
                          <div className="flex justify-between items-center mb-3 pb-2 border-b border-green-500/30"> 
                              <h3 className="text-xs font-black text-green-400 flex gap-2 drop-shadow-[0_0_5px_rgba(34,197,94,0.8)] items-center tracking-widest">
                                  <Square size={14}/> 
                                  TABLERO
                              </h3> 
                              <button onClick={()=>setShowBoardTools(false)} className="text-green-500 hover:text-white transition hover:scale-110 bg-green-500/10 p-0.5 rounded"><X size={14}/></button> 
                          </div> 
                          
                          <div className="mb-3"> 
                              <div className="text-[8px] text-green-300/70 font-black mb-2 uppercase tracking-[0.1em]">Medidas (Rectángulo)</div> 
                              <div className="flex gap-1 mb-2 items-center"> 
                                  <div className="flex-1 relative">
                                      <input type="number" value={boardDim.width} onChange={(e)=>setBoardDim({...boardDim, width:e.target.value})} className="w-full bg-black/60 border border-green-500/30 rounded px-2 py-1 text-xs text-center text-white focus:border-green-400 outline-none font-mono"/> 
                                      <span className="absolute right-1 top-1 text-[8px] text-gray-500">cm</span>
                                  </div>
                                  <span className="text-green-500 font-bold text-[10px]">x</span> 
                                  <div className="flex-1 relative">
                                      <input type="number" value={boardDim.height} onChange={(e)=>setBoardDim({...boardDim, height:e.target.value})} className="w-full bg-black/60 border border-green-500/30 rounded px-2 py-1 text-xs text-center text-white focus:border-green-400 outline-none font-mono"/> 
                                      <span className="absolute right-1 top-1 text-[8px] text-gray-500">cm</span>
                                  </div>
                              </div> 
                              <button onClick={createRectBoard} className="w-full py-1.5 bg-green-600 hover:bg-green-500 text-black font-black rounded text-[10px] shadow-[0_0_10px_rgba(34,197,94,0.3)] transition-all uppercase tracking-wider transform active:scale-95">Crear Rectángulo</button> 
                          </div> 
                          
                          <div className="border-t border-green-500/30 pt-3"> 
                              <div className="text-[8px] text-green-300/70 font-black mb-2 uppercase tracking-[0.1em]">Manual (Punto a Punto)</div> 
                              
                              <div className="flex items-center justify-between mb-3 bg-green-900/20 p-1.5 rounded border border-green-500/20"> 
                                  <span className="text-[10px] text-green-400 font-bold uppercase ml-1">Longitud:</span> 
                                  <div className="flex items-center gap-1">
                                      <input type="number" value={boardStep} onChange={(e)=>setBoardStep(e.target.value)} className="w-12 bg-black/50 border border-green-500/50 rounded px-1 py-0.5 text-xs text-center text-white focus:border-green-400 outline-none font-mono font-bold"/> 
                                      <span className="text-[9px] text-gray-400">cm</span>
                                  </div>
                              </div> 
                              
                              <div className="grid grid-cols-3 gap-1 mb-3"> 
                                  {/* ARRIBA */}
                                  <div className="col-start-2"> 
                                      <button onClick={()=>addBoardPoint(0, -parseFloat(boardStep || 0))} className="w-full h-10 bg-black/40 hover:bg-green-500/20 text-green-400 rounded flex flex-col items-center justify-center border border-green-500/30 hover:border-green-400 hover:shadow-[0_0_10px_rgba(34,197,94,0.2)] transition-all group active:scale-95"> 
                                          <span className="text-[9px] font-black tracking-widest">ARRIBA</span>
                                      </button> 
                                  </div> 
                                  {/* IZQUIERDA */}
                                  <div className="col-start-1 row-start-2"> 
                                      <button onClick={()=>addBoardPoint(-parseFloat(boardStep || 0), 0)} className="w-full h-10 bg-black/40 hover:bg-green-500/20 text-green-400 rounded flex flex-col items-center justify-center border border-green-500/30 hover:border-green-400 hover:shadow-[0_0_10px_rgba(34,197,94,0.2)] transition-all group active:scale-95"> 
                                          <span className="text-[9px] font-black tracking-widest">IZQ</span>
                                      </button> 
                                  </div> 
                                  {/* CENTRO (VISUAL) */}
                                  <div className="col-start-2 row-start-2 flex items-center justify-center opacity-30"> 
                                      <div className="w-1.5 h-1.5 bg-green-500 rounded-full animate-ping"></div>
                                  </div> 
                                  {/* DERECHA */}
                                  <div className="col-start-3 row-start-2"> 
                                      <button onClick={()=>addBoardPoint(parseFloat(boardStep || 0), 0)} className="w-full h-10 bg-black/40 hover:bg-green-500/20 text-green-400 rounded flex flex-col items-center justify-center border border-green-500/30 hover:border-green-400 hover:shadow-[0_0_10px_rgba(34,197,94,0.2)] transition-all group active:scale-95"> 
                                          <span className="text-[9px] font-black tracking-widest">DER</span>
                                      </button> 
                                  </div> 
                                  {/* ABAJO */}
                                  <div className="col-start-2 row-start-3"> 
                                      <button onClick={()=>addBoardPoint(0, parseFloat(boardStep || 0))} className="w-full h-10 bg-black/40 hover:bg-green-500/20 text-green-400 rounded flex flex-col items-center justify-center border border-green-500/30 hover:border-green-400 hover:shadow-[0_0_10px_rgba(34,197,94,0.2)] transition-all group active:scale-95"> 
                                          <span className="text-[9px] font-black tracking-widest">ABAJO</span>
                                      </button> 
                                  </div> 
                              </div> 
                              
                              <div className="flex gap-2 mt-3 pt-3 border-t border-green-500/20"> 
                                  <button onClick={closeBoardPolygon} className="flex-[2] py-2 bg-green-500/20 hover:bg-green-500/40 text-green-300 border border-green-500/50 hover:border-green-400 font-bold rounded text-[9px] flex items-center justify-center gap-1 transition-all hover:shadow-[0_0_15px_rgba(34,197,94,0.3)] active:scale-95 uppercase tracking-widest">
                                      <Square size={10} className="fill-current"/> CIERRE
                                  </button> 
                                  <button onClick={clearBoard} className="flex-1 py-2 bg-red-500/10 hover:bg-red-500/30 text-red-400 border border-red-500/30 hover:border-red-400 font-bold rounded text-[9px] flex items-center justify-center gap-1 transition-all active:scale-95">
                                      <Trash2 size={10}/> BORRAR
                                  </button> 
                              </div> 

                              <div className="mt-2">
                                  <button onClick={()=>setShowBoardTools(false)} className="w-full py-1.5 bg-gray-800/50 hover:bg-gray-700 text-gray-400 font-bold rounded text-[9px] border border-gray-700 transition-all uppercase tracking-widest hover:text-white">
                                      SALIR DEL TABLERO
                                  </button>
                              </div>
                          </div> 
                      </div> 
                  )}
                  <div className="absolute bottom-6 left-0 w-full flex justify-center md:justify-start md:left-6 md:w-auto pointer-events-none z-30"> 
                      <div className="flex gap-3 pointer-events-auto bg-black/40 p-3 rounded-xl backdrop-blur-sm border border-cyan-500/30 shadow-[0_0_20px_rgba(6,182,212,0.2)] relative"> 
                          <button onClick={handleUndo} className={`flex flex-col items-center justify-center w-20 h-20 bg-gray-900/90 border border-cyan-500 shadow-[0_0_15px_rgba(6,182,212,0.4)] rounded-lg text-cyan-400 hover:bg-cyan-950/50 active:scale-95 active:shadow-none transition-all group ${historyStep === 0 ? 'opacity-50 cursor-not-allowed' : 'hover:shadow-[0_0_25px_rgba(6,182,212,0.6)]'}`} title="Deshacer última acción" disabled={historyStep === 0}> <Undo2 size={24} className="mb-1 group-hover:scale-110 transition-transform"/> <span className="text-[9px] font-black tracking-widest">DESHACER</span> </button> 
                          <button onClick={handleRedo} className={`flex flex-col items-center justify-center w-20 h-20 bg-gray-900/90 border border-cyan-500 shadow-[0_0_15px_rgba(6,182,212,0.4)] rounded-lg text-cyan-400 hover:bg-cyan-950/50 active:scale-95 active:shadow-none transition-all group ${historyStep < history.length - 1 ? 'hover:shadow-[0_0_25px_rgba(6,182,212,0.6)]' : 'opacity-50 cursor-not-allowed'}`} title="Rehacer acción deshecha" disabled={historyStep === history.length - 1}> <Redo2 size={24} className="mb-1 group-hover:scale-110 transition-transform"/> <span className="text-[9px] font-black tracking-widest">REHACER</span> </button> 
                          <button onClick={handleZoomOut} className="flex flex-col items-center justify-center w-20 h-20 bg-gray-900/90 border border-cyan-500 shadow-[0_0_15px_rgba(6,182,212,0.4)] rounded-lg text-cyan-400 hover:bg-cyan-950/50 active:scale-95 active:shadow-none transition-all group hover:shadow-[0_0_25px_rgba(6,182,212,0.6)]"> <ZoomOut size={24} className="mb-1 group-hover:scale-110 transition-transform"/> <span className="text-[9px] font-black tracking-widest">ALEJAR</span> </button> 
                          <button onClick={fitToScreen} className="flex flex-col items-center justify-center w-20 h-20 bg-gray-900/90 border border-cyan-500 shadow-[0_0_15px_rgba(6,182,212,0.4)] rounded-lg text-cyan-400 hover:bg-cyan-950/50 active:scale-95 active:shadow-none transition-all group hover:shadow-[0_0_25px_rgba(6,182,212,0.6)]"> <Crosshair size={24} className="mb-1 group-hover:rotate-45 transition-transform"/> <span className="text-[9px] font-black tracking-widest">CENTRAR</span> </button> 
                          <button onClick={handleZoomIn} className="flex flex-col items-center justify-center w-20 h-20 bg-gray-900/90 border border-cyan-500 shadow-[0_0_15px_rgba(6,182,212,0.4)] rounded-lg text-cyan-400 hover:bg-cyan-950/50 active:scale-95 active:shadow-none transition-all group hover:shadow-[0_0_25px_rgba(6,182,212,0.6)]"> <ZoomIn size={24} className="mb-1 group-hover:scale-110 transition-transform"/> <span className="text-[9px] font-black tracking-widest">ACERCAR</span> </button> 
                          
                          {/* BOTÓN SIMULACIÓN ESPECTACULAR */}
                          <button onClick={goToSimulation} className="flex flex-col items-center justify-center w-20 h-20 bg-gray-900/90 border border-[#39ff14] shadow-[0_0_20px_rgba(57,255,20,0.5)] rounded-lg text-[#39ff14] hover:bg-green-950/50 active:scale-95 active:shadow-none transition-all group hover:shadow-[0_0_35px_rgba(57,255,20,0.9)] hover:scale-105 relative overflow-hidden"> 
                              <div className="absolute inset-0 bg-gradient-to-t from-[#39ff14]/10 to-transparent opacity-50"></div>
                              <Play size={24} className="mb-1 group-hover:scale-125 transition-transform fill-current z-10 drop-shadow-[0_0_8px_rgba(57,255,20,1)]"/> 
                              <span className="text-[9px] font-black tracking-widest z-10 drop-shadow-[0_0_5px_rgba(0,0,0,0.8)]">SIMULACIÓN</span> 
                          </button> 
                      </div> 
                  </div>
                  {selectedPieceId && pieces.find(p=>p.uid===selectedPieceId) && ( <div className={`absolute top-6 right-6 bg-[#0f172a]/90 p-5 rounded-2xl shadow-2xl border w-72 backdrop-blur-md ${neonClass}`}> <div className="flex justify-between items-start mb-4 border-b border-white/10 pb-3"><div><h3 className="text-lg font-black text-white">{pieces.find(p=>p.uid===selectedPieceId).label}</h3></div><button onClick={()=>setSelectedPieceId(null)} className="hover:text-white text-gray-500 transition"><X size={20}/></button></div> <div className="space-y-4"> <button onClick={toggleInvertPiece} className="w-full flex items-center justify-center gap-3 px-4 py-4 rounded-xl text-xs font-bold bg-[#1e293b] text-gray-400 border border-[#334155] hover:bg-[#334155] transition shadow-[0_0_10px_rgba(255,255,255,0.1)] hover:shadow-[0_0_15px_rgba(255,255,255,0.2)]"><Repeat size={18}/> INVERTIR 180°</button> <div className="pt-3 border-t border-white/10"><button onClick={removePiece} className="w-full flex items-center justify-center gap-2 px-4 py-4 bg-red-900/20 text-red-500 border border-red-900/50 rounded-xl text-xs font-bold hover:bg-red-900/40 transition shadow-[0_0_10px_rgba(239,68,68,0.2)] hover:shadow-[0_0_20px_rgba(239,68,68,0.4)]"><Trash2 size={18}/> ELIMINAR</button></div> </div> </div> )}
              </div>
            </div>
          );
        }

        const rootElement = document.getElementById('root');
        if (rootElement) {
            try {
                const root = ReactDOM.createRoot(rootElement);
                root.render(<SlotDesigner />);
            } catch (error) {
                console.error("Error al renderizar:", error);
                document.getElementById('loading-screen').innerHTML = `<h2 class="text-xl text-red-500 font-bold">Error fatal</h2><p class="text-white">${error.message}</p>`;
            }
        } else { console.error("No se encontró el elemento root"); }
    </script>
</body>
</html>